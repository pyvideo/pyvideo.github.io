<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_michael-dymshtis.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2017-06-13T00:00:00+00:00</updated><entry><title>Process Monitoring on Sequences of System Call Vectors</title><link href="https://pyvideo.org/pycon-israel-2017/process-monitoring-on-sequences-of-system-call-vectors.html" rel="alternate"></link><published>2017-06-13T00:00:00+00:00</published><updated>2017-06-13T00:00:00+00:00</updated><author><name>Michael Dymshtis</name></author><id>tag:pyvideo.org,2017-06-13:pycon-israel-2017/process-monitoring-on-sequences-of-system-call-vectors.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;We introduce a methodology for efficient monitoring of processes running on hosts in a corporate network. The methodology is based on collecting streams of system calls produced by all or selected processes on the hosts, and sending them over the network to an analytics server, where machine learning algorithms based on LSTM (Long-Short Term Memory) are used to identify changes in process behavior, due to malicious activity, hardware failures, or software errors. System call streams are enormous, and an efficient representation with performance guarantees independent of the level of activity on the host must be used. Some earlier work was based on processing of sequential streams of system calls, which does not scale well. Other approaches rely on computing frequencies of short sequences (n-grams) of system calls over a fixed time window. However, in this case information about temporal dynamics of the process is lost. In our methodology, vectors of counts of system calls are collected and sent for every monitored process at fixed short time intervals, e.g., 1 second. However, the analytics server processes sequences of system call vectors over longer time spans. This way, the performance guarantee is maintained through sending fixed amount of data per time unit independently of the activity on the host, but the temporal behavior is at least partially preserved. By varying the vector and sequence time durations, a balance between network and CPU load, on one hand, and monitoring accuracy, on the other hand, can be adjusted depending on performance and accuracy requirements.&lt;/p&gt;
</summary></entry></feed>