<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Thu, 02 May 2019 09:00:00 +0000</lastBuildDate><item><title>To trust or to test?: Automated testing of scientific projects with pytest</title><link>https://pyvideo.org/pycon-us-2019/to-trust-or-to-test-automated-testing-of-scientific-projects-with-pytest.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Many researchers rely strongly on numerical computations. Unfortunately,
testing scientific code is a hard task. Often there is no ground truth
available for comparison and the end result of the simulation is unknown
even to the code developer herself/himself. Often the user-base of the
scientific code is small and the work environment does not provide
incentives for testing.&lt;/p&gt;
&lt;p&gt;However, there are always parts of the code that are relatively easy to
cover by Unit Tests. Scientific pipelines could and should have
Regressions Tests, which ensure that previously developed software still
performs after changes in the code, or in external libraries and
computational environment. An automatic test suite should not be a
burden and can become a game-changer even for a small programming
project.&lt;/p&gt;
&lt;p&gt;This tutorial is meant to be an introduction to testing in general and
to pytest library. Pytest is a full feature tool to test the Python
code, it offers a simple way to get started and scales from simple unit
testing to complex functional testing. We will begin with simple assert
statements and finish with pytest.fixture and pytest.parametrization.
The tutorial will also cover a simple integration of the tests suit with
Continuous Integration platforms using GitHub and Travis/CircleCI.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Audience:&lt;/strong&gt; The tutorial is designed for scientist and data scientists
who would like incorporate testing to their everyday work. We expect
that people know basic Python and NumPy, and are familiar with simple
shell commands. Basic knowledge of Git/GitHub will be useful in the
second half of the tutorial.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Dorota Jarecka</dc:creator><pubDate>Thu, 02 May 2019 09:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-05-02:pycon-us-2019/to-trust-or-to-test-automated-testing-of-scientific-projects-with-pytest.html</guid><category>tutorial</category></item><item><title>Object oriented Programming with NumPy using CPython &amp; PyPy</title><link>https://pyvideo.org/scipy-2014/object-oriented-programming-with-numpy-using-cpyt.html</link><description>&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;In the paper we compare object-oriented implementations of an advection
algorithm written in Python, C++ and modern FORTRAN. The main angles of
comparison are code brevity and syntax clarity (and hence
maintainability and auditability) as well as performance. A notable
performance gain when switching from CPython to PyPy will be
exemplified, and the reasons for it will be briefly explained.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In the paper we compare object-oriented implementations of an advection
algorithm written in Python, C++ and modern FORTRAN. The MPDATA
advection algorithm (Multidimensional Positive-Definite Advective
Transport Algorithm) used as a core of weather, ocean and climate
modelling systems serves as an example.&lt;/p&gt;
&lt;p&gt;In the context of scientific programming, employment of object-oriented
programming (OOP) techniques may help to improve code readability, and
hence its auditability and maintainability. OOP offers, in particular,
the possibility to reproduce in the program code the mathematical
&amp;quot;blackboard abstractions&amp;quot; used in the literature. We compare how the
choice of a particular language influences syntax clarity, code length
and the performance: CPU time and memory usage.&lt;/p&gt;
&lt;p&gt;The Python implementation of MPDATA is based on NumPy. Its performance
is compared with C++/Blitz++ and FORTRAN implementations. A notable
performance gain when switching from the standard CPython to PyPy will
be exemplified, and the reasons for it will be briefly explained.
Discussion of other selected solutions for improving the NumPyâ€™s
relatively poor performance will be also presented.&lt;/p&gt;
&lt;p&gt;This talk will describe and extend on the key findings presented in
&lt;a class="reference external" href="http://arxiv.org/abs/1301.1334"&gt;http://arxiv.org/abs/1301.1334&lt;/a&gt;.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Dorota Jarecka</dc:creator><pubDate>Wed, 09 Jul 2014 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2014-07-09:scipy-2014/object-oriented-programming-with-numpy-using-cpyt.html</guid><category>pypy</category></item></channel></rss>