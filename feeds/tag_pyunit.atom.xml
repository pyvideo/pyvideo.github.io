<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/tag_pyunit.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2011-03-11T00:00:00+00:00</updated><entry><title>Introduction to unittest (a.k.a. PyUnit) (#96)</title><link href="https://pyvideo.org/pycon-us-2010/pycon-2010--introduction-to-unittest--a-k-a--pyun.html" rel="alternate"></link><published>2010-02-19T00:00:00+00:00</published><updated>2010-02-19T00:00:00+00:00</updated><author><name>Chander Ganesan</name></author><id>tag:pyvideo.org,2010-02-19:pycon-us-2010/pycon-2010--introduction-to-unittest--a-k-a--pyun.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Introduction to Unittest (a.k.a. PyUnit)&lt;/p&gt;
&lt;p&gt;Presented by Chander K Ganesan&lt;/p&gt;
&lt;p&gt;The PyUnit (unittest) unit testing framework provides an easy-to-use set
of tools and techniques to add robust unit testing to your Python code.
By integrating unit testing in their code, developers allow for a robust
set of tools to quickly and easily identify &amp;quot;broken&amp;quot; code.&lt;/p&gt;
&lt;p&gt;In this session we'll explore the unittest module and demonstrate how to
leverage PyUnit for unit testing.&lt;/p&gt;
</summary><category term="pycon"></category><category term="pycon2010"></category><category term="pyunit"></category><category term="testing"></category><category term="unittest"></category></entry><entry><title>Units Need Testing Too</title><link href="https://pyvideo.org/pycon-us-2011/pycon-2011--units-need-testing-too.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Gary Bernhardt</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--units-need-testing-too.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Units Need Testing Too&lt;/p&gt;
&lt;p&gt;Presented by Gary Bernhardt&lt;/p&gt;
&lt;p&gt;Python's long history of testing has focused primarily on integration-
and system-level tests: slow-running tests executing lots of code. These
are a great start, but many of them can be transformed into unit-level
tests. True unit tests are orders of magnitude faster (about 1ms each),
providing quicker feedback and better failure localization. We'll look
at why and how to write them.&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;Python has a wonderful legacy in testing: PyUnit has been in the
standard library since March, 2001, and it was already a year old by
then. We adopted browser driving quickly, and we do it at huge scale
with great test parallelization infrastructure.&lt;/p&gt;
&lt;p&gt;Big tests aren't everything, though. In the Python world, true unit
tests are somewhat rare, and even most tests written with the unittest
library are integration tests. These tests are slow to execute and don't
localize failure as well as smaller, focused tests. They leave us with
two options: either run them rarely, sacrificing feedback, or run them
often, sacrificing speed.&lt;/p&gt;
&lt;p&gt;Writing true unit tests removes that particular trade-off. When your
tests execute in a millisecond each, you can afford to run a thousand of
them every time you save a source file. This talk will discuss what unit
tests really are, why they matter, and how to write them in Python.&lt;/p&gt;
</summary><category term="pycon"></category><category term="pycon2011"></category><category term="pyunit"></category><category term="testing"></category><category term="unittests"></category></entry></feed>