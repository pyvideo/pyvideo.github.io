<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_josue-balandrano-coronel.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2018-10-15T00:00:00+00:00</updated><entry><title>Building Workflows With Celery</title><link href="https://pyvideo.org/djangocon-us-2018/building-workflows-with-celery.html" rel="alternate"></link><published>2018-10-15T00:00:00+00:00</published><updated>2018-10-15T00:00:00+00:00</updated><author><name>Josue Balandrano Coronel</name></author><id>tag:pyvideo.org,2018-10-15:djangocon-us-2018/building-workflows-with-celery.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Task Queues is a topic which most developers will eventually have to
dive into, specially in today’s web development world. The idea is
really simple: whenever one has any functionality which might take too
long to perform, one can spawn a process which will take care of this
functionality without having to block the app’s main loop. A task queue
will use worker processes to execute these long-running tasks and the
user does not have to wait until the task is done. Instead, an
acknowledged message is presented to de user while the task is executed
in the background. This concept is really important when building web
applications. HTTP Requests have timeout and making the user wait a long
time for something to finish is not a good user experience practice.
Usually, these tasks are used in groups creating a workflow where the
work is distributed into smaller tasks.&lt;/p&gt;
&lt;p&gt;Celery is usually the first project one encounters when searching for
task queues and Django. I have been using Celery for over four years.
The Celery project is one of the most robust task queues out there. It
is certainly not the only task queue. And, it can be difficult planning
the correct architecture for a specific workflow. This talk will explain
enough of Celery’s basics to understand how to build workflows with
Celery.&lt;/p&gt;
&lt;p&gt;Building workflows with Celery is never straight forward. This is mainly
because Celery offers the building blocks to build workflows but it
tries to move out of the way. By not being too intrusive, Celery allows
building complex workflows. I will explain common patters and tips to
successfully use celery to build workflow of different complexities.&lt;/p&gt;
&lt;div class="section" id="outline"&gt;
&lt;h4&gt;Outline&lt;/h4&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Introduction&lt;ol class="arabic"&gt;
&lt;li&gt;Basics of Celery’s architecture&lt;/li&gt;
&lt;li&gt;Caveats when using Celery&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Workflows&lt;ol class="arabic"&gt;
&lt;li&gt;What are Workflows and why use them&lt;/li&gt;
&lt;li&gt;Celery’s building blocks&lt;/li&gt;
&lt;li&gt;Common workflows techniques&lt;/li&gt;
&lt;li&gt;Real World Example&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Tips and Tricks&lt;ol class="arabic"&gt;
&lt;li&gt;Caveats&lt;/li&gt;
&lt;li&gt;Testing&lt;/li&gt;
&lt;li&gt;Local development&lt;/li&gt;
&lt;li&gt;Using Celery in production&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</summary></entry><entry><title>WebSockets: Intro to Messaging</title><link href="https://pyvideo.org/djangocon-us-2016/websockets-intro-to-messaging.html" rel="alternate"></link><published>2016-08-10T00:00:00+00:00</published><updated>2016-08-10T00:00:00+00:00</updated><author><name>Josue Balandrano Coronel</name></author><id>tag:pyvideo.org,2016-08-10:djangocon-us-2016/websockets-intro-to-messaging.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;DjangoCon US 2016 - WebSockets: Intro to Messaging by Josue Balandrano Coronel&lt;/p&gt;
&lt;p&gt;Today’s web applications demand information to be delivered immediately after it is available. This is a huge step from where everything started, simple HTTP blocking requests. In order to solve this Server Side Events (SSE) and Websockets (WS) were created. SSE works from the server to the client only and it uses the HTTP protocol. WS is bidirectional and implements a layer on top of HTTP. WS started to get more momentum and now most of modern web browsers support it.&lt;/p&gt;
</summary></entry></feed>