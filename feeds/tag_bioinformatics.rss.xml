<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Sat, 23 Feb 2019 00:00:00 +0000</lastBuildDate><item><title>Python’s role in accelerating biomedical science</title><link>https://pyvideo.org/pycon-philippines-2019/pythons-role-in-accelerating-biomedical-science.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python has an increasingly important role in biomedical research due to its diverse modules available and the flexibility for utilization. In this talk, I will showcase how Python helped us in solving questions in cancer evolution.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Li Ting Chen</dc:creator><pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-02-23:pycon-philippines-2019/pythons-role-in-accelerating-biomedical-science.html</guid><category>biomedicine</category><category>biomedical-data-science</category><category>bioinformatics</category></item><item><title>Using network community clustering algorithms to aid determination of protein structures</title><link>https://pyvideo.org/pydata-barcelona-2017/using-network-community-clustering-algorithms-to-aid-determination-of-protein-structures.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;How can you best exploit the information on the protein structures that we already know in order to solve the (many more) that we don’t know? That’s the question we try to solve in our group and this talk will show our use of community clustering on the use case of aiding protein structure solution.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Abstract&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The study of proteins is extremely relevant to many fields, ranging from medicine to industrial processes. If a cell was a factory, proteins would be the workers, performing very specific tasks in a production chain, in which a failure at any of the steps might affect the others. In order to really understand the function of proteins, there are a number of biochemical techniques that we can apply, but to get a really accurate description of their mechanisms we need to have information up to their atomic level. Proteins are composed by different combinations of 20 amino acids which form chains and result in an intricate and functional structure. We know the final shape of the protein is dependent from its sequence but we can't (currently) predict the outcome of a given sequence, so we need experimental techniques to obtain this information. We can't directly look a protein with a microscope and see its three-dimensional atomic arrangement. There are biophysical techniques that allow us to get low-resolution shapes or surfaces of them, but the only current method that provides atomic detail is x-ray diffraction. In contrast to microscopy, were after illuminating your sample you can, with the appropriate lenses, transform back your reflected rays in an image, in x-ray diffraction we only get the Fourier transform of our protein's structure, that is, its diffraction pattern, but we lose the phase information from the diffracted rays. This problem, known as the phase problem, is an issue in structure solution, because, compared to the intensities of the diffraction pattern, phases provide much more information about our protein's structure. Phases can be computed from a coordinates model, so, if there is a structure of a protein that is expected to be similar (in terms of their coordinates) to an unknown one, it can be used to provide initial estimates of the phases and then improve them until the problem structure is solved.&lt;/p&gt;
&lt;p&gt;Proteins do not adopt random shapes. There are forces that act on them and, according to the chemical properties of the amino acids and the context they have around, they will arrange in particular forms. The first level of structure formed is what we call secondary structure, which is formed of alpha helices and beta strands. These are very general and are present in all kind of proteins. As letters in different books, which are general if looked at independently but can acquire a quite different meaning in 'El Quijote' than in '50 Shades of Grey', these structure fragments alone have a different meaning than when set in a context with other structure elements. Yet, even combinations of a few elements can still be general and frequent, and have a sense, such as the phrase 'Once upon a time' in so many tales. In the protein case, particular small combinations of alpha helices and beta strands should also appear more frequently and can be studied on their different contexts. In a way, we could say that, protein structures, from a top down view, look quite different between them, but from a bottom up one, when we go to small pieces, they look much more similar.&lt;/p&gt;
&lt;p&gt;In our group, we try to exploit these properties of protein structures for solving two types of problems. One is a search problem, consisting in understanding which is the best way in which to break down a larger model of a protein similar to an unknown one in order to refine it and get the correct phases and solve the structure. The other one is more of a prediction problem, in which we want to find structural units in the database of solved structures in order to help us interpret them and extract new information from this vast amount of data. In order to solve both problems we need a numerical description of our system than can help us describing its geometrical features in an accurate way. We have developed a description of such secondary structure fragments based on what we call characteristic vectors, that we also employ to represent the relations between such elements. This description can be implemented in a network graph that allows to use community clustering algorithms on it in order to evaluate simultaneously all the relations between the elements of the structure and find its communities.&lt;/p&gt;
&lt;p&gt;From the technical point of view, the language we use for our development is Python, and the tool in which our graphs are implemented is python-igraph. There are a number of community clustering algorithms available and deciding which is the best for our case and which metrics to use to describe our structures has been an interesting process that we want to share with you. In this talk I will explain our research and development on this topic and I will link the general descriptions to our current and successful use case, possibly leaving open questions on what can we do more!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Claudia Millán</dc:creator><pubDate>Sun, 21 May 2017 15:45:00 +0200</pubDate><guid isPermaLink="false">tag:pyvideo.org,2017-05-21:pydata-barcelona-2017/using-network-community-clustering-algorithms-to-aid-determination-of-protein-structures.html</guid><category>bioinformatics</category><category>protein</category></item><item><title>Scikit bio: A Bioinformatics Library for Data Scientists, Students, and Developers</title><link>https://pyvideo.org/scipy-2015/scikit-bio-a-bioinformatics-library-for-data-scientists-students-and-developers.html</link><description></description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jai Ram Rideout</dc:creator><pubDate>Thu, 09 Jul 2015 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2015-07-09:scipy-2015/scikit-bio-a-bioinformatics-library-for-data-scientists-students-and-developers.html</guid><category>scikit-bio</category><category>bioinformatics</category></item><item><title>All-by-all learning of protein complexes from mass spectrometry data</title><link>https://pyvideo.org/scipy-2013/all-by-all-learning-of-protein-complexes-from-mas-.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Authors: Blake Borgeson, Center for Systems and Synthetic Biology,
University of Texas at Austin; Cuihong Wa&lt;/p&gt;
&lt;p&gt;Track: Bioinformatics&lt;/p&gt;
&lt;p&gt;Despite our knowledge that the vast majority of life's processes at a
cellular level are carried out by complexes of multiple proteins,
knowledge of all the complexes formed in a cell and their members is a
distant goal. By using a new approach first applied to human cell lines
by collaborators Havugimana and Hart, et al, consisting of 1) subjecting
biological samples to many levels of many types of fractionations, 2)
using mass spectrometry to quantify protein levels in each fraction, and
3) processing the data through a machine learning pipeline, we are able
to seek complexes using a high-throughput all-by-all approach. By
incorporating additional functional genomic information into our
learning process, we are able to reconstruct maps of complexes that
rival in quality and far surpass in coverage those generated with
previously-used, much more labor-intensive methods such as affinity
purification followed by mass spectrometry, or AP-MS. Here, using 6,000
mass spectrometry experiments from more than 60 fractionated biological
samples from human, mouse, sea urchin, fly and worm, we predict with
high confidence hundreds (~500) of expected and putative novel conserved
complexes. IPython, SciPy, and scikit-learn are the foundational tools
used to handle data integration and machine learning, and an integrated
python environment for this work has been critical to the speed of
progress.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Blake Borgeson</dc:creator><pubDate>Mon, 01 Jul 2013 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2013-07-01:scipy-2013/all-by-all-learning-of-protein-complexes-from-mas-.html</guid><category>bioinformatics</category><category>machine learning</category></item><item><title>Detection and characterization of interactions of genetic risk factors</title><link>https://pyvideo.org/scipy-2013/detection-and-characterization-of-interactions-of-.html</link><description>&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Much attention has been focused on the application of machine learning
approaches to detection of gene interactions. Our method is based upon
training a supervised learning algorithm to detect disease, and then
quantifying the effect on prediction accuracy when alleles of two or
more genes are perturbed to unmutated in patterns so as to reveal and
characterize gene interactions.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Detection and characterization of interactions of genetic risk factors
in disease&lt;/p&gt;
&lt;p&gt;Authors: Francis-Lyon, Patricia, University of San Francisco; Belvadi,
Shashank, University of San Francisco; Wang, Lin, University of San
Francisco&lt;/p&gt;
&lt;p&gt;Track: Bioinformatics&lt;/p&gt;
&lt;p&gt;It is well known that two or more genes can interact so as to enhance or
suppress incidence of disease, such that the observed phenotype differs
from when the genes act independently. The effect of a gene allele at
one locus can mask or modify the effect of alleles at one or more other
loci. Discovery and characterization of such gene interactions is
pursued as a valuable aid in early diagnosis and treatment of disease.
Also it is hoped that the characterization of such interactions will
shed light on biological and biochemical pathways that are involved in a
specific disease, leading to new therapeutic treatments.&lt;/p&gt;
&lt;p&gt;Much attention has been focused on the application of machine learning
approaches to detection of gene interactions. Our method is based upon
training a supervised learning algorithm to detect disease, and then
quantifying the effect on prediction accuracy when alleles of two or
more genes are perturbed to unmutated in patterns so as to reveal and
characterize gene interactions. We utilize this approach with both a
neural network and a support vector machine.&lt;/p&gt;
&lt;p&gt;We test the versatility of our approach using seven disease models, some
of which model gene interactions and some of which model biological
independence. In every disease model we correctly detect the presence or
absence of 2-way and 3-way gene interactions using our method with both
neural network and support vector machine. We also correctly
characterize all of the interactions as to the epistatic effect of gene
alleles in both 2-way and 3-way gene interactions. We conclude that
machine learning approaches can be used to successfully detect and also
characterize gene interactions in disease.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Lin Wang</dc:creator><pubDate>Mon, 01 Jul 2013 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2013-07-01:scipy-2013/detection-and-characterization-of-interactions-of-.html</guid><category>bioinformatics</category><category>machine learning</category></item><item><title>MIST: Micro-Simulation Tool to Support Disease Modeling</title><link>https://pyvideo.org/scipy-2013/mist-micro-simulation-tool-to-support-disease-mo-0.html</link><description>&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;MIST stands for Misco-Simulation Tool. It is a modeling and simulation
framework that supports computational Chronic Disease Modeling
activities.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Authors: Jacob Barhak&lt;/p&gt;
&lt;p&gt;Track: Bioinformatics&lt;/p&gt;
&lt;p&gt;MIST stands for Misco-Simulation Tool. It is a modeling and simulation
framework that supports computational Chronic Disease Modeling
activities. It is a fork from the IEST = Indirect Estimation and
Simulation Tool GPL modeling framework.&lt;/p&gt;
&lt;p&gt;MIST removes complexity associated with the estimation engine, with
parameter definitions, and with rule restrictions. This significantly
simplifies the system and allows its development in the Micro-simulation
path less encumbered.&lt;/p&gt;
&lt;p&gt;The incentive to split MIST was to adapt the code to use newer compiler
technology to speed up simulations. There is wrong skepticism in the
medical disease modeling community towards using Interpreters for
simulations due to performance issues. The use of advanced compiler
technology with Python may remedy this misconception and provide
optimized python based simulations. MIST is a first step in this
direction.&lt;/p&gt;
&lt;p&gt;MIST takes care of a few documented and known issues. It also moves to
use new scientific Python stacks such as Anaconda and PythonXY as its
platform. This improves its accessibility to less sophisticated users
that can now benefit from easier installation.&lt;/p&gt;
&lt;p&gt;The Reference Model for disease progression intends to use MIST as its
main platform. Yet MIST is equipped with a Micro-simulation compiler
designed to accommodate Monte Carlo simulations for other purposes.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jacob Barhak</dc:creator><pubDate>Mon, 01 Jul 2013 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2013-07-01:scipy-2013/mist-micro-simulation-tool-to-support-disease-mo-0.html</guid><category>bioinformatics</category></item><item><title>The KBase Narrative Bioinformatics for the 99%</title><link>https://pyvideo.org/scipy-2014/the-kbase-narrative-bioinformatics-for-the-99.html</link><description>&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;The KBase Narrative builds on the IPython Notebook to provide a
multi-user, virtualized Bioinformatics Laboratory Notebook that brings
Experimental/Wetlab Biologists, students and the bio-curious into the
world of Computational Biology. Tools for genome annotation,
visualization, metabolic modeling and more are made available in a
collaborative and educational web interface.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Computional Biology and Experimental Biology are two specialities that
would deeply benefit from more interaction - computationalists need
access to data, biologists in wetlabs need computational tools. The
KBase Narrative is a computerized laboratory notebook that puts the
power of the KBase predictive biology platform into the hands of
experimentalists and students. KBase provides cluster computation,
analysis and modeling pipelines, large public datasets and a &amp;quot;pluggable&amp;quot;
architecture for future services. The Narrative is an interface enabling
the sharing of data, approaches and workflows on KBase. It also serves
as a teaching tool and publishing platform, allowing other scientists
and students to observe and reproduce the processes that led to the
published result.&lt;/p&gt;
&lt;p&gt;The KBase Narrative is based on the IPython Notebook, extended in the
following ways:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Notebooks are stored in a remote object store that enables
versioning, provenance and sharing&lt;/li&gt;
&lt;li&gt;Support for multiple users has been added, based on OAuth
authentication against a &amp;quot;cloud&amp;quot; authentication service (Globus
Online)&lt;/li&gt;
&lt;li&gt;A framework for dynamically building form inputs for services using
Python introspection and the IPython Traitlets package (a version of
Traits) and displaying the output in JS visualization widgets&lt;/li&gt;
&lt;li&gt;A Docker based provisioning system that builds and tears down
sandboxed IPython Notebook servers on demand, providing a scalable,
reasonable safe and easy to use environment for running hosted
IPython notebooks with much smaller overhead than VM's&lt;/li&gt;
&lt;li&gt;A heavily modified user interface that has been designed to support
computational biology workflows&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The current KBase Narrative was developed over the span of roughly 6
months by a small team of developers and user interface experts - the
short time scale was possible due to the huge amount of functionality
already provided by the IPython Notebook, and taking advantage of the
productivity and power of the Python language.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Bill Rihl</dc:creator><pubDate>Mon, 14 Jul 2014 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2014-07-14:scipy-2014/the-kbase-narrative-bioinformatics-for-the-99.html</guid><category>bioinformatics</category></item><item><title>SociaLite: Python intergrated query Language for Data Analysis</title><link>https://pyvideo.org/scipy-2014/socialite-python-intergrated-query-language-for.html</link><description>&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;SociaLite is a Python-integrated query language for data analysis. It
makes scientific data analysis simple, yet achieves fast performance
with its compiler optimizations. We support relational tables and
operations in SociaLite as well as Python integration, which makes it
easy to implement various analysis algorithms, including Blast algorithm
and genome assembly algorithm in bioinformatics.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;SociaLite is a Python-integrated query language for distributed data
analysis.
It makes scientific data analysis simple, yet achieves fast
performance with its compiler optimizations. The performance of
SociaLite is often more than three orders of magnitude faster than
Hadoop programs, and close to optimized C programs. For example,
PageRank algorithm can be implemented in just 2 lines of SociaLite
query, which runs nearly as fast as an optimal parallelized C code.&lt;/p&gt;
&lt;p&gt;SociaLite supports well-known high-level concepts to make data analysis
easy for non-expert programmers. We support relational tables for
storing data, and relational operations, such as join, selection, and
projection, for processing the data. Moreover, SociaLite queries are
fully integrated with Python, so both SociaLite and Python code can be
used to implement data analysis logic. For the integration with Python,
we support embedding and extending SociaLite, where embedding supports
using SociaLite queries directly in Python code, and extending supports
using Python functions in SociaLite queries.&lt;/p&gt;
&lt;p&gt;The Python integration makes it easy to implement various analysis
algorithms in SociaLite and Python. For example, the BLAST algorithm in
bioinformatics can be implemented in just a few lines of SociaLite
queries and Python code. Also genome assembly algorithm -- generating a
De Bruijn graph and applying Eulerian cycle algorithm -- can be simply
implemented. In the talk, I will demonstrate these algorithms in
SociaLite as well as more general algorithms such as K-means clustering
and logistic regression.&lt;/p&gt;
&lt;p&gt;The SociaLite queries are compiled to highly optimized
parallel/distributed code; we apply optimizations such as pipelined
evaluation and prioritization. The runtime system also speeds up the
performance; for example, the customized memory allocator reduces memory
allocation time and footprint. In short, SociaLite makes
high-performance data analysis easy with its high-level abstractions and
compiler/runtime optimizations.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jiwon Seo</dc:creator><pubDate>Wed, 09 Jul 2014 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2014-07-09:scipy-2014/socialite-python-intergrated-query-language-for.html</guid><category>bioinformatics</category><category>blast</category><category>data analysis</category></item></channel></rss>