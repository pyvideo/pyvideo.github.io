<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org - Wes Kendall</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Mon, 16 Oct 2023 00:00:00 +0000</lastBuildDate><item><title>Using simple database triggers for complex Django problems</title><link>https://pyvideo.org/djangocon-us-2021/using-simple-database-triggers-for-complex-django-problems.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Over the years I have struggled with a large class of Django problems, and I have found that these problems are much better solved using a common database feature called triggers.&lt;/p&gt;
&lt;p&gt;Let's consider some real-world problems before we get into what triggers are. Say that you want to ensure that a &amp;quot;status&amp;quot; field on a model can only transition between valid states. There are many popular libraries like django-fsm that try to solve this problem. The major problem with these libraries is that it's also very easy to accidentally bypass what the library aims to protect. For example, just doing certain bulk updates with django-fsm will bypass transition protection. This is no fault of django-fsm - it's just nearly impossible to try to intercept every single database call in an application and do certain things. This, however, can lead to some serious errors down the road and confusion about why the library didn't &amp;quot;just work&amp;quot; in the first place.&lt;/p&gt;
&lt;p&gt;Now let's expand this a bit more - consider protecting your models from deletion, making append-only models, versioning models, doing soft deletion, or tracking changes to your models. There are a plethora of libraries just for these very common problems, and the solutions are all prone to the same faults as django-fsm - there are &lt;em&gt;always&lt;/em&gt; ways to purposefully or accidentally bypass what those libraries aim to do, and usually without knowing.&lt;/p&gt;
&lt;p&gt;Similar to how you wouldn't rely on your application code to enforce a database uniqueness constraint, this talk aims to illustrate why you may not want your application code to solve these types of problems either. When you try to solve a database problem in the application, you will normally experience pain. Instead, I want to open people's eyes to the power of database triggers and illustrate why they should always be top of mind when designing high-quality Django projects and evaluating solutions to certain problems.&lt;/p&gt;
&lt;p&gt;A database trigger is a method that runs entirely in the database and is based on events and conditions. For example, one can create a database trigger to compute derived fields on a row immediately after the row is inserted or updated. Normally a user will have to write these triggers as database functions that are a superset of the SQL dialect supported by the database, such as PL/pgSQL for Postgres. These intricacies, along with the many barriers for even installing a trigger, have really inhibited adoption of triggers in Django.&lt;/p&gt;
&lt;p&gt;This is terrible though, because triggers are so useful for so many problems people don't even realize. For example, have you ever accidentally used Django's &amp;quot;User.objects.create()&amp;quot; to create a user and not the main &amp;quot;User.objects.create_user()&amp;quot; interface? You can use a trigger to enforce that the engineers of an application always use &amp;quot;Users.objects.create_user()&amp;quot; to create users. And no, it's not through monkey patching - &lt;em&gt;Any&lt;/em&gt; creation of a user, even in raw SQL, would be blocked if you didn't go through the proper interface in your application. Examples like these, which sometimes can make people scratch their heads as to how it is even possible to do this, are what make triggers so fun and unique to talk about.&lt;/p&gt;
&lt;p&gt;I have created an open-source library that is battle-tested at various large organizations that integrates triggers into Django. Triggers are registered and automatically migrated with your models, and there are lots of pre-built triggers for you to use. Users can even write conditional triggers with Django idioms like F and Q objects. If you are feeling really adventurous, you can integrate your own native triggers with ease too. I have an interactive tutorial for this library that I use during talks, I have performed this talk at 4 different companies as a tech talk, and I have also performed this talk at a prominent Django city meetup.&lt;/p&gt;
&lt;p&gt;This talk provides the following take-aways for the participants:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Understanding how triggers work in databases and what problems they can be used to solve.&lt;/li&gt;
&lt;li&gt;How people can seamlessly integrate triggers in their Postgres Django projects with an open source library. Currently the library only works for Postgres triggers, but I will have MySQL support integrated by Djangocon.&lt;/li&gt;
&lt;li&gt;How people can solve a wide array of difficult problems very easily with triggers.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here are some examples of problems we will solve together using an interactive tutorial:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Protecting operations - preventing deletes, making append-only models, making read-only columns, and &amp;quot;freezing&amp;quot; published models.&lt;/li&gt;
&lt;li&gt;Soft-deleting models - setting a &amp;quot;is_active&amp;quot; flag to &amp;quot;False&amp;quot; when a model is deleted instead of actually deleting it.&lt;/li&gt;
&lt;li&gt;Finite state machines - ensuring that a &amp;quot;status&amp;quot; field can only transition among valid states.&lt;/li&gt;
&lt;li&gt;Versioning a model - incrementing a version number of a model only when fields have changed.&lt;/li&gt;
&lt;li&gt;Official interfaces - requiring that an &amp;quot;official&amp;quot; interface, like Model.objects.my_create() vs. Model.objects.create(), is used to create a model.&lt;/li&gt;
&lt;li&gt;History tracking - snapshotting before/after versions of your model automatically while still capturing context like the logged-in user.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;All of these problems are solved in a few lines of code. Because of the properties of database triggers, these problems are also enforced at the database level - e.g. a user cannot delete a protected model even if they try to do it in raw SQL. That's the power of triggers, and that's why they are an important concept for Django developers to consider when approaching various problems. This talk aims to open people's eyes to what those problems are, why triggers are useful to them, and how they are actually very easy to use in practice.&lt;/p&gt;
&lt;p&gt;Triggers are inherently an advanced subject, so this talk is not aimed at the beginning Django user. I am tailoring this more to the intermediate/advanced user that has implemented a fair amount of model design. For example, if you've overridden a model's &amp;quot;Meta&amp;quot; and added unique constraints before, you should be able to put lessons from this talk into practice.&lt;/p&gt;
&lt;p&gt;I have been using Django in practice full time for 9 years now, and I have used it exclusively as the foundation for three different startups from the ground up. I went all-in on triggers at my last full-time job when it was the only reliable way to solve our history tracking problem, and that's how the open-source library was born. I love talking to people about Django, and I really love talking about integrating triggers with Django as you might be able to tell. That's why I'm so excited to talk about it at Djangocon and hopefully give people some other great ways to improve their application design.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wes Kendall</dc:creator><pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2021-10-23:/djangocon-us-2021/using-simple-database-triggers-for-complex-django-problems.html</guid><category>DjangoCon US 2021</category></item><item><title>Using database triggers to reliably track model history</title><link>https://pyvideo.org/djangocon-us-2023/using-database-triggers-to-reliably-track-model-history.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Tracking model history is an essential aspect of many web applications, as it allows developers to monitor and analyze changes made to the data over time. In Django, the majority of history tracking apps are implemented in Python at the application level, making a tamper-proof audit trail nearly impossible to implement accurately.&lt;/p&gt;
&lt;p&gt;By utilizing triggers, developers can automate the process of capturing and storing changes made to models within the database itself. This approach offers several benefits. Firstly, it reduces the complexity of manually implementing and maintaining history tracking functionality in Django code. Triggers provide a centralized and standardized mechanism to monitor modifications, ensuring consistency and accuracy across multiple models and applications.&lt;/p&gt;
&lt;p&gt;Secondly, triggers enable the tracking of changes at a database level, resulting in improved performance and reduced overhead. Since the triggers are executed within the database engine, they can efficiently capture modifications without requiring additional round-trips between the application and the database. This efficiency is particularly valuable when dealing with large datasets or frequently updated models.&lt;/p&gt;
&lt;p&gt;Furthermore, triggers provide a reliable and tamper-proof history of model changes. By operating at the database level, triggers can capture modifications regardless of whether they originate from Django or other external sources. This capability ensures that all changes to the model are consistently tracked, eliminating the risk of data loss or incomplete history.&lt;/p&gt;
&lt;p&gt;Additionally, utilizing triggers for model history tracking in Django promotes data integrity and compliance with auditing requirements. By maintaining a comprehensive record of changes, developers can trace back and analyze the evolution of data, helping to identify potential issues, perform forensic analysis, or meet regulatory obligations.&lt;/p&gt;
&lt;p&gt;In this talk, we show how to implement history tracking using [django-pghistory](hub.com/opus10/django-pghistory), an app that uses Postgres triggers to track historical changes. We discuss the philosophy of django-pghistory and how it models historical changes so that engineers can use structured history tables that mirror tracked models. We show how users can attach free-form context from the application to group together changes, forming a more coherent audit trail. We also discuss several other application-specific examples of using django-pghistory in practice, for example, using conditional history triggers to track and snapshot specific events.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wes Kendall</dc:creator><pubDate>Mon, 16 Oct 2023 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2023-10-16:/djangocon-us-2023/using-database-triggers-to-reliably-track-model-history.html</guid><category>DjangoCon US 2023</category></item></channel></rss>