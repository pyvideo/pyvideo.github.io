<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Sat, 17 Aug 2019 00:00:00 +0000</lastBuildDate><item><title>Extending GDB with Python</title><link>https://pyvideo.org/pybay-2019/extending-gdb-with-python.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;This talk was presented at PyBay2019 - 4th annual Bay Area Regional Python conference. See pybay.com for more details about PyBay and click SHOW MORE for more information about this talk.&lt;/p&gt;
&lt;p&gt;Description
GDB is powerful, and can be extended with Python to do more than just one-off debugging. This talk will describe using Python with GDB to with GDB to write tools that interact with running processes, highlighting GDB’s ability to call C functions and how this can be coupled with Python’s C-API to inject code without needing to stop the process.&lt;/p&gt;
&lt;p&gt;Abstract
The first half of the talk will be introductory in nature. I will talk about GDB and some of the specifics of how it can be extended with Python. The second half of the talk I will use the things discussed to create a program that does simple memory analysis of all objects in a running Python process.&lt;/p&gt;
&lt;p&gt;Introduction- who I am, what this talk is about (1 min)
GDB Introduction (3 min) a. What it is typically used for- debugging segfaults, etc b. How it works- ptrace under the hood c. Can execute C code (this will be important later in the talk) d. Source files (also important later in the talk)
GDB Python API (6 min) a. Accessing Python from GDB: basic commands (python [command], source, py-list, etc) b. Accessing GDB from Python: To use GDB in Python, from a GDB process, you can import gdb and all of the API is available to you. The API has extensive options to allow for many types of analysis but I will focus on some of the more basic options: executing GDB CLI strings, setting GDB parameters, and creating custom GDB commands. Docs: &lt;a class="reference external" href="https://sourceware.org/gdb/current/onlinedocs/gdb/Python-API.html#Python-API"&gt;https://sourceware.org/gdb/current/onlinedocs/gdb/Python-API.html#Python-API&lt;/a&gt; c. Show an example using gdb and Python’s C-API: gdb.execute(‘call PyRun_SimpleString(“print(‘Hello World’)”)’)
Problem Statement: I want to know what objects are taking up the most memory in my program, but I don’t want to (or more realistically, can’t) add code to my process to do the data collection. Solution: Use GDB to inject into my running process some memory analysis code (we can use open-source projects like objgraph or pympler to do the memory work for us) and get that data back without killing the debugged process. (2 min)
Launch a GDB subprocess and attach to the running process we are interested in debugging. (2 min)
In the GDB subprocess command, connect to a Python script file that GDB can use as a ‘source file’. This file will be able to import gdb and use the GDB Python API to create custom commands. (1 mins)
Write a custom command by inheriting from gdb.Command and using gdb.execute with PyRun_SimpleString (3 mins)
Memory analysis tools can be injected the same way as print(‘Hello World’) using PyRun_SimpleString, but PyRun_SimpleString only likes one line at a time. To get around this, I place all the code I would like executed in another file, and have PyRun_SimpleString run an exec(file.read()) on the open file (3 mins)
Two gotchas: locking the GIL, and making sure the running process has access to the memory analysis modules (2 min)
Conclusion (2 min)&lt;/p&gt;
&lt;p&gt;Original slides: &lt;a class="reference external" href="https://t.ly/3VX2b"&gt;https://t.ly/3VX2b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;About the speaker
Lisa is a Production Engineer at Facebook and a CPython Core Developer. She is passionate about Python, and has spent time using Python on networking and security teams, and now focuses on improving the language itself and enabling other users of it.&lt;/p&gt;
&lt;p&gt;Sponsor Acknowledgement
This and other PyBay2019 videos are via the help of our media partner AlphaVoice (&lt;a class="reference external" href="https://www.alphavoice.io/"&gt;https://www.alphavoice.io/&lt;/a&gt;)!&lt;/p&gt;
&lt;p&gt;#pybay #pybay2019 #python #python3 #gdb&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Lisa Roach</dc:creator><pubDate>Sat, 17 Aug 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-08-17:pybay-2019/extending-gdb-with-python.html</guid></item><item><title>Python Services at Scale</title><link>https://pyvideo.org/pybay-2018/python-services-at-scale.html</link><description></description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Lisa Roach</dc:creator><pubDate>Sat, 18 Aug 2018 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2018-08-18:pybay-2018/python-services-at-scale.html</guid></item><item><title>Demystifying the Patch Function</title><link>https://pyvideo.org/pycon-us-2018/demystifying-the-patch-function.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;One of the most challenging and important thing fors for Python developers learn is the unittest mock library. The patch function is in particular confusing- there are many different ways to use it. Should I use a context manager? Decorator? When would I use it manually? Improperly used patch functions can make unit tests useless, all the while making them look as if they are correctly testing code. Let’s learn how to wield patch with confidence!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Lisa Roach</dc:creator><pubDate>Sat, 12 May 2018 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2018-05-12:pycon-us-2018/demystifying-the-patch-function.html</guid></item></channel></rss>