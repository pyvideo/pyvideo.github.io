<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/tag_deploymentcontinuous-integration-and-delivery.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2019-07-12T00:00:00+00:00</updated><entry><title>Docker meets Python - A look on the Docker SDK for Python</title><link href="https://pyvideo.org/europython-2019/docker-meets-python-a-look-on-the-docker-sdk-for-python.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Jan Wagner</name></author><id>tag:pyvideo.org,2019-07-12:europython-2019/docker-meets-python-a-look-on-the-docker-sdk-for-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;My talk aims to introduce and have a closer look on the Docker SDK for
Python.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;I will cover:&lt;/div&gt;
&lt;div class="line"&gt;- How and where to get the SDK&lt;/div&gt;
&lt;div class="line"&gt;- How it works and how to use it in general&lt;/div&gt;
&lt;div class="line"&gt;- Possible use-cases like: Processing Container-Logs, Testing with
pytest on different Python Versions, Deploy via Python Script, etc..&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;For my talk, you should know what Docker is and how to use it.&lt;/div&gt;
&lt;div class="line"&gt;A basic idea of pytest and server administration is nice to have, but
not necessarily needed to follow my talk.&lt;/div&gt;
&lt;/div&gt;
</summary><category term="Deployment/Continuous Integration and Delivery"></category><category term="DevOps general"></category><category term="Docker"></category><category term="Testing"></category><category term="Virtualization"></category></entry><entry><title>Evolving a helper script into a 180,000-lines-of-Python-code project</title><link href="https://pyvideo.org/europython-2019/evolving-a-helper-script-into-a-180000-lines-of-python-code-project.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Mikhail Bushkov</name></author><id>tag:pyvideo.org,2019-07-12:europython-2019/evolving-a-helper-script-into-a-180000-lines-of-python-code-project.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;GRR Rapid Response (&lt;a class="reference external" href="https://github.com/google/grr"&gt;https://github.com/google/grr&lt;/a&gt;) is an incident
response framework focused on remote live forensics.&lt;/p&gt;
&lt;p&gt;It consists of a Python client (agent) that is installed on target
systems, and Python server infrastructure that can manage and talk to
clients. The goal of GRR is to support forensics and investigations in a
fast, scalable manner to allow analysts to quickly triage attacks and
perform analysis remotely.&lt;/p&gt;
&lt;p&gt;GRR was started at Google in 2009 as a simple Python helper script used
by Incident Response engineers. Eventually a little Python script got a
little server component, was adapted to run on multiple systems (Mac,
Linux, Windows), then a little UI was added and a few nice features were
introduced (large-scale hunts, collection of predefined artifacts,
memory analysis). A helper script has eventually evolved into a
sophisticated framework with 180,000 lines of Python code.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;In the presentation we’ll talk about the process of evolving a small
prototype-like Python project into a production-ready system, using
GRR as an example. The topics that we’ll cover are:&lt;/div&gt;
&lt;div class="line"&gt;* Taking shortcuts - both in terms of design and implementation.
Reasons for taking them and their eventual costs.&lt;/div&gt;
&lt;div class="line"&gt;* Relying on Python’s power features (i.e. meta-classes, mixins)?
Long-term consequences on maintainability and readability.&lt;/div&gt;
&lt;div class="line"&gt;* Organising the project into separate PyPI packages - benefits of
doing that.&lt;/div&gt;
&lt;div class="line"&gt;* Continuous integration, testing and automated builds for various
platforms - implementation costs and maintainability effects.&lt;/div&gt;
&lt;/div&gt;
</summary><category term="Databases"></category><category term="Deployment/Continuous Integration and Delivery"></category><category term="Development"></category><category term="Open-Source"></category><category term="Security"></category></entry><entry><title>Google Cloud for Pythonistas</title><link href="https://pyvideo.org/europython-2019/google-cloud-for-pythonistas.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Dustin Ingram</name></author><id>tag:pyvideo.org,2019-07-12:europython-2019/google-cloud-for-pythonistas.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Support for Python on Google Cloud has never been better. Join us for a
tour of Python runtimes, services and client libraries, including App
Engine, Cloud Functions, Cloud Run, and more. We'll also discuss tools
for monitoring and debugging your Python application, and best practices
for using Python on Google Cloud.&lt;/p&gt;
</summary><category term="Deployment/Continuous Integration and Delivery"></category><category term="DevOps general"></category><category term="Development"></category><category term="Public Cloud (AWS/Google/...)"></category><category term="Web"></category></entry><entry><title>Modern Continuous Delivery for Python Developers</title><link href="https://pyvideo.org/europython-2019/modern-continuous-delivery-for-python-developers.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Peter Bittner</name></author><id>tag:pyvideo.org,2019-07-12:europython-2019/modern-continuous-delivery-for-python-developers.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Deployment automation, cloud platforms, containerization, short
iterations to develop and release software—we’ve progressed a lot. And
finally it’s official: Kubernetes and OpenShift are the established
platforms to help us do scaling and zero downtime deployments with just
a few hundred lines of YAML. It’s a great time.&lt;/p&gt;
&lt;p&gt;Can we finally put all our eggs into one basket? Identify the cloud
platform that fits our needs, and jump on it? That could well backfire:
Vendor lock-in is the new waterfall, it slows you down. In future you’ll
want to jump over to the next better platform, in a matter of minutes.
Not months.&lt;/p&gt;
&lt;p&gt;This talk is about The Art of Writing deployment pipelines that will
survive Kubernetes, OpenShift and the like. It’s for Python developers
and Kubernetes enthusiasts of all levels – no domain specific knowledge
required, all you need to understand will be explained. You’ll learn how
to separate application-specific and deployment-specific configuration
details, to maximize your freedom and avoid vendor lock-in.&lt;/p&gt;
&lt;p&gt;Come see a demo of a Django project setup that covers everything from
local development to automatic scaling, flexible enough to be deployed
on any of your favorite container platforms. Take home a working,
future-proof setup for your Python applications.&lt;/p&gt;
</summary><category term="Agile"></category><category term="Best Practice"></category><category term="Clean Code"></category><category term="Deployment/Continuous Integration and Delivery"></category></entry><entry><title>Moving big projects to Python 3</title><link href="https://pyvideo.org/europython-2019/moving-big-projects-to-python-3.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Lennart Regebro</name></author><id>tag:pyvideo.org,2019-07-12:europython-2019/moving-big-projects-to-python-3.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Next year Python 2 is no longer maintained. But you have a monster code
base with clever tricks and libraries that don't support Python 2, and
your data may be stored in a format that is hard to move Python 3. And
that's the easy bit.&lt;/p&gt;
&lt;p&gt;This talk focuses on the process of moving, not the code changes.
Because it's the process that is the hard part. How do you get your code
in a state where it's ready to move? How do you get the whole team on
the boat to Python 3?&lt;/p&gt;
&lt;p&gt;All Python 3 talks I have seen, including those I have given, and all
the texts on how to port, including the book I wrote, focus on the code
changes. With increasing backwards compatibility in Python 3 and
forward-compatibility in Python 2, this actually became a lesser problem
for big code bases.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The extra issues of large, old code bases&lt;/li&gt;
&lt;li&gt;Can you stop adding features? (1 min)&lt;/li&gt;
&lt;li&gt;Separate team vs getting everyone on it (2 min)&lt;/li&gt;
&lt;li&gt;Python 2 compatibility: You need it (1 min)&lt;/li&gt;
&lt;li&gt;The steps&lt;/li&gt;
&lt;li&gt;Fix your development process (2 min)&lt;/li&gt;
&lt;li&gt;Replace old libraries, or take over maintenance and port them (2 min)&lt;/li&gt;
&lt;li&gt;Make sure your tests are solid (1 min)&lt;/li&gt;
&lt;li&gt;Run 2to3 but only backwards compatible fixers (2 min)&lt;/li&gt;
&lt;li&gt;Run tests on Python 3 to stop backsliding (4 min)&lt;/li&gt;
&lt;li&gt;Run all tests: Expansive or slow&lt;/li&gt;
&lt;li&gt;Store passed tests&lt;/li&gt;
&lt;li&gt;Detect tests that change&lt;/li&gt;
&lt;li&gt;Turning it off adds a lot of extra work&lt;/li&gt;
&lt;li&gt;Port all your little utilities and tool scripts (1 min)&lt;/li&gt;
&lt;li&gt;Fix fix fix fix (1 min)&lt;/li&gt;
&lt;li&gt;Add tests with Python 2 data, to test migration (2 min)&lt;/li&gt;
&lt;li&gt;You might need migration scripts&lt;/li&gt;
&lt;li&gt;Extra careful staging tests (1 min)&lt;/li&gt;
&lt;li&gt;Production: Try, fail, repeat (1 min)&lt;/li&gt;
&lt;li&gt;Clean the code up (3 min)&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="Deployment/Continuous Integration and Delivery"></category><category term="Management"></category><category term="Python 3"></category><category term="Testing"></category></entry><entry><title>Optimizing Docker builds for Python applications</title><link href="https://pyvideo.org/europython-2019/optimizing-docker-builds-for-python-applications.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Dmitry Figol</name></author><id>tag:pyvideo.org,2019-07-12:europython-2019/optimizing-docker-builds-for-python-applications.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Do you deploy Python applications in Docker? Then this session is for
you!&lt;/div&gt;
&lt;div class="line"&gt;We will start by reviewing a simple Dockerfile to package a Python
application and move to more complex examples which speed up the build
process and reduce the size of the resulting Docker image for both
development and production builds.&lt;/div&gt;
&lt;/div&gt;
</summary><category term="Deployment/Continuous Integration and Delivery"></category><category term="Docker"></category></entry><entry><title>Zen of Python Dependency Management</title><link href="https://pyvideo.org/europython-2019/zen-of-python-dependency-management.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Justin Mayer</name></author><id>tag:pyvideo.org,2019-07-12:europython-2019/zen-of-python-dependency-management.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Ensuring reliably repeatable dependency installation has long been an
unsolved problem for many Python projects. Pinning dependencies via
setup.py and requirements.txt has historically been met with extra work
and unexpected results, particularly when managing the dependencies of
dependencies.&lt;/p&gt;
&lt;p&gt;Thanks to PEP 518, Python projects can now more easily manage
dependencies via the new pyproject.toml file specification. In its wake,
a number of useful tools have arisen that use this file to provide
enhanced dependency resolution, including Poetry, Hatch, and Pipenv.&lt;/p&gt;
&lt;p&gt;Attendees of this talk will take home the following knowledge and
skills:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;how to replace three files (setup.py, requirements.txt, and
MANIFEST.ini) with just one: pyproject.toml&lt;/li&gt;
&lt;li&gt;why dependency resolution is hard and why it matters&lt;/li&gt;
&lt;li&gt;how Poetry, Hatch, and Pipenv differ and when to use each&lt;/li&gt;
&lt;li&gt;why one might use a less magical alternative: pip-tools&lt;/li&gt;
&lt;li&gt;how to use pipx to isolate system-wide Python tools&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="Deployment/Continuous Integration and Delivery"></category><category term="Open-Source"></category><category term="Packaging"></category><category term="PyPi"></category></entry></feed>