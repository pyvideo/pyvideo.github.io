<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org - Deployment/Continuous Integration and Delivery</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/tag_deploymentcontinuous-integration-and-delivery.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2020-07-23T00:00:00+00:00</updated><subtitle></subtitle><entry><title>Docker meets Python - A look on the Docker SDK for Python</title><link href="https://pyvideo.org/europython-2019/docker-meets-python-a-look-on-the-docker-sdk-for-python.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Jan Wagner</name></author><id>tag:pyvideo.org,2019-07-12:/europython-2019/docker-meets-python-a-look-on-the-docker-sdk-for-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;My talk aims to introduce and have a closer look on the Docker SDK for
Python.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;I will cover:&lt;/div&gt;
&lt;div class="line"&gt;- How and where to get the SDK&lt;/div&gt;
&lt;div class="line"&gt;- How it works and how to use it in general&lt;/div&gt;
&lt;div class="line"&gt;- Possible use-cases like: Processing Container-Logs, Testing with
pytest on different Python Versions, Deploy …&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;My talk aims to introduce and have a closer look on the Docker SDK for
Python.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;I will cover:&lt;/div&gt;
&lt;div class="line"&gt;- How and where to get the SDK&lt;/div&gt;
&lt;div class="line"&gt;- How it works and how to use it in general&lt;/div&gt;
&lt;div class="line"&gt;- Possible use-cases like: Processing Container-Logs, Testing with
pytest on different Python Versions, Deploy via Python Script, etc..&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;For my talk, you should know what Docker is and how to use it.&lt;/div&gt;
&lt;div class="line"&gt;A basic idea of pytest and server administration is nice to have, but
not necessarily needed to follow my talk.&lt;/div&gt;
&lt;/div&gt;
</content><category term="EuroPython 2019"></category><category term="Deployment/Continuous Integration and Delivery"></category><category term="DevOps general"></category><category term="Docker"></category><category term="Testing"></category><category term="Virtualization"></category></entry><entry><title>Evolving a helper script into a 180,000-lines-of-Python-code project</title><link href="https://pyvideo.org/europython-2019/evolving-a-helper-script-into-a-180000-lines-of-python-code-project.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Mikhail Bushkov</name></author><id>tag:pyvideo.org,2019-07-12:/europython-2019/evolving-a-helper-script-into-a-180000-lines-of-python-code-project.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;GRR Rapid Response (&lt;a class="reference external" href="https://github.com/google/grr"&gt;https://github.com/google/grr&lt;/a&gt;) is an incident
response framework focused on remote live forensics.&lt;/p&gt;
&lt;p&gt;It consists of a Python client (agent) that is installed on target
systems, and Python server infrastructure that can manage and talk to
clients. The goal of GRR is to support …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;GRR Rapid Response (&lt;a class="reference external" href="https://github.com/google/grr"&gt;https://github.com/google/grr&lt;/a&gt;) is an incident
response framework focused on remote live forensics.&lt;/p&gt;
&lt;p&gt;It consists of a Python client (agent) that is installed on target
systems, and Python server infrastructure that can manage and talk to
clients. The goal of GRR is to support forensics and investigations in a
fast, scalable manner to allow analysts to quickly triage attacks and
perform analysis remotely.&lt;/p&gt;
&lt;p&gt;GRR was started at Google in 2009 as a simple Python helper script used
by Incident Response engineers. Eventually a little Python script got a
little server component, was adapted to run on multiple systems (Mac,
Linux, Windows), then a little UI was added and a few nice features were
introduced (large-scale hunts, collection of predefined artifacts,
memory analysis). A helper script has eventually evolved into a
sophisticated framework with 180,000 lines of Python code.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;In the presentation we’ll talk about the process of evolving a small
prototype-like Python project into a production-ready system, using
GRR as an example. The topics that we’ll cover are:&lt;/div&gt;
&lt;div class="line"&gt;* Taking shortcuts - both in terms of design and implementation.
Reasons for taking them and their eventual costs.&lt;/div&gt;
&lt;div class="line"&gt;* Relying on Python’s power features (i.e. meta-classes, mixins)?
Long-term consequences on maintainability and readability.&lt;/div&gt;
&lt;div class="line"&gt;* Organising the project into separate PyPI packages - benefits of
doing that.&lt;/div&gt;
&lt;div class="line"&gt;* Continuous integration, testing and automated builds for various
platforms - implementation costs and maintainability effects.&lt;/div&gt;
&lt;/div&gt;
</content><category term="EuroPython 2019"></category><category term="Databases"></category><category term="Deployment/Continuous Integration and Delivery"></category><category term="Development"></category><category term="Open-Source"></category><category term="Security"></category></entry><entry><title>Google Cloud for Pythonistas</title><link href="https://pyvideo.org/europython-2019/google-cloud-for-pythonistas.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Dustin Ingram</name></author><id>tag:pyvideo.org,2019-07-12:/europython-2019/google-cloud-for-pythonistas.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Support for Python on Google Cloud has never been better. Join us for a
tour of Python runtimes, services and client libraries, including App
Engine, Cloud Functions, Cloud Run, and more. We'll also discuss tools
for monitoring and debugging your Python application, and best practices
for using Python on …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Support for Python on Google Cloud has never been better. Join us for a
tour of Python runtimes, services and client libraries, including App
Engine, Cloud Functions, Cloud Run, and more. We'll also discuss tools
for monitoring and debugging your Python application, and best practices
for using Python on Google Cloud.&lt;/p&gt;
</content><category term="EuroPython 2019"></category><category term="Deployment/Continuous Integration and Delivery"></category><category term="DevOps general"></category><category term="Development"></category><category term="Public Cloud (AWS/Google/...)"></category><category term="Web"></category></entry><entry><title>Modern Continuous Delivery for Python Developers</title><link href="https://pyvideo.org/europython-2019/modern-continuous-delivery-for-python-developers.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Peter Bittner</name></author><id>tag:pyvideo.org,2019-07-12:/europython-2019/modern-continuous-delivery-for-python-developers.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Deployment automation, cloud platforms, containerization, short
iterations to develop and release software—we’ve progressed a lot. And
finally it’s official: Kubernetes and OpenShift are the established
platforms to help us do scaling and zero downtime deployments with just
a few hundred lines of YAML. It’s a …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Deployment automation, cloud platforms, containerization, short
iterations to develop and release software—we’ve progressed a lot. And
finally it’s official: Kubernetes and OpenShift are the established
platforms to help us do scaling and zero downtime deployments with just
a few hundred lines of YAML. It’s a great time.&lt;/p&gt;
&lt;p&gt;Can we finally put all our eggs into one basket? Identify the cloud
platform that fits our needs, and jump on it? That could well backfire:
Vendor lock-in is the new waterfall, it slows you down. In future you’ll
want to jump over to the next better platform, in a matter of minutes.
Not months.&lt;/p&gt;
&lt;p&gt;This talk is about The Art of Writing deployment pipelines that will
survive Kubernetes, OpenShift and the like. It’s for Python developers
and Kubernetes enthusiasts of all levels – no domain specific knowledge
required, all you need to understand will be explained. You’ll learn how
to separate application-specific and deployment-specific configuration
details, to maximize your freedom and avoid vendor lock-in.&lt;/p&gt;
&lt;p&gt;Come see a demo of a Django project setup that covers everything from
local development to automatic scaling, flexible enough to be deployed
on any of your favorite container platforms. Take home a working,
future-proof setup for your Python applications.&lt;/p&gt;
</content><category term="EuroPython 2019"></category><category term="Agile"></category><category term="Best Practice"></category><category term="Clean Code"></category><category term="Deployment/Continuous Integration and Delivery"></category></entry><entry><title>Moving big projects to Python 3</title><link href="https://pyvideo.org/europython-2019/moving-big-projects-to-python-3.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Lennart Regebro</name></author><id>tag:pyvideo.org,2019-07-12:/europython-2019/moving-big-projects-to-python-3.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Next year Python 2 is no longer maintained. But you have a monster code
base with clever tricks and libraries that don't support Python 2, and
your data may be stored in a format that is hard to move Python 3. And
that's the easy bit.&lt;/p&gt;
&lt;p&gt;This talk focuses …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Next year Python 2 is no longer maintained. But you have a monster code
base with clever tricks and libraries that don't support Python 2, and
your data may be stored in a format that is hard to move Python 3. And
that's the easy bit.&lt;/p&gt;
&lt;p&gt;This talk focuses on the process of moving, not the code changes.
Because it's the process that is the hard part. How do you get your code
in a state where it's ready to move? How do you get the whole team on
the boat to Python 3?&lt;/p&gt;
&lt;p&gt;All Python 3 talks I have seen, including those I have given, and all
the texts on how to port, including the book I wrote, focus on the code
changes. With increasing backwards compatibility in Python 3 and
forward-compatibility in Python 2, this actually became a lesser problem
for big code bases.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The extra issues of large, old code bases&lt;/li&gt;
&lt;li&gt;Can you stop adding features? (1 min)&lt;/li&gt;
&lt;li&gt;Separate team vs getting everyone on it (2 min)&lt;/li&gt;
&lt;li&gt;Python 2 compatibility: You need it (1 min)&lt;/li&gt;
&lt;li&gt;The steps&lt;/li&gt;
&lt;li&gt;Fix your development process (2 min)&lt;/li&gt;
&lt;li&gt;Replace old libraries, or take over maintenance and port them (2 min)&lt;/li&gt;
&lt;li&gt;Make sure your tests are solid (1 min)&lt;/li&gt;
&lt;li&gt;Run 2to3 but only backwards compatible fixers (2 min)&lt;/li&gt;
&lt;li&gt;Run tests on Python 3 to stop backsliding (4 min)&lt;/li&gt;
&lt;li&gt;Run all tests: Expansive or slow&lt;/li&gt;
&lt;li&gt;Store passed tests&lt;/li&gt;
&lt;li&gt;Detect tests that change&lt;/li&gt;
&lt;li&gt;Turning it off adds a lot of extra work&lt;/li&gt;
&lt;li&gt;Port all your little utilities and tool scripts (1 min)&lt;/li&gt;
&lt;li&gt;Fix fix fix fix (1 min)&lt;/li&gt;
&lt;li&gt;Add tests with Python 2 data, to test migration (2 min)&lt;/li&gt;
&lt;li&gt;You might need migration scripts&lt;/li&gt;
&lt;li&gt;Extra careful staging tests (1 min)&lt;/li&gt;
&lt;li&gt;Production: Try, fail, repeat (1 min)&lt;/li&gt;
&lt;li&gt;Clean the code up (3 min)&lt;/li&gt;
&lt;/ul&gt;
</content><category term="EuroPython 2019"></category><category term="Deployment/Continuous Integration and Delivery"></category><category term="Management"></category><category term="Python 3"></category><category term="Testing"></category></entry><entry><title>Optimizing Docker builds for Python applications</title><link href="https://pyvideo.org/europython-2019/optimizing-docker-builds-for-python-applications.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Dmitry Figol</name></author><id>tag:pyvideo.org,2019-07-12:/europython-2019/optimizing-docker-builds-for-python-applications.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Do you deploy Python applications in Docker? Then this session is for
you!&lt;/div&gt;
&lt;div class="line"&gt;We will start by reviewing a simple Dockerfile to package a Python
application and move to more complex examples which speed up the build
process and reduce the size of the resulting Docker image for both …&lt;/div&gt;&lt;/div&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Do you deploy Python applications in Docker? Then this session is for
you!&lt;/div&gt;
&lt;div class="line"&gt;We will start by reviewing a simple Dockerfile to package a Python
application and move to more complex examples which speed up the build
process and reduce the size of the resulting Docker image for both
development and production builds.&lt;/div&gt;
&lt;/div&gt;
</content><category term="EuroPython 2019"></category><category term="Deployment/Continuous Integration and Delivery"></category><category term="Docker"></category></entry><entry><title>Zen of Python Dependency Management</title><link href="https://pyvideo.org/europython-2019/zen-of-python-dependency-management.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Justin Mayer</name></author><id>tag:pyvideo.org,2019-07-12:/europython-2019/zen-of-python-dependency-management.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Ensuring reliably repeatable dependency installation has long been an
unsolved problem for many Python projects. Pinning dependencies via
setup.py and requirements.txt has historically been met with extra work
and unexpected results, particularly when managing the dependencies of
dependencies.&lt;/p&gt;
&lt;p&gt;Thanks to PEP 518, Python projects can now more …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Ensuring reliably repeatable dependency installation has long been an
unsolved problem for many Python projects. Pinning dependencies via
setup.py and requirements.txt has historically been met with extra work
and unexpected results, particularly when managing the dependencies of
dependencies.&lt;/p&gt;
&lt;p&gt;Thanks to PEP 518, Python projects can now more easily manage
dependencies via the new pyproject.toml file specification. In its wake,
a number of useful tools have arisen that use this file to provide
enhanced dependency resolution, including Poetry, Hatch, and Pipenv.&lt;/p&gt;
&lt;p&gt;Attendees of this talk will take home the following knowledge and
skills:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;how to replace three files (setup.py, requirements.txt, and
MANIFEST.ini) with just one: pyproject.toml&lt;/li&gt;
&lt;li&gt;why dependency resolution is hard and why it matters&lt;/li&gt;
&lt;li&gt;how Poetry, Hatch, and Pipenv differ and when to use each&lt;/li&gt;
&lt;li&gt;why one might use a less magical alternative: pip-tools&lt;/li&gt;
&lt;li&gt;how to use pipx to isolate system-wide Python tools&lt;/li&gt;
&lt;/ul&gt;
</content><category term="EuroPython 2019"></category><category term="Deployment/Continuous Integration and Delivery"></category><category term="Open-Source"></category><category term="Packaging"></category><category term="PyPi"></category></entry><entry><title>Automating machine learning workflow with DVC</title><link href="https://pyvideo.org/europython-2020/automating-machine-learning-workflow-with-dvc.html" rel="alternate"></link><published>2020-07-23T00:00:00+00:00</published><updated>2020-07-23T00:00:00+00:00</updated><author><name>Hongjoo Lee</name></author><id>tag:pyvideo.org,2020-07-23:/europython-2020/automating-machine-learning-workflow-with-dvc.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;What data scientist / ML engineer wants to do while software engineers are busy with CI/CD.&lt;/p&gt;
&lt;p&gt;As software engineers work on CI/CD process as soon as they start a new project, data scientists and ML engineers define a pipeline for data as it flows through a typical workflow …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;What data scientist / ML engineer wants to do while software engineers are busy with CI/CD.&lt;/p&gt;
&lt;p&gt;As software engineers work on CI/CD process as soon as they start a new project, data scientists and ML engineers define a pipeline for data as it flows through a typical workflow. Each step of the pipeline is fed data processed from its preceding step as CI/CD process starts from code changes.&lt;/p&gt;
&lt;p&gt;&amp;quot;Pipelining ML project&amp;quot; is sometimes misleading as it implies a large project with a group of engineers working on some large systems , being considered to be hard for an individual and unnecessary for a small project. Regardless of its size, having well organized pipelines for any ML projects is essential to succeed and actually it could be done easily with utilizing a proper tool.&lt;/p&gt;
&lt;p&gt;In this talk, we will go through a machine learning workflow divided into a few steps composing a ML pipeline from data ingestion to model deployment. Each step depends on data produced by previous step, which are controlled by DVC. DVC is open-source version control system for data scientist and ML engineer helping them to organize data, models and experiments for some ML projects. The presentation will not only introduce how to use the tool but also show how to organize a ML pipeline with some examples.&lt;/p&gt;
&lt;p&gt;The goal of this talk is to motivate data scientists and ML engineer to start building machine learning pipeline with DVC. Audience might expect a guide to using DVC  for automating the pipeline. Also I will give some explanation about concepts of machine learning related techniques necessary for understanding the pipeline.&lt;/p&gt;
&lt;p&gt;This session is designed to be accessible to everyone in beginners level. Understandings of basic concepts of machine learning and version control system (preferably, Git) might be helpful but not mandatory for the audience.&lt;/p&gt;
</content><category term="EuroPython 2020"></category><category term="europython"></category><category term="europython-2020"></category><category term="europython-online"></category><category term="Big Data"></category><category term="Data"></category><category term="Data Science"></category><category term="Deployment/Continuous Integration and Delivery"></category></entry><entry><title>Best practices for production-ready Docker packaging</title><link href="https://pyvideo.org/europython-2020/best-practices-for-production-ready-docker-packaging.html" rel="alternate"></link><published>2020-07-23T00:00:00+00:00</published><updated>2020-07-23T00:00:00+00:00</updated><author><name>Itamar Turner-Trauring</name></author><id>tag:pyvideo.org,2020-07-23:/europython-2020/best-practices-for-production-ready-docker-packaging.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;An iterative packaging plan for your Python application&lt;/p&gt;
&lt;p&gt;You know the basics of packaging your Python application for Docker, but do you know enough to run that image in production? Bad packaging can result in security and production problems, not to mention wasted time try to debug unreproducible errors …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;An iterative packaging plan for your Python application&lt;/p&gt;
&lt;p&gt;You know the basics of packaging your Python application for Docker, but do you know enough to run that image in production? Bad packaging can result in security and production problems, not to mention wasted time try to debug unreproducible errors.&lt;/p&gt;
&lt;p&gt;And even if you figure out the best practices, there's still a huge number of details to get right, many of which interact with each other in unexpected ways. My personal list includes over 60 Docker packaging best practices, and it keeps growing. So where do you start? What should you do first?&lt;/p&gt;
&lt;p&gt;To help you quickly package your application in a production-ready way, this talk will give you a plan to help you prioritize and iteratively implement these best practices, by starting with the highest priority best practices (security, automation), moving on the correctness and reproducibility, and finally focusing on optimization.&lt;/p&gt;
&lt;p&gt;To make this process more concrete, along the way you'll also learn some of the techniques needed to build production-ready images:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Running as a non-root, for increased security.&lt;/li&gt;
&lt;li&gt;Debugging C crashes with faulthandler.&lt;/li&gt;
&lt;li&gt;Faster startup with pre-compiled .pycs.&lt;/li&gt;
&lt;li&gt;Smaller images by disabling pip caching.&lt;/li&gt;
&lt;li&gt;Avoiding Alpine Linux.&lt;/li&gt;
&lt;li&gt;And more!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;At the end of the talk you'll also get some resources to teach you even more best practices that can't be fit in a 30-minute talk.&lt;/p&gt;
&lt;p&gt;This talk is for Python programmers who know the basics of Docker packaging, and need to run the resulting images in a production environment.&lt;/p&gt;
</content><category term="EuroPython 2020"></category><category term="europython"></category><category term="europython-2020"></category><category term="europython-online"></category><category term="Deployment/Continuous Integration and Delivery"></category><category term="DevOps general"></category><category term="Docker"></category><category term="Packaging"></category><category term="Security"></category></entry><entry><title>Deploy your Machine Learning Bots like a boss with CI/CD</title><link href="https://pyvideo.org/europython-2020/deploy-your-machine-learning-bots-like-a-boss-with-cicd.html" rel="alternate"></link><published>2020-07-23T00:00:00+00:00</published><updated>2020-07-23T00:00:00+00:00</updated><author><name>William Arias</name></author><id>tag:pyvideo.org,2020-07-23:/europython-2020/deploy-your-machine-learning-bots-like-a-boss-with-cicd.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Using Gitlab Open Source tools to automate NLP models deployment&lt;/p&gt;
&lt;p&gt;Context: Today is relatively easy to create and train a conversational agent using Machine Learning Techniques, fire it up and showcase it in your computer&lt;/p&gt;
&lt;p&gt;Problem: Sharing your chatbot with the outside world is not as easy as training …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Using Gitlab Open Source tools to automate NLP models deployment&lt;/p&gt;
&lt;p&gt;Context: Today is relatively easy to create and train a conversational agent using Machine Learning Techniques, fire it up and showcase it in your computer&lt;/p&gt;
&lt;p&gt;Problem: Sharing your chatbot with the outside world is not as easy as training your models. Load Balancer, Unit Test, Integration Tests, Differential Tests ... Text Analytics and retrain the models to better serve your audience goes way beyond the simple agent that runs in the developer environment&lt;/p&gt;
&lt;p&gt;Solution: I want to show how from my experience of deploying bots to production, leveraging DevOps + DataScience skills along with an entry level knowledge of Databases, CI/CD and distributed systems you can take your prototypes to a next level, deploy, iterate  and re-train your models faster.&lt;/p&gt;
&lt;p&gt;Pre-reqs: Entry level understanding of CI/CD Pipelines, NLP, jupyterhub, Version Control, Rasa&lt;/p&gt;
</content><category term="EuroPython 2020"></category><category term="europython"></category><category term="europython-2020"></category><category term="europython-online"></category><category term="Deep Learning"></category><category term="Deployment/Continuous Integration and Delivery"></category><category term="Ipython"></category><category term="Machine-Learning"></category><category term="Open-Source"></category></entry><entry><title>Extending Python with Rust</title><link href="https://pyvideo.org/europython-2020/extending-python-with-rust.html" rel="alternate"></link><published>2020-07-23T00:00:00+00:00</published><updated>2020-07-23T00:00:00+00:00</updated><author><name>Mikhail Medvedev</name></author><id>tag:pyvideo.org,2020-07-23:/europython-2020/extending-python-with-rust.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Introduction and a hands-on demo of writing Python extension in Rust&lt;/p&gt;
&lt;p&gt;Rust is a rising star of the programming language world. I'd like to discuss it from a Python developer perspective. Obviously, Rust is not a replacement for Python, but in case you're seeking better performance it may be …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Introduction and a hands-on demo of writing Python extension in Rust&lt;/p&gt;
&lt;p&gt;Rust is a rising star of the programming language world. I'd like to discuss it from a Python developer perspective. Obviously, Rust is not a replacement for Python, but in case you're seeking better performance it may be a good idea to build an extension. This is safer and arguably easier to do in Rust than in C.
In this talk we will take a look at existing crates that provide interface to Python and see how easy it is to use them.
Then we go through the demo and see it in action.
Run some benchmarks against pure Python and also Cython.
Write a Dockerfile to build it all together.
Discuss CI/CD for mixed Rust/Python projects.&lt;/p&gt;
</content><category term="EuroPython 2020"></category><category term="europython"></category><category term="europython-2020"></category><category term="europython-online"></category><category term="All Other Programming Languages"></category><category term="Compiler and Interpreters"></category><category term="Deployment/Continuous Integration and Delivery"></category><category term="Docker"></category><category term="Rust"></category></entry></feed>