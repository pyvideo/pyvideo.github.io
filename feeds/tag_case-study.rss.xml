<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Fri, 12 Jul 2019 00:00:00 +0000</lastBuildDate><item><title>Downloading a Billion Files in Python</title><link>https://pyvideo.org/europython-2019/downloading-a-billion-files-in-python.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;You've been given a task. You need to download some files from a server
to your local machine. The files are fairly small, and you can list and
access these files from the remote server through a REST API. You'd like
to download them as fast as possible. The catch? There's a billion of
them. Yes, one billion files.&lt;/p&gt;
&lt;p&gt;How would would you do this? Would you do this synchronously in a single
for loop? Would you use a producer/consumer queue with threads?
Multiprocessing? Asyncio?&lt;/p&gt;
&lt;p&gt;In this talk, we'll examine 3 different mechanisms for concurrently
downloading files: multithreading, multiprocessing, and asyncio.&lt;/p&gt;
&lt;p&gt;For each of these mechanisms we'll look at design best practices, how to
handle debugging and error handling, and of course the overall
performance. By examining three different approaches using the same data
set, we gain a better understanding of the tradeoffs of each approach so
we can pick the right library for the job.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">James Saryerwinnie</dc:creator><pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-07-12:europython-2019/downloading-a-billion-files-in-python.html</guid><category>ASYNC / Concurrency</category><category>Case Study</category><category>Multi-Processing</category><category>Multi-Threading</category><category>Performance</category></item><item><title>Enhancing Angklung Music Rehearsals with Python</title><link>https://pyvideo.org/europython-2019/enhancing-angklung-music-rehearsals-with-python.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Angklung is a traditional musical instrument from Indonesia. This
instrument has a lot of variety in how it is performed; a common format
is the orchestral format in which 15-30 players gather to form a team.
Playing Angklung in this way is fun but also presents some challenges
that are hard to solve manually.&lt;/p&gt;
&lt;p&gt;First, I will introduce you to the instrument and how it works/how it is
played. Then, I will show you how Python-based algorithms can be used to
ease the pains of managing Angklung teams, by reading Angklung-specific
sheet music and calculating the most optimal distribution of Angklung
based on several important factors.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Trapsilo Bumi</dc:creator><pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-07-12:europython-2019/enhancing-angklung-music-rehearsals-with-python.html</guid><category>Algorithms</category><category>Analytics</category><category>Beginners</category><category>Case Study</category><category>Use Case</category></item><item><title>How we run GraphQL APIs in production on our Kubernetes cluster</title><link>https://pyvideo.org/europython-2019/how-we-run-graphql-apis-in-production-on-our-kubernetes-cluster.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In this talk I would like to share the workflow and tools we use to
build, deploy and operate GraphQL APIs on our on-premise Kubernetes
cluster.&lt;/p&gt;
&lt;p&gt;I will share code and command examples explaining how we are operating
our applications since our recent transition from REST APIs on Web
servers to GraphQL APIs containers on Kubernetes.&lt;/p&gt;
&lt;p&gt;This talk will not be about the difference between REST and GraphQL but
focus on the workflow, tools and experience we gained in switching our
run time environments and API models.&lt;/p&gt;
&lt;p&gt;At Numberly, we have built and are operating our own on-premise
Kubernetes cluster so we will also be talking about its capabilities and
share some of the experience we gained in doing so.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Proposed agenda:&lt;/div&gt;
&lt;div class="line"&gt;- Our previous workflow and its limitations&lt;/div&gt;
&lt;div class="line"&gt;- How we designed our Kubernetes cluster, its capabilities and the
choices we made&lt;/div&gt;
&lt;div class="line"&gt;- Developer workflow, environments management and deployment&lt;/div&gt;
&lt;div class="line"&gt;- Our GraphQL stack, featuring a sample application&lt;/div&gt;
&lt;div class="line"&gt;- What we're still working on to improve&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexys Jacob</dc:creator><pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-07-12:europython-2019/how-we-run-graphql-apis-in-production-on-our-kubernetes-cluster.html</guid><category>APIs</category><category>Best Practice</category><category>Case Study</category><category>Docker</category><category>Infrastructure</category></item><item><title>Tips for the scientific programmer</title><link>https://pyvideo.org/europython-2019/tips-for-the-scientific-programmer.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;This is a talk for people who need to perform large numeric
calculations. They could be scientists, developers working in close
contact with scientists, or even people working on finance and other
quantitative fields. Such people are routinely confronted with issues
like&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;1 parallelism: how to parallelize calculations efficiently&lt;/div&gt;
&lt;div class="line"&gt;2 data: how to store and manage large amounts of data efficiently&lt;/div&gt;
&lt;div class="line"&gt;3 memory: how to avoid running out of memory&lt;/div&gt;
&lt;div class="line"&gt;4 performance: how to be fast&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;The goal of the talk is to teach some lessons learned after several
years of doing numeric simulations in a context were micro-optimizations
are the least important factor, while overall architecture, design
choices and good algorithms are of paramount importance.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Michele Simionato</dc:creator><pubDate>Thu, 11 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-07-11:europython-2019/tips-for-the-scientific-programmer.html</guid><category>Algorithms</category><category>Architecture</category><category>Big Data</category><category>Case Study</category><category>Performance</category></item><item><title>The dos and don'ts of task queues</title><link>https://pyvideo.org/europython-2019/the-dos-and-donts-of-task-queues.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;At Kiwi.com we heavily rely on task queues and asynchronous execution of
code to process large amounts of requests coming to our back-ends. With
the separation of our codebase to microservices, we can quickly try new
tools and different approaches to process these large volumes of
requests. The microservice we’ll be talking about is making unreliable
slow 3rd party services reliable and asynchronous with a bit of business
logic sprinkled on top of it. We’ll tell a failure story of ours but
resulting in a valuable lesson.&lt;/p&gt;
&lt;p&gt;Most of our services use Celery and it’s the go-to tool for new services
as well but we wanted to be different with this new microservice. RQ is
the next best choice for task queues and it is presented as simpler and
more straightforward than Celery. That can definitely be true but after
3 weeks of research, development and struggling we found out the
unpleasant truth about being simple and making the right choices. We
won’t talk about comparing the frameworks but rather about the approach
on how to experiment with new things in your environment. After that,
we’ll present our current setup which can take upon any number of
tasks*. How we orchestrate the app and continuously integrate and
deploy and what fun things await ahead of us in the development.&lt;/p&gt;
&lt;p&gt;*Conditions may apply.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Petr Stehlík</dc:creator><pubDate>Wed, 10 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-07-10:europython-2019/the-dos-and-donts-of-task-queues.html</guid><category>ASYNC / Concurrency</category><category>Architecture</category><category>Best Practice</category><category>Case Study</category><category>failures/mistakes</category></item><item><title>Pyramid advanced configuration tactics for nice apps and libs</title><link>https://pyvideo.org/europython-2013/pyramid-advanced-configuration-tactics-for-nice-apps-and-libs.html</link><description></description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Georges Dubus</dc:creator><pubDate>Fri, 05 Jul 2013 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2013-07-05:europython-2013/pyramid-advanced-configuration-tactics-for-nice-apps-and-libs.html</guid><category>web</category><category>pyramid</category><category>case-study</category></item><item><title>SimpleManagement: come semplificare la gestione progetti con Python</title><link>https://pyvideo.org/europython-2013/simplemanagement-come-semplificare-la-gestione-progetti-con-python.html</link><description></description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Maurizio Delmonte</dc:creator><pubDate>Thu, 04 Jul 2013 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2013-07-04:europython-2013/simplemanagement-come-semplificare-la-gestione-progetti-con-python.html</guid><category>project-management</category><category>open-source</category><category>teamwork</category><category>zope</category><category>plone</category><category>case-study</category></item><item><title>Lost in OAuth? Learn Velruse And Get Your Life Back!</title><link>https://pyvideo.org/europython-2013/lost-in-oauth-learn-velruse-and-get-your-life-back.html</link><description></description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Andrew Mleczko</dc:creator><pubDate>Wed, 03 Jul 2013 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2013-07-03:europython-2013/lost-in-oauth-learn-velruse-and-get-your-life-back.html</guid><category>web</category><category>pyramid</category><category>HTTP</category><category>open-source</category><category>case-study</category></item><item><title>Celery and Social Networks. 5 Things I Have Learned During Earthquake Hackathon.</title><link>https://pyvideo.org/europython-2013/celery-and-social-networks-5-things-i-have-learned-during-earthquake-hackathon.html</link><description></description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Andrew Mleczko</dc:creator><pubDate>Tue, 02 Jul 2013 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2013-07-02:europython-2013/celery-and-social-networks-5-things-i-have-learned-during-earthquake-hackathon.html</guid><category>celery</category><category>security</category><category>open-source</category><category>case-study</category><category>social</category></item></channel></rss>