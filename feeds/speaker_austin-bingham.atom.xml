<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_austin-bingham.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2016-06-21T00:00:00+00:00</updated><entry><title>Python refactoring with Rope and Traad</title><link href="https://pyvideo.org/pycon-belarus-2015/python-refactoring-with-rope-and-traad.html" rel="alternate"></link><published>2015-01-31T00:00:00+00:00</published><updated>2015-01-31T00:00:00+00:00</updated><author><name>Austin Bingham</name></author><id>tag:pyvideo.org,2015-01-31:pycon-belarus-2015/python-refactoring-with-rope-and-traad.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python Refactoring with Rope and Traad – The rope library is a powerful
tool for refactoring Python code, but to be truly useful it needs to be
available to development environments. Traad is a tool which makes it
simpler to integrate rope into nearly any tool by exposing a simple HTTP
API. In this session we’ll look at how traad and rope work together, and
we’ll see how traad integrates with at least one popular editor.&lt;/p&gt;
</summary></entry><entry><title>Transducers in Python</title><link href="https://pyvideo.org/pycon-belarus-2015/transducers-in-python.html" rel="alternate"></link><published>2015-01-31T00:00:00+00:00</published><updated>2015-01-31T00:00:00+00:00</updated><author><name>Austin Bingham</name></author><id>tag:pyvideo.org,2015-01-31:pycon-belarus-2015/transducers-in-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Understanding Transducers Through Python – Transducers are a new and
interesting functional programming concept that comes from the world of
Clojure. In this talk we’ll learn about transducers by seeing how to
implement them in Python. By using transducers to build familiar
functional programming elements like map and filter, we’ll see that
transducers are actually simple, elegant, and quite powerful.&lt;/p&gt;
</summary></entry><entry><title>Mutation Testing in Python with Cosmic Ray</title><link href="https://pyvideo.org/ndc-oslo-2016/mutation-testing-in-python-with-cosmic-ray.html" rel="alternate"></link><published>2016-06-21T00:00:00+00:00</published><updated>2016-06-21T00:00:00+00:00</updated><author><name>Austin Bingham</name></author><id>tag:pyvideo.org,2016-06-21:ndc-oslo-2016/mutation-testing-in-python-with-cosmic-ray.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Mutation testing is a technique for systematically mutating source code in order to validate test suites. It works by making small changes to a program’s source code and then running a test suite; if the test suite passes on mutated code then a flag is raised. The goal is to check that a system’s test suite is sufficiently powerful to detect a large class of functionality-affecting changes, thereby helping ensure that the system functions as expected. Mutation testing is a fascinating topic with great potential that has valuable lessons for the broader software development community.
I’ll begin this talk with a description of the theory behind mutation testing. We’ll look at how it works and the benefits it can provide. We’ll also consider some of the practical difficulties associated with the technique, including long runtimes and certain difficult classes of mutants. I’ll then move into an analysis of Cosmic Ray, a tool for mutation testing in Python. I'll demonstrate using Cosmic Ray to locate untested code not detected by traditional coverage techniques in an open source library – with surprising results.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Mutation testing is a technique for systematically mutating source code in order to validate test suites. It works by making small changes to a program’s source code and then running a test suite; if the test suite passes on mutated code then a flag is raised. The goal is to check that a system’s test suite is sufficiently powerful to detect a large class of functionality-affecting changes, thereby helping ensure that the system functions as expected. Mutation testing is a fascinating topic with great potential that has valuable lessons for the broader software development community.
I’ll begin this talk with a description of the theory behind mutation testing. We’ll look at how it works and the benefits it can provide. We’ll also consider some of the practical difficulties associated with the technique, including long runtimes and certain difficult classes of mutants. I’ll then move into an analysis of Cosmic Ray, a tool for mutation testing in Python. I'll demonstrate using Cosmic Ray to locate untested code not detected by traditional coverage techniques in an open source library – with surprising results.&lt;/p&gt;
</summary><category term="unit testing"></category><category term="testing"></category><category term="mutation testing"></category><category term="ndc"></category><category term="ndcoslo"></category><category term="ndcoslo2016"></category></entry><entry><title>Integrating Python and C++ with Boost Python part 2</title><link href="https://pyvideo.org/scipy-2014/integrating-python-and-c-with-boost-python-part.html" rel="alternate"></link><published>2014-07-09T00:00:00+00:00</published><updated>2014-07-09T00:00:00+00:00</updated><author><name>Austin Bingham</name></author><id>tag:pyvideo.org,2014-07-09:scipy-2014/integrating-python-and-c-with-boost-python-part.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Python and C++ can be powerful complements to one another. C++ is great
for performance-critical calculations, while Python is great for
everything else. In this tutorial we’ll look at how to integrate Python
and C++ using the Boost.Python library. You’ll learn techniques for
easily developing hybrid systems that use the right language for the
right task, resulting in better software.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python and C++ are both popular languages that each bring a lot to the
table. The languages also complement one another well: Python is
high-level, dynamic, and easy to use while C++ is at-the-metal, static,
and (in)famously tricky. There are times when there are real advantages
to combining these disparate natures, and Python’s C API provides a
strong interface for doing just that. Boost.Python is a C++ library that
builds upon and improves Python’s C API to give users a simpler, more
intuitive, and safer means to integrate Python and C++.&lt;/p&gt;
&lt;p&gt;In this tutorial we’ll look at how to use Boost.Python to effectively
bridge the Python/C++ boundary. We’ll start by briefly looking at the
fundamentals of the Python C API since that defines the “ground rules”;
this includes things like reference counting, the basic object model,
and so forth. We’ll then quickly look at the Boost.Python API and show
how it provides the same functionality as the underlying C API, but does
so in a way that doesn’t obscure the real semantics of the Python
language.&lt;/p&gt;
&lt;p&gt;After this introduction, the rest of the tutorial will involve writing
code to explore various elements of Boost.Python. We’ll focus on
techniques for extending Python with C++, that is, writing Python
modules in C++. Boost.Python can be used for embedding (i.e. invoking
Python code from C++), but that involves a different set of techniques,
and in practice most scientific Python developers are more interested in
developing extensions.&lt;/p&gt;
&lt;p&gt;The syllabus for the four-hour tutorial will be like this:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Introduction: C-API and Boost.Python basics&lt;/p&gt;
&lt;p&gt;Note that this can be reduced or eliminated of participants are
already comfortable with the topics.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Hello World: Exposing a basic function&lt;/p&gt;
&lt;p&gt;In this section we’ll get a minimal Boost.Python module working. This
will not only introduce students to the infrastructure of
Boost.Python, but it will also give us a chance to make sure that
everyone’s build environment is working.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Exposing functions&lt;/p&gt;
&lt;p&gt;In this section we’ll look at the details of exposing C++ functions
to Python. The topics we’ll cover will include overloading (including
Boost.Python’s auto-overload feature), default argument values, and a
brief look at call policies.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Exposing classes&lt;/p&gt;
&lt;p&gt;Here we’ll look at how to expose C++ classes to Python. Topics will
include the basic &lt;tt class="docutils literal"&gt;class_&amp;lt;T&amp;gt;&lt;/tt&gt; template, member functions, data
members, properties, inheritance, and virtual functions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;boost::python::object&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;boost::python::object&lt;/span&gt;&lt;/tt&gt; class is Boost.Python’s primary
interface to Python’s &lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; structure. Understanding how to
work with this class is a key building-block for developing Python
modules with Boost.Python. We’ll explore its API and features,
including areas like attribute access, reference counting, and
converting between Python and C++ objects.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Derived object types&lt;/p&gt;
&lt;p&gt;Boost.Python provides a number of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;boost::python::object&lt;/span&gt;&lt;/tt&gt;
subclasses for important Python classes like &lt;tt class="docutils literal"&gt;list&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;dict&lt;/tt&gt;, and
&lt;tt class="docutils literal"&gt;tuple&lt;/tt&gt;. In this section we’ll look at these subclasses and how to
use them in Boost.Python modules.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Enums&lt;/p&gt;
&lt;p&gt;Boost.Python provides &lt;tt class="docutils literal"&gt;enum_&amp;lt;T&amp;gt;&lt;/tt&gt; for exposing C++ enums to Python.
Python doesn’t have a notion of enums &lt;em&gt;per se&lt;/em&gt;, but in this section
we’ll explore how this template makes it straightforward to use C++
enums in Python in a simple and intuitive way.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Type conversion&lt;/p&gt;
&lt;p&gt;In this section we’ll look at Boost.Python’s support for doing
automatic type-conversion across the Python/C++ boundary. We’ll see
how you can register type-converters with Boost.Python which will be
invoked whenever Boost.Python needs to convert a Python object to a
C++ object or vice versa.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is a fairly ambitious set of topics, and it’s possible that we
won’t be able to cover them all. The topics are roughly in
most-often-used to least-often-used order, however, so students will be
sure to be exposed to the most important and relevant elements of the
course.&lt;/p&gt;
&lt;p&gt;Likewise, the four-hour format of the course means that we won’t be able
to go into great depth on many topics. The main goal of the course,
then, is to give students enough orientation and hands-on experience
with Boost.Python that they can continue to learn on their own.
Inter-language integration - especially between languages as dissimilar
as C++ and Python - can be quite complex, but this tutorial will give
students the grounding they need to successfully apply Boost.Python to
their problems.&lt;/p&gt;
</summary><category term="boost"></category><category term="c++"></category></entry><entry><title>Integrating Python and C++ with Boost Python part 1</title><link href="https://pyvideo.org/scipy-2014/integrating-python-and-c-with-boost-python-part-0.html" rel="alternate"></link><published>2014-07-09T00:00:00+00:00</published><updated>2014-07-09T00:00:00+00:00</updated><author><name>Austin Bingham</name></author><id>tag:pyvideo.org,2014-07-09:scipy-2014/integrating-python-and-c-with-boost-python-part-0.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Python and C++ can be powerful complements to one another. C++ is great
for performance-critical calculations, while Python is great for
everything else. In this tutorial we’ll look at how to integrate Python
and C++ using the Boost.Python library. You’ll learn techniques for
easily developing hybrid systems that use the right language for the
right task, resulting in better software.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python and C++ are both popular languages that each bring a lot to the
table. The languages also complement one another well: Python is
high-level, dynamic, and easy to use while C++ is at-the-metal, static,
and (in)famously tricky. There are times when there are real advantages
to combining these disparate natures, and Python’s C API provides a
strong interface for doing just that. Boost.Python is a C++ library that
builds upon and improves Python’s C API to give users a simpler, more
intuitive, and safer means to integrate Python and C++.&lt;/p&gt;
&lt;p&gt;In this tutorial we’ll look at how to use Boost.Python to effectively
bridge the Python/C++ boundary. We’ll start by briefly looking at the
fundamentals of the Python C API since that defines the “ground rules”;
this includes things like reference counting, the basic object model,
and so forth. We’ll then quickly look at the Boost.Python API and show
how it provides the same functionality as the underlying C API, but does
so in a way that doesn’t obscure the real semantics of the Python
language.&lt;/p&gt;
&lt;p&gt;After this introduction, the rest of the tutorial will involve writing
code to explore various elements of Boost.Python. We’ll focus on
techniques for extending Python with C++, that is, writing Python
modules in C++. Boost.Python can be used for embedding (i.e. invoking
Python code from C++), but that involves a different set of techniques,
and in practice most scientific Python developers are more interested in
developing extensions.&lt;/p&gt;
&lt;p&gt;The syllabus for the four-hour tutorial will be like this:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Introduction: C-API and Boost.Python basics&lt;/p&gt;
&lt;p&gt;Note that this can be reduced or eliminated of participants are
already comfortable with the topics.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Hello World: Exposing a basic function&lt;/p&gt;
&lt;p&gt;In this section we’ll get a minimal Boost.Python module working. This
will not only introduce students to the infrastructure of
Boost.Python, but it will also give us a chance to make sure that
everyone’s build environment is working.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Exposing functions&lt;/p&gt;
&lt;p&gt;In this section we’ll look at the details of exposing C++ functions
to Python. The topics we’ll cover will include overloading (including
Boost.Python’s auto-overload feature), default argument values, and a
brief look at call policies.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Exposing classes&lt;/p&gt;
&lt;p&gt;Here we’ll look at how to expose C++ classes to Python. Topics will
include the basic &lt;tt class="docutils literal"&gt;class_&amp;lt;T&amp;gt;&lt;/tt&gt; template, member functions, data
members, properties, inheritance, and virtual functions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;boost::python::object&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;boost::python::object&lt;/span&gt;&lt;/tt&gt; class is Boost.Python’s primary
interface to Python’s &lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; structure. Understanding how to
work with this class is a key building-block for developing Python
modules with Boost.Python. We’ll explore its API and features,
including areas like attribute access, reference counting, and
converting between Python and C++ objects.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Derived object types&lt;/p&gt;
&lt;p&gt;Boost.Python provides a number of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;boost::python::object&lt;/span&gt;&lt;/tt&gt;
subclasses for important Python classes like &lt;tt class="docutils literal"&gt;list&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;dict&lt;/tt&gt;, and
&lt;tt class="docutils literal"&gt;tuple&lt;/tt&gt;. In this section we’ll look at these subclasses and how to
use them in Boost.Python modules.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Enums&lt;/p&gt;
&lt;p&gt;Boost.Python provides &lt;tt class="docutils literal"&gt;enum_&amp;lt;T&amp;gt;&lt;/tt&gt; for exposing C++ enums to Python.
Python doesn’t have a notion of enums &lt;em&gt;per se&lt;/em&gt;, but in this section
we’ll explore how this template makes it straightforward to use C++
enums in Python in a simple and intuitive way.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Type conversion&lt;/p&gt;
&lt;p&gt;In this section we’ll look at Boost.Python’s support for doing
automatic type-conversion across the Python/C++ boundary. We’ll see
how you can register type-converters with Boost.Python which will be
invoked whenever Boost.Python needs to convert a Python object to a
C++ object or vice versa.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is a fairly ambitious set of topics, and it’s possible that we
won’t be able to cover them all. The topics are roughly in
most-often-used to least-often-used order, however, so students will be
sure to be exposed to the most important and relevant elements of the
course.&lt;/p&gt;
&lt;p&gt;Likewise, the four-hour format of the course means that we won’t be able
to go into great depth on many topics. The main goal of the course,
then, is to give students enough orientation and hands-on experience
with Boost.Python that they can continue to learn on their own.
Inter-language integration - especially between languages as dissimilar
as C++ and Python - can be quite complex, but this tutorial will give
students the grounding they need to successfully apply Boost.Python to
their problems.&lt;/p&gt;
</summary><category term="boost"></category><category term="c++"></category></entry><entry><title>Integrating Python and C++ with Boost Python part 3</title><link href="https://pyvideo.org/scipy-2014/integrating-python-and-c-with-boost-python-part-1.html" rel="alternate"></link><published>2014-07-09T00:00:00+00:00</published><updated>2014-07-09T00:00:00+00:00</updated><author><name>Austin Bingham</name></author><id>tag:pyvideo.org,2014-07-09:scipy-2014/integrating-python-and-c-with-boost-python-part-1.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Python and C++ can be powerful complements to one another. C++ is great
for performance-critical calculations, while Python is great for
everything else. In this tutorial we’ll look at how to integrate Python
and C++ using the Boost.Python library. You’ll learn techniques for
easily developing hybrid systems that use the right language for the
right task, resulting in better software.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python and C++ are both popular languages that each bring a lot to the
table. The languages also complement one another well: Python is
high-level, dynamic, and easy to use while C++ is at-the-metal, static,
and (in)famously tricky. There are times when there are real advantages
to combining these disparate natures, and Python’s C API provides a
strong interface for doing just that. Boost.Python is a C++ library that
builds upon and improves Python’s C API to give users a simpler, more
intuitive, and safer means to integrate Python and C++.&lt;/p&gt;
&lt;p&gt;In this tutorial we’ll look at how to use Boost.Python to effectively
bridge the Python/C++ boundary. We’ll start by briefly looking at the
fundamentals of the Python C API since that defines the “ground rules”;
this includes things like reference counting, the basic object model,
and so forth. We’ll then quickly look at the Boost.Python API and show
how it provides the same functionality as the underlying C API, but does
so in a way that doesn’t obscure the real semantics of the Python
language.&lt;/p&gt;
&lt;p&gt;After this introduction, the rest of the tutorial will involve writing
code to explore various elements of Boost.Python. We’ll focus on
techniques for extending Python with C++, that is, writing Python
modules in C++. Boost.Python can be used for embedding (i.e. invoking
Python code from C++), but that involves a different set of techniques,
and in practice most scientific Python developers are more interested in
developing extensions.&lt;/p&gt;
&lt;p&gt;The syllabus for the four-hour tutorial will be like this:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Introduction: C-API and Boost.Python basics&lt;/p&gt;
&lt;p&gt;Note that this can be reduced or eliminated of participants are
already comfortable with the topics.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Hello World: Exposing a basic function&lt;/p&gt;
&lt;p&gt;In this section we’ll get a minimal Boost.Python module working. This
will not only introduce students to the infrastructure of
Boost.Python, but it will also give us a chance to make sure that
everyone’s build environment is working.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Exposing functions&lt;/p&gt;
&lt;p&gt;In this section we’ll look at the details of exposing C++ functions
to Python. The topics we’ll cover will include overloading (including
Boost.Python’s auto-overload feature), default argument values, and a
brief look at call policies.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Exposing classes&lt;/p&gt;
&lt;p&gt;Here we’ll look at how to expose C++ classes to Python. Topics will
include the basic &lt;tt class="docutils literal"&gt;class_&amp;lt;T&amp;gt;&lt;/tt&gt; template, member functions, data
members, properties, inheritance, and virtual functions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;boost::python::object&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;boost::python::object&lt;/span&gt;&lt;/tt&gt; class is Boost.Python’s primary
interface to Python’s &lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; structure. Understanding how to
work with this class is a key building-block for developing Python
modules with Boost.Python. We’ll explore its API and features,
including areas like attribute access, reference counting, and
converting between Python and C++ objects.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Derived object types&lt;/p&gt;
&lt;p&gt;Boost.Python provides a number of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;boost::python::object&lt;/span&gt;&lt;/tt&gt;
subclasses for important Python classes like &lt;tt class="docutils literal"&gt;list&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;dict&lt;/tt&gt;, and
&lt;tt class="docutils literal"&gt;tuple&lt;/tt&gt;. In this section we’ll look at these subclasses and how to
use them in Boost.Python modules.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Enums&lt;/p&gt;
&lt;p&gt;Boost.Python provides &lt;tt class="docutils literal"&gt;enum_&amp;lt;T&amp;gt;&lt;/tt&gt; for exposing C++ enums to Python.
Python doesn’t have a notion of enums &lt;em&gt;per se&lt;/em&gt;, but in this section
we’ll explore how this template makes it straightforward to use C++
enums in Python in a simple and intuitive way.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Type conversion&lt;/p&gt;
&lt;p&gt;In this section we’ll look at Boost.Python’s support for doing
automatic type-conversion across the Python/C++ boundary. We’ll see
how you can register type-converters with Boost.Python which will be
invoked whenever Boost.Python needs to convert a Python object to a
C++ object or vice versa.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is a fairly ambitious set of topics, and it’s possible that we
won’t be able to cover them all. The topics are roughly in
most-often-used to least-often-used order, however, so students will be
sure to be exposed to the most important and relevant elements of the
course.&lt;/p&gt;
&lt;p&gt;Likewise, the four-hour format of the course means that we won’t be able
to go into great depth on many topics. The main goal of the course,
then, is to give students enough orientation and hands-on experience
with Boost.Python that they can continue to learn on their own.
Inter-language integration - especially between languages as dissimilar
as C++ and Python - can be quite complex, but this tutorial will give
students the grounding they need to successfully apply Boost.Python to
their problems.&lt;/p&gt;
</summary><category term="boost"></category><category term="c++"></category></entry><entry><title>Integrating Python and C++ with Boost Python part 4</title><link href="https://pyvideo.org/scipy-2014/integrating-python-and-c-with-boost-python-part-2.html" rel="alternate"></link><published>2014-07-09T00:00:00+00:00</published><updated>2014-07-09T00:00:00+00:00</updated><author><name>Austin Bingham</name></author><id>tag:pyvideo.org,2014-07-09:scipy-2014/integrating-python-and-c-with-boost-python-part-2.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Python and C++ can be powerful complements to one another. C++ is great
for performance-critical calculations, while Python is great for
everything else. In this tutorial we’ll look at how to integrate Python
and C++ using the Boost.Python library. You’ll learn techniques for
easily developing hybrid systems that use the right language for the
right task, resulting in better software.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python and C++ are both popular languages that each bring a lot to the
table. The languages also complement one another well: Python is
high-level, dynamic, and easy to use while C++ is at-the-metal, static,
and (in)famously tricky. There are times when there are real advantages
to combining these disparate natures, and Python’s C API provides a
strong interface for doing just that. Boost.Python is a C++ library that
builds upon and improves Python’s C API to give users a simpler, more
intuitive, and safer means to integrate Python and C++.&lt;/p&gt;
&lt;p&gt;In this tutorial we’ll look at how to use Boost.Python to effectively
bridge the Python/C++ boundary. We’ll start by briefly looking at the
fundamentals of the Python C API since that defines the “ground rules”;
this includes things like reference counting, the basic object model,
and so forth. We’ll then quickly look at the Boost.Python API and show
how it provides the same functionality as the underlying C API, but does
so in a way that doesn’t obscure the real semantics of the Python
language.&lt;/p&gt;
&lt;p&gt;After this introduction, the rest of the tutorial will involve writing
code to explore various elements of Boost.Python. We’ll focus on
techniques for extending Python with C++, that is, writing Python
modules in C++. Boost.Python can be used for embedding (i.e. invoking
Python code from C++), but that involves a different set of techniques,
and in practice most scientific Python developers are more interested in
developing extensions.&lt;/p&gt;
&lt;p&gt;The syllabus for the four-hour tutorial will be like this:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Introduction: C-API and Boost.Python basics&lt;/p&gt;
&lt;p&gt;Note that this can be reduced or eliminated of participants are
already comfortable with the topics.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Hello World: Exposing a basic function&lt;/p&gt;
&lt;p&gt;In this section we’ll get a minimal Boost.Python module working. This
will not only introduce students to the infrastructure of
Boost.Python, but it will also give us a chance to make sure that
everyone’s build environment is working.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Exposing functions&lt;/p&gt;
&lt;p&gt;In this section we’ll look at the details of exposing C++ functions
to Python. The topics we’ll cover will include overloading (including
Boost.Python’s auto-overload feature), default argument values, and a
brief look at call policies.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Exposing classes&lt;/p&gt;
&lt;p&gt;Here we’ll look at how to expose C++ classes to Python. Topics will
include the basic &lt;tt class="docutils literal"&gt;class_&amp;lt;T&amp;gt;&lt;/tt&gt; template, member functions, data
members, properties, inheritance, and virtual functions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;boost::python::object&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;boost::python::object&lt;/span&gt;&lt;/tt&gt; class is Boost.Python’s primary
interface to Python’s &lt;tt class="docutils literal"&gt;PyObject&lt;/tt&gt; structure. Understanding how to
work with this class is a key building-block for developing Python
modules with Boost.Python. We’ll explore its API and features,
including areas like attribute access, reference counting, and
converting between Python and C++ objects.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Derived object types&lt;/p&gt;
&lt;p&gt;Boost.Python provides a number of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;boost::python::object&lt;/span&gt;&lt;/tt&gt;
subclasses for important Python classes like &lt;tt class="docutils literal"&gt;list&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;dict&lt;/tt&gt;, and
&lt;tt class="docutils literal"&gt;tuple&lt;/tt&gt;. In this section we’ll look at these subclasses and how to
use them in Boost.Python modules.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Enums&lt;/p&gt;
&lt;p&gt;Boost.Python provides &lt;tt class="docutils literal"&gt;enum_&amp;lt;T&amp;gt;&lt;/tt&gt; for exposing C++ enums to Python.
Python doesn’t have a notion of enums &lt;em&gt;per se&lt;/em&gt;, but in this section
we’ll explore how this template makes it straightforward to use C++
enums in Python in a simple and intuitive way.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Type conversion&lt;/p&gt;
&lt;p&gt;In this section we’ll look at Boost.Python’s support for doing
automatic type-conversion across the Python/C++ boundary. We’ll see
how you can register type-converters with Boost.Python which will be
invoked whenever Boost.Python needs to convert a Python object to a
C++ object or vice versa.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is a fairly ambitious set of topics, and it’s possible that we
won’t be able to cover them all. The topics are roughly in
most-often-used to least-often-used order, however, so students will be
sure to be exposed to the most important and relevant elements of the
course.&lt;/p&gt;
&lt;p&gt;Likewise, the four-hour format of the course means that we won’t be able
to go into great depth on many topics. The main goal of the course,
then, is to give students enough orientation and hands-on experience
with Boost.Python that they can continue to learn on their own.
Inter-language integration - especially between languages as dissimilar
as C++ and Python - can be quite complex, but this tutorial will give
students the grounding they need to successfully apply Boost.Python to
their problems.&lt;/p&gt;
</summary><category term="boost"></category><category term="c++"></category></entry><entry><title>Python refactoring with Rope and Traad</title><link href="https://pyvideo.org/europython-2014/python-refactoring-with-rope-and-traad.html" rel="alternate"></link><published>2014-07-23T00:00:00+00:00</published><updated>2014-07-23T00:00:00+00:00</updated><author><name>Austin Bingham</name></author><id>tag:pyvideo.org,2014-07-23:europython-2014/python-refactoring-with-rope-and-traad.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Rope is a powerful Python refactoring library. Traad (Norwegian for
&amp;quot;thread&amp;quot;) is a tool which makes it simpler to integrate rope into IDEs
via a simple HTTP API. In this session we'll look at how traad and rope
work together and how traad integrates with at least one popular editor.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python is a modern, dynamic language which is growing in popularity, but
tool support for it is sometime lacking or only available in specific
environments. For refactoring and other common IDE functions, however,
the powerful open-source rope library provides a set of tools which are
designed to be integrated into almost any programming environment. Rope
supports most common refactorings, such as renaming and method
extraction, but also more Python-specific refactorings, such as import
organization. Rope’s underlying code analysis engine also allows it to
do things like locating method definitions and generating
auto-completion suggestions.&lt;/p&gt;
&lt;p&gt;While rope is designed to be used from many environments, it’s not
always easy or ideal to integrate rope directly into other programs.
Traad (Norwegian for “thread”) is another open-source project that
addresses this problem by wrapping rope into a simple client-server
model so that client programs (IDEs, editors, etc.) can perform
refactorings without needing to embed rope directly. This simplifies
dependencies, makes clients more robust in the face of errors, eases
traad client development, and even allows clients to do things like
switch between Python 2 and 3 refactoring in the same session.&lt;/p&gt;
&lt;p&gt;In this session we’ll look at how rope operates, and we’ll see how traad
wraps it to provide an easier integration interface. The audience will
get enough information to start using rope themselves, either directly
or via traad, and they’ll see how to use traad for integrating rope into
their own environments. More generally, we’ll look at why client-server
refactoring tools might be preferable to the more standard approach of
direct embedding.&lt;/p&gt;
</summary></entry></feed>