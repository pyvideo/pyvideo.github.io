<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_donovan-preston.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2010-02-19T00:00:00+00:00</updated><entry><title>Actors: What, Why, and How (#161)</title><link href="https://pyvideo.org/pycon-us-2010/pycon-2010--actors--what--why--and-how---161.html" rel="alternate"></link><published>2010-02-19T00:00:00+00:00</published><updated>2010-02-19T00:00:00+00:00</updated><author><name>Donovan Preston</name></author><id>tag:pyvideo.org,2010-02-19:pycon-us-2010/pycon-2010--actors--what--why--and-how---161.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Actors: What, Why and How&lt;/p&gt;
&lt;p&gt;Presented by Donovan Preston&lt;/p&gt;
&lt;p&gt;Since the dawn of concurrency research, there have been two camps:
shared everything, and shared nothing. Most modern applications use
threads for concurrency, a shared everything architecture.&lt;/p&gt;
&lt;p&gt;Actors, however, use a shared nothing architecture where lightweight
processes communicate with each other using message passing. Actors can
change their state, create a new Actor, send a message to any Actor it
has the Address of, and wait for a specific kind of message to arrive in
it's mailbox.&lt;/p&gt;
&lt;p&gt;We will discuss the benefits of using the Actor architecture and
strategies for implementing an Actor system in Python.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://bitbucket.org/fzzzy/python-%20actors/"&gt;http://bitbucket.org/fzzzy/python-actors/&lt;/a&gt;&lt;/p&gt;
</summary><category term="concurrency"></category><category term="eventlet"></category><category term="infrastructure"></category><category term="pycon"></category><category term="pycon2010"></category><category term="rest"></category><category term="scaling"></category><category term="wsgi"></category></entry><entry><title>Eventlet: Asynchronous I/O with a synchronous interface (#141)</title><link href="https://pyvideo.org/pycon-us-2010/pycon-2010--eventlet--asynchronous-i-o-with-a-syn.html" rel="alternate"></link><published>2010-02-19T00:00:00+00:00</published><updated>2010-02-19T00:00:00+00:00</updated><author><name>Donovan Preston</name></author><id>tag:pyvideo.org,2010-02-19:pycon-us-2010/pycon-2010--eventlet--asynchronous-i-o-with-a-syn.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Eventlet: Asynchronous I/O with a synchronous interface&lt;/p&gt;
&lt;p&gt;Presented by Donovan Preston&lt;/p&gt;
&lt;p&gt;Network servers which scale to thousands of simultaneous connections
have always been possible in Python thanks to libraries such as asyncore
and twisted. More recently, FriendFeed's new open source project Tornado
has stirred debate in this area. These libraries allow a Python process
to scale to many simultaneous connections using non-blocking I/O (also
known as asynchronous I/O). However these projects require that the
programmer learn a custom API to abstract away the complexities of using
a callback-style API.&lt;/p&gt;
&lt;p&gt;Eventlet uses greenlet, which provides coroutines as described in &amp;quot;The
Art of Computer Programming&amp;quot;, to implement efficient cooperative
concurrency while retaining synchronous semantics. Eventlet also
provides an implementation of the standard library's socket module. Code
written to use Python's standard socket library can be transparently
converted to use nonblocking I/O and green threads with eventlet. This
leads to much greater code reuse and programmer efficiency.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.eventlet.net/"&gt;http://www.eventlet.net/&lt;/a&gt;&lt;/p&gt;
</summary><category term="asynchronous"></category><category term="eventlet"></category><category term="greenlet"></category><category term="i/o"></category><category term="pycon"></category><category term="pycon2010"></category></entry></feed>