<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org - Joe Kirincic</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_joe-kirincic.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2023-09-17T00:00:00+00:00</updated><subtitle></subtitle><entry><title>Shiny New Tools for Scaling your Shiny Apps</title><link href="https://pyvideo.org/positconf-2023/shiny-new-tools-for-scaling-your-shiny-apps.html" rel="alternate"></link><published>2023-09-17T00:00:00+00:00</published><updated>2023-09-17T00:00:00+00:00</updated><author><name>Joe Kirincic</name></author><id>tag:pyvideo.org,2023-09-17:/positconf-2023/shiny-new-tools-for-scaling-your-shiny-apps.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;So you have a Shiny app your org loves, but as adoption grows, performance starts getting sluggish. Profiling reveals your cool interactive plots are the culprit. What can you do to make things snappy again? We can increase the number of app instances, sure, but suppose that isn't an â€¦&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;So you have a Shiny app your org loves, but as adoption grows, performance starts getting sluggish. Profiling reveals your cool interactive plots are the culprit. What can you do to make things snappy again? We can increase the number of app instances, sure, but suppose that isn't an option for us. Another approach is to shift the plotting work from the server onto the client.&lt;/p&gt;
&lt;p&gt;In this talk, we'll learn how to leverage two Javascript projects, DuckDB-WASM and Observable's Plot.js, in our Shiny app to create fast, flexible interactive visualizations in the browser without burdening our app's server function. The end result is an app that can scale to more users without needing to increase compute resources.&lt;/p&gt;
</content><category term="Posit:Conf 2023"></category></entry></feed>