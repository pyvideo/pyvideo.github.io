<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_itamar-turner-trauring.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2019-11-04T00:00:00+00:00</updated><entry><title>Small Big Data: using NumPy and Pandas when your data doesn't fit in memory</title><link href="https://pyvideo.org/pydata-new-york-city-2019/small-big-data-using-numpy-and-pandas-when-your-data-doesnt-fit-in-memory.html" rel="alternate"></link><published>2019-11-04T00:00:00+00:00</published><updated>2019-11-04T00:00:00+00:00</updated><author><name>Itamar Turner-Trauring</name></author><id>tag:pyvideo.org,2019-11-04:pydata-new-york-city-2019/small-big-data-using-numpy-and-pandas-when-your-data-doesnt-fit-in-memory.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Your data is too big to fit in memory—loading it crashes your program—but it's also too small for a complex Big Data cluster. How to process your data simply and quickly?  In this talk you'll learn the basic techniques for dealing with Small Big Data: money, compression, batching and parallelization, and indexing. In particular, you'll learn how to apply these techniques to NumPy and Pandas.&lt;/p&gt;
</summary></entry><entry><title>Beyond cProfile: performance optimization with sampling profilers and logging</title><link href="https://pyvideo.org/pygotham-2019/beyond-cprofile-performance-optimization-with-sampling-profilers-and-logging.html" rel="alternate"></link><published>2019-10-05T00:00:00+00:00</published><updated>2019-10-05T00:00:00+00:00</updated><author><name>Itamar Turner-Trauring</name></author><id>tag:pyvideo.org,2019-10-05:pygotham-2019/beyond-cprofile-performance-optimization-with-sampling-profilers-and-logging.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Your software is too slow, and you need to figure out why. It's natural to
reach for the cProfile profiler that's built-in to Python, but as a
deterministic profiler it suffers from a number of limitations.&lt;/p&gt;
&lt;p&gt;In this talk you'll learn about better tools for performance optimization:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Sampling profilers, which distort the results less and give you a calltree
overview of your running application.&lt;/li&gt;
&lt;li&gt;Trace-based logging, which can help you figure out not only which
functions are slow, but also which particular inputs are causing the
slowness.&lt;/li&gt;
&lt;/ul&gt;
</summary></entry><entry><title>Logging for Scientific Computing: Reproducibility, Debugging, Optimization</title><link href="https://pyvideo.org/pycon-us-2019/logging-for-scientific-computing-reproducibility-debugging-optimization.html" rel="alternate"></link><published>2019-05-05T13:10:00+00:00</published><updated>2019-05-05T13:10:00+00:00</updated><author><name>Itamar Turner-Trauring</name></author><id>tag:pyvideo.org,2019-05-05:pycon-us-2019/logging-for-scientific-computing-reproducibility-debugging-optimization.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;When it takes hours or days to run your computation, it can take a long
time before you notice something has gone wrong, so your feedback cycle
for fixes can be very slow. If you want to solve problems
quickly—whether it's inconsistent results, crashes, or slowness—you need
to understand what was going on in your process as it was running: you
need logging.&lt;/p&gt;
&lt;p&gt;In this talk you'll learn how to use the Eliot logging library to create
causal traces of your computation, including intermediate inputs and
outputs. You'll then see how these traces can help you:&lt;/p&gt;
&lt;p&gt;Ensure the computation ran as expected. Debug problems that may have
occurred far along within your computation. Identify and localize
performance problems: which parts of your computation were slow, and
what arguments were involved.&lt;/p&gt;
</summary><category term="talk"></category></entry><entry><title>Big picture software testing: unit testing, Lean Startup, and everything in-between</title><link href="https://pyvideo.org/pycon-us-2017/big-picture-software-testing-unit-testing-lean-startup-and-everything-in-between.html" rel="alternate"></link><published>2017-05-19T00:00:00+00:00</published><updated>2017-05-19T00:00:00+00:00</updated><author><name>Itamar Turner-Trauring</name></author><id>tag:pyvideo.org,2017-05-19:pycon-us-2017/big-picture-software-testing-unit-testing-lean-startup-and-everything-in-between.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;There are many ways you can test your software: unit testing, manual
testing, end-to-end testing, and so forth. Take a step back and you'll
discover even more form of testing, many of them very different in their
goals: A/B testing, say, where you see which of two versions of your
website results in more signups or ad clicks.&lt;/p&gt;
&lt;p&gt;How do these forms of testing differ, how do they relate to each other?
How do you choose which kind of testing to pursue, given limited time
and resources? How do you deal with strongly held yet opposite views
arguing either that a particular kind of testing is essential or that
it's a waste time?&lt;/p&gt;
&lt;p&gt;This talk will provide you with a model, a way to organize all forms of
testing and understand what exactly they provide, and why. Once you
understand the model you will be able to choose the right form of
testing for &lt;em&gt;your&lt;/em&gt; situation and goals.&lt;/p&gt;
</summary></entry><entry><title>Intermediate Twisted: Test-Driven Networking Software</title><link href="https://pyvideo.org/pycon-us-2013/intermediate-twisted-test-driven-networking-soft.html" rel="alternate"></link><published>2013-03-14T00:00:00+00:00</published><updated>2013-03-14T00:00:00+00:00</updated><author><name>Itamar Turner-Trauring</name></author><id>tag:pyvideo.org,2013-03-14:pycon-us-2013/intermediate-twisted-test-driven-networking-soft.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Writing tests for networking code presents special challenges, which
Twisted tries to address. In this tutorial you will implement a toy HTTP
server using test-first methodology: first the tests are written, and
then the code. You will learn how to write well-tested network
applications using Twisted, and the general virtues of doing test-driven
development.&lt;/p&gt;
</summary><category term="tutorial"></category></entry><entry><title>A Beginner's Guide to Test-driven Development</title><link href="https://pyvideo.org/pycon-us-2015/a-beginners-guide-to-test-driven-development.html" rel="alternate"></link><published>2015-04-11T00:00:00+00:00</published><updated>2015-04-11T00:00:00+00:00</updated><author><name>Itamar Turner-Trauring</name></author><id>tag:pyvideo.org,2015-04-11:pycon-us-2015/a-beginners-guide-to-test-driven-development.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Software is maintained by humans with limited memory and an unfortunate
tendency to make mistakes. Test-driven development (TDD) can help you
work around these design flaws by providing a permanent, automated
specification for your code. Learn how to implement TDD when bug fixing
and implementing new features and how this process will ensure your code
is correct both now and in the future.&lt;/p&gt;
</summary></entry></feed>