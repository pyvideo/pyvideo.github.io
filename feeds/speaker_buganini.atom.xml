<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org - Buganini</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_buganini.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2021-10-02T00:00:00+00:00</updated><subtitle></subtitle><entry><title>DAFunctor: Symbolic translator from NumPy/PyTorch ND-Array operations to C – Buganini (PyCon TW21)</title><link href="https://pyvideo.org/pycon-taiwan-2021/dafunctor-symbolic-translator-from-numpypytorch-nd-array-operations-to-c-buganini-pycon-tw21.html" rel="alternate"></link><published>2021-10-02T00:00:00+00:00</published><updated>2021-10-02T00:00:00+00:00</updated><author><name>Buganini</name></author><id>tag:pyvideo.org,2021-10-02:/pycon-taiwan-2021/dafunctor-symbolic-translator-from-numpypytorch-nd-array-operations-to-c-buganini-pycon-tw21.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Day 1, 10:40-11:25&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;DAFunctor aims to reduce the increasing gap between science and engineering. ND-Array is a crucial part of modern algorithm design. It reduces the mental burden for designers and bypasses Python's slow loop. However, using lower-level languages like C/C++ is sometimes unavoidable on …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Day 1, 10:40-11:25&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;DAFunctor aims to reduce the increasing gap between science and engineering. ND-Array is a crucial part of modern algorithm design. It reduces the mental burden for designers and bypasses Python's slow loop. However, using lower-level languages like C/C++ is sometimes unavoidable on productization. Some strict development guidelines like MISRA even forbid dynamic memory allocation, making engineering more difficult. Manual translation to C/C++ usually introduces human errors. Other function-to-function auto translators generate lots of boilerplate code and require many intermediate buffers. On the contrary symbolic translation generates only the essential logic. Imperative programming style makes the performance directly depends on the implementation; symbolic translation can also eliminate part of the inefficiency caused by the programmer, thus make benchmarking more normalized. The making of DAFunctor also involves fun low-level hacks on the Python interpreter.&lt;/p&gt;
&lt;p&gt;Slides: &lt;a class="reference external" href="https://www.slideshare.net/Buganini/dafunctor-250351849"&gt;https://www.slideshare.net/Buganini/dafunctor-250351849&lt;/a&gt;
HackMD: &lt;a class="reference external" href="https://hackmd.io/&amp;#64;pycontw/2021/%2F%40pycontw%2FByS9zeYfK"&gt;https://hackmd.io/&amp;#64;pycontw/2021/%2F%40pycontw%2FByS9zeYfK&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Speaker: Buganini&lt;/p&gt;
&lt;p&gt;Pythonista since 2008&lt;/p&gt;
</content><category term="PyCon Taiwan 2021"></category></entry></feed>