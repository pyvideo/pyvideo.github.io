<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_dave-halter.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2017-10-25T00:00:00+00:00</updated><entry><title>Python is Weird</title><link href="https://pyvideo.org/swiss-python-summit-2017/python-is-weird.html" rel="alternate"></link><published>2017-02-17T00:00:00+00:00</published><updated>2017-02-17T00:00:00+00:00</updated><author><name>Dave Halter</name></author><id>tag:pyvideo.org,2017-02-17:swiss-python-summit-2017/python-is-weird.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;A lot of people think that Python is a really simple and straightforward language. Python hides a lot of peculiarities very well, but for the sake of this talk we will try to uncover them.&lt;/p&gt;
&lt;p&gt;I will be explaining how the whole process of tokenizing - parsing - ast creation - bytecode works and will use odd Python code to show the internals. Do you think &lt;cite&gt;++4;&lt;/cite&gt; is valid Python? Or how about &lt;cite&gt;0jif.1else-2&lt;/cite&gt;? There's no spaces in it. Go figure! &amp;quot;Edge cases&amp;quot; will help us understand the inner workings of Python.&lt;/p&gt;
&lt;p&gt;We will be looking into how modules, classes and instances are really just fancy dictionaries and how importing is really nothing else than storing a module into a dictionary (&lt;cite&gt;sys.modules&lt;/cite&gt;).&lt;/p&gt;
&lt;p&gt;There's a lot of things we can learn from diving deep into the details of our beloved languages.&lt;/p&gt;
&lt;p&gt;Talk recorded at the Swiss Python Summit on February 17th, 2017.&lt;/p&gt;
&lt;p&gt;Licensed as Creative Commons Attribution 4.0 International&lt;/p&gt;
</summary></entry><entry><title>Python is Weird</title><link href="https://pyvideo.org/pycon-de-2017/python-is-weird.html" rel="alternate"></link><published>2017-10-25T00:00:00+00:00</published><updated>2017-10-25T00:00:00+00:00</updated><author><name>Dave Halter</name></author><id>tag:pyvideo.org,2017-10-25:pycon-de-2017/python-is-weird.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Dave Halter&lt;/strong&gt; (&amp;#64;jedidjah_ch)&lt;/p&gt;
&lt;p&gt;I'm an engineer for cloudscale.ch. We are serving cloud services (mostly IaaS) with a focus on simplicity. In my free time I work a lot on parsers/type inference for the Python world. Jedi is probably the project people would know me for.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Abstract&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A lot of people think that Python is a really simple and straightforward language. Python hides a lot of peculiarities very well, but for the sake of this talk we will try to uncover them.&lt;/p&gt;
&lt;p&gt;Is ++4; valid Python? And what does it do? Let me give you an introduction into tokenizers/parsers.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A lot of people think that Python is a really simple and straightforward language. Python hides a lot of peculiarities very well, but for the sake of this talk we will try to uncover them.&lt;/p&gt;
&lt;p&gt;I will be explaining how the whole process of tokenizing - parsing - ast creation - bytecode works and will use odd Python code to give you an insight on the internals. Do you think ++4; is valid Python? Or how about 0jif.1else-2? There are no spaces in it. Go figure! &amp;quot;Edge cases&amp;quot; will help us understand the inner workings of Python. These two cases are possible, because of the tokenizer. Other &amp;quot;weird&amp;quot; Python code is waiting as soon as you start looking at the grammar file. Have you for example heard about lambda generators?&lt;/p&gt;
&lt;p&gt;We will be looking into how modules, classes and instances are really just fancy dictionaries and how importing is really nothing else than storing a module into a dictionary (sys.modules).&lt;/p&gt;
&lt;p&gt;There are a lot of things we can learn from diving deep into the details of our beloved languages. This talk will give you a very small introduction in how languages are built and explain how Python itself is defined by its parser, tokenizer and bytecode generation. Knowing how those abstractions work makes you a better Python programmer, because you will know better how the language behaves.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Recorded at&lt;/strong&gt; PyCon.DE 2017 Karlsruhe: &lt;a class="reference external" href="https://de.pycon.org/"&gt;https://de.pycon.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Video editing&lt;/strong&gt;: Sebastian Neubauer &amp;amp; Andrei Dan&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tools&lt;/strong&gt;: Blender, Avidemux &amp;amp; Sonic Pi&lt;/p&gt;
</summary><category term="tokenizer"></category><category term="parser"></category><category term="python"></category></entry><entry><title>Dave Halter – API Design is Hard – SPS16</title><link href="https://pyvideo.org/swiss-python-summit-2016/dave-halter-api-design-is-hard-sps16.html" rel="alternate"></link><published>2016-02-05T00:00:00+00:00</published><updated>2016-02-05T00:00:00+00:00</updated><author><name>Dave Halter</name></author><id>tag:pyvideo.org,2016-02-05:swiss-python-summit-2016/dave-halter-api-design-is-hard-sps16.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;&amp;quot;Have you ever been really annoyed about some APIs of open source libraries? There's are good reasons to be. Most libraries are devoted to backwards compatibility and are not able to change content anymore.
Coming from writing a Python library called &amp;quot;Jedi&amp;quot;, I can feel with you. I have hated my own APIs more than enough. I have learned the hard way and want to tell you a few things I would have loved to hear years earlier!&amp;quot;&lt;/p&gt;
&lt;p&gt;Talk recorded at the Swiss Python Summit on February 5th, 2016.&lt;/p&gt;
&lt;p&gt;Licensed as Creative Commons Attribution 4.0 International.&lt;/p&gt;
</summary></entry><entry><title>Identifying Bugs Before Runtime With Jedi</title><link href="https://pyvideo.org/europython-2014/identifying-bugs-before-runtime-with-jedi.html" rel="alternate"></link><published>2014-07-23T00:00:00+00:00</published><updated>2014-07-23T00:00:00+00:00</updated><author><name>Dave Halter</name></author><id>tag:pyvideo.org,2014-07-23:europython-2014/identifying-bugs-before-runtime-with-jedi.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Finding bugs before runtime has been an incredibly tedious task in
Python. Jedi is an autocompletion library with interesting capabilities:
It understands a lot of the dynamic features of Python. I will show you
how we can use the force of (the) Jedi to identify bugs in your Python
code. It's not just another pylint. It's way better.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Jedi is an autocompletion library for Python that has gained quite a
following over the last year. There are a couple of plugins for the most
popular editors (VIM, Sublime, Emacs, etc.) and mainstream IDEs like
Spyder are switching to Jedi.&lt;/p&gt;
&lt;p&gt;Jedi basically tries to redefine the boundaries of autocompletion in
dynamic languages. Most people still think that there's no hope for
decent autocompletion in Python. This talk will try to argue the
opposite, that decent autocompletion is very close.&lt;/p&gt;
&lt;p&gt;While the first part will be about Jedi, the second part of this talk
will discuss the future of dynamic analysis. Dynamic Analysis is what I
call the parts that static analysis doesn't cover. The hope is to
generate a kind of &amp;quot;compiler&amp;quot; that doesn't execute code but reports
additional bugs in your code (AttributeErrors and the like).&lt;/p&gt;
&lt;p&gt;I still have to work out the details of the presentation. I also have to
add that Jedi I'm currently working full-time on Jedi and that there's
going to be some major improvements until the conference. Autocompletion
and static/dynamic analysis as well as refactoring are hugely important
tools for a dynamic language IMHO, because they can improve the only big
disadvantage compared to static languages: Finding bugs before running
your tool.&lt;/p&gt;
</summary></entry></feed>