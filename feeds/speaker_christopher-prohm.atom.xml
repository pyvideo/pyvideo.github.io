<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org - Christopher Prohm</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_christopher-prohm.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2023-04-17T00:00:00+00:00</updated><subtitle></subtitle><entry><title>Prototyping to tested code</title><link href="https://pyvideo.org/pycon-de-2018/prototyping-to-tested-code.html" rel="alternate"></link><published>2018-10-26T00:00:00+00:00</published><updated>2018-10-26T00:00:00+00:00</updated><author><name>Christopher Prohm</name></author><id>tag:pyvideo.org,2018-10-26:/pycon-de-2018/prototyping-to-tested-code.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Jupyter notebooks are a great environment to prototype solutions and
explore their design. Turning these solutions into reusable components
usually requires moving them out of the notebook environment into
external python packages. Often, at this stage, the code is refactored
and test are written.&lt;/p&gt;
&lt;p&gt;In this talk, I will …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Jupyter notebooks are a great environment to prototype solutions and
explore their design. Turning these solutions into reusable components
usually requires moving them out of the notebook environment into
external python packages. Often, at this stage, the code is refactored
and test are written.&lt;/p&gt;
&lt;p&gt;In this talk, I will demo
&lt;tt class="docutils literal"&gt;`ipytest&lt;/tt&gt; &amp;lt;&lt;a class="reference external" href="https://github.com/chmp/ipytest"&gt;https://github.com/chmp/ipytest&lt;/a&gt;&amp;gt;`__, a small tool to run
tests inside notebooks. It supports &lt;tt class="docutils literal"&gt;`pytest&lt;/tt&gt; &amp;lt;&lt;a class="reference external" href="http://pytest.org/"&gt;http://pytest.org/&lt;/a&gt;&amp;gt;`__
as well as the standard
&lt;tt class="docutils literal"&gt;`unittest&lt;/tt&gt; &amp;lt;&lt;a class="reference external" href="https://docs.python.org/3/library/unittest.html"&gt;https://docs.python.org/3/library/unittest.html&lt;/a&gt;&amp;gt;`__
framework. It allows to start prototypes in a notebook and to develop
the tests with the code in an highly interactive environment. As the
code grows, it can be transparently moved outside notebooks and
transformed into reusable components. By bringing support for tests to
the notebook environment,
&lt;tt class="docutils literal"&gt;`ipytest&lt;/tt&gt; &amp;lt;&lt;a class="reference external" href="https://github.com/chmp/ipytest"&gt;https://github.com/chmp/ipytest&lt;/a&gt;&amp;gt;`__ bridges the artificial
gap between notebooks and reusable components.&lt;/p&gt;
</content><category term="PyCon DE 2018"></category><category term="Data Science"></category><category term="Machine Learning"></category></entry><entry><title>Pragmatic ways of using Rust in your data project</title><link href="https://pyvideo.org/pydata-berlin-2023/pragmatic-ways-of-using-rust-in-your-data-project.html" rel="alternate"></link><published>2023-04-17T00:00:00+00:00</published><updated>2023-04-17T00:00:00+00:00</updated><author><name>Christopher Prohm</name></author><id>tag:pyvideo.org,2023-04-17:/pydata-berlin-2023/pragmatic-ways-of-using-rust-in-your-data-project.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Writing efficient data pipelines in Python can be tricky. The standard recommendation is to use vectorized functions implemented in Numpy, Pandas, or the like. However, what to do, when the processing task does not fit these libraries? Using plain Python for processing can result in lacking performance, in particular …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Writing efficient data pipelines in Python can be tricky. The standard recommendation is to use vectorized functions implemented in Numpy, Pandas, or the like. However, what to do, when the processing task does not fit these libraries? Using plain Python for processing can result in lacking performance, in particular when handling large data sets.&lt;/p&gt;
&lt;p&gt;Rust is a modern, performance-oriented programming language that is already widely used by the Python community. Augmenting data processing steps with Rust can result in substantial speed ups. In this talk will present strategies of using Rust in a larger Python data processing pipeline with a particular focus on pragmatism and minimizing integration efforts.&lt;/p&gt;
</content><category term="PyData Berlin 2023"></category><category term="Rust"></category></entry></feed>