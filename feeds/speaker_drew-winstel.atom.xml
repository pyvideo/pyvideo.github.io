<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_drew-winstel.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2018-10-17T00:00:00+00:00</updated><entry><title>Django REST Framework: Moving Past the Tutorial to Production</title><link href="https://pyvideo.org/djangocon-us-2018/django-rest-framework-moving-past-the-tutorial-to-production.html" rel="alternate"></link><published>2018-10-17T00:00:00+00:00</published><updated>2018-10-17T00:00:00+00:00</updated><author><name>Drew Winstel</name></author><id>tag:pyvideo.org,2018-10-17:djangocon-us-2018/django-rest-framework-moving-past-the-tutorial-to-production.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;So you’ve made your first attempt at creating a DRF API, but now you
need to figure out how to put the hair on the proverbial pony. You want
to make things easier on your client developers so they can get exactly
what they need. I’ll walk through things that made our lives better
developing a Django REST Framework API serving a React frontend.&lt;/p&gt;
&lt;p&gt;I’ll include optimizations such as embedding related fields into
serializers, using different serializers for different users and use
cases (HTTP methods), and using DRF’s &lt;tt class="docutils literal"&gt;actions&lt;/tt&gt; decorator to provide
easy access to related tasks. I’ll also touch on some third-party
libraries that made life way easier, such as &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;rest-framework-filters&lt;/span&gt;&lt;/tt&gt;,
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;django-rest-swagger&lt;/span&gt;&lt;/tt&gt;, and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;django-simple-&lt;/span&gt; history&lt;/tt&gt;.&lt;/p&gt;
</summary></entry></feed>