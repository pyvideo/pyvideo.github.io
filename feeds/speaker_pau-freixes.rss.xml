<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org - Pau Freixes</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Thu, 23 Jul 2020 00:00:00 +0000</lastBuildDate><item><title>gRPC Python, C Extensions, and AsyncIO</title><link>https://pyvideo.org/europython-2020/grpc-python-c-extensions-and-asyncio.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;How to make AsyncIO work with the gRPC Core&lt;/p&gt;
&lt;p&gt;Goal - Encourage Python developers to understand C extensions by sharing gRPC Python’s practice, and advocate the adoption of AsyncIO.&lt;/p&gt;
&lt;p&gt;Prerequisite
- Understand thread vs. process;
- Interested in asynchronous programming.&lt;/p&gt;
&lt;p&gt;gRPC Brief
- What’s gRPC Core? And what is gRPC Python?&lt;/p&gt;
&lt;p&gt;Cython To The Rescue
- Why we picked Cython among all other available tools (e.g., pybind11, ctypes)
- Debuggability: pdb &amp;amp; gdb&lt;/p&gt;
&lt;p&gt;The GIL Friction
- How to delegate work to C extension
- How to make multithreading work&lt;/p&gt;
&lt;p&gt;AsyncIO Topic
- Not blocking the loop, the main headache.
- Non-blocking I/O solution 1: replacing C libraries’ I/O operations
- Non-blocking I/O solution 2: dedicated background poller thread
- Performance improvement (10k -&amp;gt; 20k for client, 4k -&amp;gt; 16k for server)&lt;/p&gt;
&lt;p&gt;Migration to AsyncIO
- Tolerate multithreading and AsyncIO in the same application
- Make both API co-existable in the same application&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Lidi Zheng</dc:creator><pubDate>Thu, 23 Jul 2020 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2020-07-23:/europython-2020/grpc-python-c-extensions-and-asyncio.html</guid><category>EuroPython 2020</category><category>europython</category><category>europython-2020</category><category>europython-online</category><category>ASYNC / Concurreny</category><category>CPython</category><category>Cython</category><category>Performance</category></item><item><title>Amqp from Python, advanced design patterns</title><link>https://pyvideo.org/pycon-es-2015/amqp-from-python-advanced-design-patterns.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;AMQP as standard application layer protocol is widely used to design backends where business logic is spread around different processes using a broker to link them, usually RabbitMQ. AMQP allows us to use different design patterns than the traditional monolithic backends, where part of your business logic is designed as entities of the AMQP topology. In this talk we will talk about the Python drivers such as Celery, Pika and others, and how they can be used to get the full power of the AMQP.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Pau Freixes</dc:creator><pubDate>Tue, 02 Feb 2016 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2016-02-02:/pycon-es-2015/amqp-from-python-advanced-design-patterns.html</guid><category>PyCon ES 2015</category><category>Track Avanzado</category></item></channel></rss>