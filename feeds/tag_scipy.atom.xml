<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/tag_scipy.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2018-04-21T00:00:00+00:00</updated><entry><title>Hacking Your Way Into Machine Learning</title><link href="https://pyvideo.org/pycon-italia-2018/hacking-your-way-into-machine-learning.html" rel="alternate"></link><published>2018-04-21T00:00:00+00:00</published><updated>2018-04-21T00:00:00+00:00</updated><author><name>Laksh Arora</name></author><id>tag:pyvideo.org,2018-04-21:pycon-italia-2018/hacking-your-way-into-machine-learning.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;You might have heard of Machine Learning from your co-worker or in a local meetup and are enticed to get started but not sure how to take that first step. Confused between different sources, where to start from or how to proceed given a particular problem statement or dataset, then this talk is for you. It is aimed at complete beginners ( maybe you? ) who are just starting in machine learning and are ready to commit.
The talk will go something like this - each of the following items will be explained how it’s useful and why we should use it. Then alongside showcase, that same step applied to the real example(dataset) of that particular item so that the audience will be able to grasp the idea. It will add to around 35 minutes leaving us with 10 minutes for Q&amp;amp;A.
1) Context ( 5 mins ):
Discuss why we need Machine Learning and how we can use Machine Learning in different domains.
2) Resources ( 3 mins):
Talks about the dataset availability, online competitions, and Open Source libraries such as Scikit-learn, Matplotlib, Keras.
3) Jupyter Notebook (25 mins):
This Jupyter notebook will be a great starting point for most Supervised Machine Learning projects that involve common tasks: a) Imports and data loading (2 mins )
b) Data Exploration (5 mins)
c) Data Cleaning (3 mins)
d) Feature Engineering (4 mins)
e) Model Exploration (6 mins)
f) Final Model Building and Prediction ( 5 mins)
4) Wrap up ( 2 mins ):
Finalizing my talk, sharing some tips etc.
5) Q&amp;amp;A ( 10 mins ):
Question and Answering with the Audience.
Hope to inspire the audience to get started with machine learning, explore different domains, to learn, to create and engage with the Machine Learning Community.&lt;/p&gt;
</summary><category term="data-analysis"></category><category term="data-visualization"></category><category term="Python"></category><category term="scikit-learn"></category><category term="matplotlib"></category><category term="analytics"></category><category term="scipy"></category><category term="machine-learning"></category><category term="data"></category><category term="Statistical Learning"></category></entry><entry><title>Predicting future states using High Order Markov Chains</title><link href="https://pyvideo.org/pycon-italia-2018/predicting-future-states-using-high-order-markov-chains.html" rel="alternate"></link><published>2018-04-21T00:00:00+00:00</published><updated>2018-04-21T00:00:00+00:00</updated><author><name>Pietro Mascolo</name></author><id>tag:pyvideo.org,2018-04-21:pycon-italia-2018/predicting-future-states-using-high-order-markov-chains.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In modern automated systems (Interactive Voice Response, help chatbots,
routing systems, etc.) it is very often important to be able to predict
what is the most likely next step for the current user. One way of
addressing this issue is using sequence algorithms such as Markov
Chains.&lt;/p&gt;
&lt;p&gt;After a quick introduction to the concept of Markov chains and Markov
processes, we will explore the basics and the implementation of a simple
High Order Markov chain to predict what the most likely next state in a
sequence, based on previous states. We will be using anonymized
real-life data of an automated system and we will try to come up with a
model that can give us the most probable next state using Markov chains
of different orders.&lt;/p&gt;
&lt;p&gt;Things we will see in detail: - Mathematics and rationale behind Markov
Chains; - Basic implementation of First Order Markov Chains; -
Implementation of High Order Markov Chains; - Real life application of
the developed model.&lt;/p&gt;
&lt;p&gt;An undergraduate level of understanding of Linear Algebra and basic
Python skills will be useful to follow the talk.&lt;/p&gt;
&lt;p&gt;in __on &lt;strong&gt;sabato 21 aprile&lt;/strong&gt; at 15:30 &lt;a class="reference external" href="/p3/schedule/pycon9/"&gt;**See
schedule**&lt;/a&gt;&lt;/p&gt;
</summary><category term="pydata"></category><category term="Pyston"></category><category term="algebra"></category><category term="Machine Learning"></category><category term="scipy"></category><category term="data-analysis"></category><category term="mathematics"></category><category term="data"></category><category term="python3"></category></entry><entry><title>Doing frequentist statistics with Scipy</title><link href="https://pyvideo.org/pydata-dc-2016/doing-frequentist-statistics-with-scipy.html" rel="alternate"></link><published>2016-10-07T00:00:00+00:00</published><updated>2016-10-07T00:00:00+00:00</updated><author><name>Gustavo Patino</name></author><id>tag:pyvideo.org,2016-10-07:pydata-dc-2016/doing-frequentist-statistics-with-scipy.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;PyData DC 2016&lt;/p&gt;
&lt;p&gt;Github: &lt;a class="reference external" href="https://github.com/gapatino/Doing-frequentist-statistics-with-Scipy"&gt;https://github.com/gapatino/Doing-frequentist-statistics-with-Scipy&lt;/a&gt;
Slides: &lt;a class="reference external" href="http://www.slideshare.net/PyData/doing-frequentist-statistics-with-scipy"&gt;http://www.slideshare.net/PyData/doing-frequentist-statistics-with-scipy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Frequentist statistical tests are still very common, and in some fields they continue to represent the technical standard. In this session we will cover the execution and interpretation of the most common tests using the SciPy.stats package, and plotting the results with Matplotlib and Seaborn. The focus will be on traditional approaches to the tests, not on Bayesian and bootstrapping approaches&lt;/p&gt;
&lt;p&gt;The session will cover: - Normality testing - Student's t-test and ANOVA - Wilcoxon rank sum and Kruskal-Wallis - Correlation - Univariate linear and logistic regression - Chi-square - p-value interpretation - Effect size calculation&lt;/p&gt;
</summary><category term="scipy"></category><category term="statistics"></category></entry><entry><title>¡Eureka! (Python y ciencia)</title><link href="https://pyvideo.org/pyday-galicia-2016/eureka-python-y-ciencia.html" rel="alternate"></link><published>2016-09-17T00:00:00+00:00</published><updated>2016-09-17T00:00:00+00:00</updated><author><name>Miguel Sánchez de León Peque</name></author><id>tag:pyvideo.org,2016-09-17:pyday-galicia-2016/eureka-python-y-ciencia.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;En esta charla se plantea una pregunta de física básica que se resolverá científicamente con ingenio, mátemáticas y python, aprovechando para (de una manera amena) ver librerías habituales en el entorno científico como sympy, numpy, scipy, matplotlib, bokeh, numba, pandas y sklearn.&lt;/p&gt;
</summary><category term="pyday"></category><category term="sympy"></category><category term="numpy"></category><category term="scipy"></category><category term="matplotlib"></category><category term="bokeh"></category><category term="numba"></category><category term="pandas"></category><category term="sklearn"></category></entry><entry><title>Python at the Intersection of Data Science, Machine Learning &amp; Cyber Anomaly Detection</title><link href="https://pyvideo.org/scipy-2016/python-at-the-intersection-of-data-science-machine-learning-cyber-anomaly-detection-scipy-2016.html" rel="alternate"></link><published>2016-07-14T00:00:00+00:00</published><updated>2016-07-14T00:00:00+00:00</updated><author><name>Randy Paffenroth</name></author><id>tag:pyvideo.org,2016-07-14:scipy-2016/python-at-the-intersection-of-data-science-machine-learning-cyber-anomaly-detection-scipy-2016.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;This talk will focus on the use of Python, scikit-learn, NumPy, SciPy, and pandas in Data Science and machine learning with a focus on cyber anomaly detection. The presentation will focus on how Python facilitates all stages of such analysis including data gathering, analytics, and scaling to large data sets.&lt;/p&gt;
</summary><category term="scikit-learn"></category><category term="numpy"></category><category term="scipy"></category><category term="pandas"></category></entry><entry><title>Python in Big Data with an overview of NumPy &amp; SciPy</title><link href="https://pyvideo.org/pydata/python-in-big-data-with-an-overview-of-numpy-sc.html" rel="alternate"></link><published>2012-03-02T00:00:00+00:00</published><updated>2012-03-02T00:00:00+00:00</updated><author><name>Travis Oliphant</name></author><id>tag:pyvideo.org,2012-03-02:pydata/python-in-big-data-with-an-overview-of-numpy-sc.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Travis Oliphant, CEO of Continuum Analytics, kicks off the PyData
Workshop with a talk on Python in Big Data. Topics addressed include
what Python has to offer the world of Big Data, specific use-cases, as
well asking why Hadoop is considered the de-facto standard.&lt;/p&gt;
&lt;p&gt;Additionally, Travis gives an overview of NumPy and SciPy.&lt;/p&gt;
</summary><category term="hadoop"></category><category term="numpy"></category><category term="scipy"></category></entry><entry><title>PyOhio 2010: Implementation of a Numerical Simulation in Python</title><link href="https://pyvideo.org/pyohio-2010/pyohio-2010--implementation-of-a-numerical-simula.html" rel="alternate"></link><published>2010-07-31T00:00:00+00:00</published><updated>2010-07-31T00:00:00+00:00</updated><author><name>Jeffrey Armstrong</name></author><id>tag:pyvideo.org,2010-07-31:pyohio-2010/pyohio-2010--implementation-of-a-numerical-simula.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Implementation of a Numerical Simulation in Python&lt;/p&gt;
&lt;p&gt;Presented by Jeffrey B. Armstrong&lt;/p&gt;
&lt;p&gt;The Python programming language is well suited for numerical computation
under a variety of circumstances. Python offers advantages over
competing free and commercial technologies, including price,
functionality, and maintainability. Specifically, the combination of
mature numerical libraries and liberal licensing allow complex
simulations to be coded with ease and to be made available to nearly all
interested parties. !NumPy/!SciPy, database access, networking, and
optimization techniques are examined in detail with respect to numerical
computation. A practical example involving an aerothermal commercial
turbofan aircraft engine simulation showcases these advantages. An
aircraft engine is broken down into discrete stages, including
compressors, turbines, and other flow-related components. Commonalities
between components, such as rotation and the presence of inlet and exit
conditions, map cleanly to the object-oriented nature of Python. Based
on simulation needs and hardware availability, Python allows for the
parallel computation of simulations without the expense and complexity
of commercial parallelization packages.&lt;/p&gt;
</summary><category term="database"></category><category term="networking"></category><category term="numpy"></category><category term="optimization"></category><category term="pyohio"></category><category term="pyohio2010"></category><category term="scipy"></category><category term="simulation"></category></entry><entry><title>A comprehensive look at representing physical quantities in Python</title><link href="https://pyvideo.org/scipy-2013/a-comprehensive-look-at-representing-physical-qua.html" rel="alternate"></link><published>2013-07-02T00:00:00+00:00</published><updated>2013-07-02T00:00:00+00:00</updated><author><name>Trevor Bekolay</name></author><id>tag:pyvideo.org,2013-07-02:scipy-2013/a-comprehensive-look-at-representing-physical-qua.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Why tracking physical quantities is an essential function for any
programming language heavily used in science and a possible unification
of the existing packages that enable the majority of use cases.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Authors: Bekolay, Trevor, University of Waterloo&lt;/p&gt;
&lt;p&gt;Track: General&lt;/p&gt;
&lt;p&gt;Code that properly tracks the units associated with physical quantities
is self-documenting and far more robust to unit conversion errors. Unit
conversion errors are common in any program that deal with physical
quantities, and have been responsible for several expensive and
dangerous software errors, like the Mars Climate Orbiter crash. Support
for tracking units is lacking in commonly used packages like NumPy and
SciPy. As a result, a whole host of packages have been created to fill
this gap, with varying implementations. Some build on top of the
commonly used scientific packages, adding to their data structures the
ability to track units. Others packages track units separately, and
store a mapping between units and the data structures containing
magnitudes.&lt;/p&gt;
&lt;p&gt;I will discuss why tracking physical quantities is an essential function
for any programming language heavily used in science. I will then
compare and contrast all of the packages that currently exist for
tracking quantities in terms of their functionality, syntax, underlying
implementation, and performance. Finally, I will present a possible
unification of the existing packages that enables the majority of use
cases, and I will discuss where that unified implementation fits into
the current scientific Python environment.&lt;/p&gt;
</summary><category term="scipy"></category></entry><entry><title>The Wonderful World of Scientific Computing with Python</title><link href="https://pyvideo.org/scipy-2014/the-wonderful-world-of-scientific-computing-with.html" rel="alternate"></link><published>2014-07-09T00:00:00+00:00</published><updated>2014-07-09T00:00:00+00:00</updated><author><name>David P. Sanders</name></author><id>tag:pyvideo.org,2014-07-09:scipy-2014/the-wonderful-world-of-scientific-computing-with.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;We will give an overview of the basics of the scientific computing
ecosystem with Python: what does each of the fundamental packages
(numpy, matplotlib, scipy, sympy and pandas) do, and how does it work?
We will use the IPython Notebook in our quest to enter this wonderful
world.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Starting out with scientific computing in Python can be daunting: Where
do I start? What are the basic packages, and what is the use case for
each of them? What are the fundamental ideas I need to understand each
package and how it works?&lt;/p&gt;
&lt;p&gt;In this tutorial, we will use examples of scientific questions and
calculations which lead directly to the need for certain computational
tools as a gateway to understand the basic structure of the scientific
computing ecosystem. The specific packages we will touch on are
&lt;tt class="docutils literal"&gt;numpy&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;matplotlib&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;scipy&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;sympy&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;pandas&lt;/tt&gt;, all
viewed through the wonderful lens of the IPython Notebook.&lt;/p&gt;
</summary><category term="matplotlib"></category><category term="numpy"></category><category term="pandas"></category><category term="scipy"></category><category term="sympy"></category></entry><entry><title>Python for Scientific and High Performance Computing (3 of 4)</title><link href="https://pyvideo.org/chipy/python-for-scientific-and-high-performance-compu0.html" rel="alternate"></link><published>2009-11-12T00:00:00+00:00</published><updated>2009-11-12T00:00:00+00:00</updated><author><name>Unknown</name></author><id>tag:pyvideo.org,2009-11-12:chipy/python-for-scientific-and-high-performance-compu0.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python for Scientific and High Performance Computing (part 3 of 4)&lt;/p&gt;
&lt;p&gt;Python, a high-level portable multi-paradigm interpreted programming
language is becoming increasingly popular with the scientific and HPC
communities due to ease of use, large collection of modules,
adaptability, and strong support from vendors and community alike. This
tutorial provides an introduction to Python focused on HPC and
scientific computing. Throughout, we provide concrete examples, hands-on
examples, and links to additional sources of information. The result
will be a clear sense of possibilities and best practices using Python
in HPC environments. We will cover several key concepts: language
basics, NumPy and SciPy, parallel programming, performance issues,
integrating C and Fortran, basic visualization, large production codes,
and finding resources. While it is impossible to address all libraries
and application domains, at the end participants should be able to write
a simple application making use of parallel programming techniques,
visualize the output, and know how to confidently proceed with future
projects with Python.&lt;/p&gt;
&lt;p&gt;ChiPy is a group of Chicago Python Programmers, l33t, and n00bs.
Meetings are held monthly at various locations around Chicago. Also,
ChiPy is a proud sponsor of many Open Source and Educational efforts in
Chicago.&lt;/p&gt;
</summary><category term="chipy"></category><category term="numpy"></category><category term="scipy"></category></entry><entry><title>Python for Scientific and High Performance Computing (2 of 4)</title><link href="https://pyvideo.org/chipy/python-for-scientific-and-high-performance-compu1.html" rel="alternate"></link><published>2009-11-12T00:00:00+00:00</published><updated>2009-11-12T00:00:00+00:00</updated><author><name>Unknown</name></author><id>tag:pyvideo.org,2009-11-12:chipy/python-for-scientific-and-high-performance-compu1.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python for Scientific and High Performance Computing (part 2 of 4)&lt;/p&gt;
&lt;p&gt;Python, a high-level portable multi-paradigm interpreted programming
language is becoming increasingly popular with the scientific and HPC
communities due to ease of use, large collection of modules,
adaptability, and strong support from vendors and community alike. This
tutorial provides an introduction to Python focused on HPC and
scientific computing. Throughout, we provide concrete examples, hands-on
examples, and links to additional sources of information. The result
will be a clear sense of possibilities and best practices using Python
in HPC environments. We will cover several key concepts: language
basics, NumPy and SciPy, parallel programming, performance issues,
integrating C and Fortran, basic visualization, large production codes,
and finding resources. While it is impossible to address all libraries
and application domains, at the end participants should be able to write
a simple application making use of parallel programming techniques,
visualize the output, and know how to confidently proceed with future
projects with Python.&lt;/p&gt;
&lt;p&gt;ChiPy is a group of Chicago Python Programmers, l33t, and n00bs.
Meetings are held monthly at various locations around Chicago. Also,
ChiPy is a proud sponsor of many Open Source and Educational efforts in
Chicago.&lt;/p&gt;
</summary><category term="chipy"></category><category term="numpy"></category><category term="scipy"></category></entry><entry><title>Python for Scientific and High Performance Computing (1 of 4)</title><link href="https://pyvideo.org/chipy/python-for-scientific-and-high-performance-compu2.html" rel="alternate"></link><published>2009-11-12T00:00:00+00:00</published><updated>2009-11-12T00:00:00+00:00</updated><author><name>Unknown</name></author><id>tag:pyvideo.org,2009-11-12:chipy/python-for-scientific-and-high-performance-compu2.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;This tutorial provides an introduction to Python focused on HPC and
scientific computing. Throughout, we provide concrete examples, hands-on
examples, and links to additional sources of information. The result
will be a clear sense of possibilities and best practices using Python
in HPC environments.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python, a high-level portable multi-paradigm interpreted programming
language is becoming increasingly popular with the scientific and HPC
communities due to ease of use, large collection of modules,
adaptability, and strong support from vendors and community alike. This
tutorial provides an introduction to Python focused on HPC and
scientific computing. Throughout, we provide concrete examples, hands-on
examples, and links to additional sources of information. The result
will be a clear sense of possibilities and best practices using Python
in HPC environments. We will cover several key concepts: language
basics, NumPy and SciPy, parallel programming, performance issues,
integrating C and Fortran, basic visualization, large production codes,
and finding resources. While it is impossible to address all libraries
and application domains, at the end participants should be able to write
a simple application making use of parallel programming techniques,
visualize the output, and know how to confidently proceed with future
projects with Python.&lt;/p&gt;
</summary><category term="chipy"></category><category term="numpy"></category><category term="scipy"></category></entry><entry><title>Python for Scientific and High Performance Computing (4 of 4)</title><link href="https://pyvideo.org/chipy/python-for-scientific-and-high-performance-comput.html" rel="alternate"></link><published>2009-11-12T00:00:00+00:00</published><updated>2009-11-12T00:00:00+00:00</updated><author><name>Unknown</name></author><id>tag:pyvideo.org,2009-11-12:chipy/python-for-scientific-and-high-performance-comput.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python for Scientific and High Performance Computing (part 4 of 4)&lt;/p&gt;
&lt;p&gt;Python, a high-level portable multi-paradigm interpreted programming
language is becoming increasingly popular with the scientific and HPC
communities due to ease of use, large collection of modules,
adaptability, and strong support from vendors and community alike. This
tutorial provides an introduction to Python focused on HPC and
scientific computing. Throughout, we provide concrete examples, hands-on
examples, and links to additional sources of information. The result
will be a clear sense of possibilities and best practices using Python
in HPC environments. We will cover several key concepts: language
basics, NumPy and SciPy, parallel programming, performance issues,
integrating C and Fortran, basic visualization, large production codes,
and finding resources. While it is impossible to address all libraries
and application domains, at the end participants should be able to write
a simple application making use of parallel programming techniques,
visualize the output, and know how to confidently proceed with future
projects with Python.&lt;/p&gt;
&lt;p&gt;ChiPy is a group of Chicago Python Programmers, l33t, and n00bs.
Meetings are held monthly at various locations around Chicago. Also,
ChiPy is a proud sponsor of many Open Source and Educational efforts in
Chicago.&lt;/p&gt;
</summary><category term="chipy"></category><category term="numpy"></category><category term="scipy"></category></entry><entry><title>Building a Scientific Software Application with the Enthought Tool Suite</title><link href="https://pyvideo.org/europython-2011/building-a-scientific-software-application-with-t.html" rel="alternate"></link><published>2011-07-24T00:00:00+00:00</published><updated>2011-07-24T00:00:00+00:00</updated><author><name>Mark Dickinson</name></author><id>tag:pyvideo.org,2011-07-24:europython-2011/building-a-scientific-software-application-with-t.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Mark Dickinson - 24 June 2011 in &amp;quot;Training Pizza
Margherita &amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The Enthought Tool Suite (ETS) is a collection of Python-based open
source components that form a foundation for nearly every application
that we deliver to our customers. In this talk I'll demonstrate how to
use ETS to rapidly develop an example scientific software application.
We'll concentrate particularly on introducing Traits, Traits UI, and the
Chaco and Mayavi visualisation tools.&lt;/p&gt;
&lt;p&gt;Prerequisites: some previous experience of working with Python and NumPy
/ SciPy is recommended.&lt;/p&gt;
</summary><category term="enthought"></category><category term="numpy"></category><category term="scientific"></category><category term="scipy"></category><category term="traits"></category></entry><entry><title>Python(x,y): diving into scientific Python</title><link href="https://pyvideo.org/europython-2011/pythonxy-diving-into-scientific-python.html" rel="alternate"></link><published>2011-07-13T00:00:00+00:00</published><updated>2011-07-13T00:00:00+00:00</updated><author><name>Vincent Noel</name></author><id>tag:pyvideo.org,2011-07-13:europython-2011/pythonxy-diving-into-scientific-python.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Vincent Noel - 22 June 2011 in &amp;quot;Training Pizza
Margherita &amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;This training session will introduce the Python scientific stack to
beginner or intermediate-level Python programmers. The basics of
scientific programming with Python will be presented:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;creation of arrays and structured arrays using numpy&lt;/li&gt;
&lt;li&gt;fast, loopless manipulation of numpy arrays through fancy indexing
and vectorized functions&lt;/li&gt;
&lt;li&gt;convenient saving/loading of array variables using numpy&lt;/li&gt;
&lt;li&gt;improved interactive use through ipython&lt;/li&gt;
&lt;li&gt;data analysis using various scipy modules (signal analysis, image
classification, etc)&lt;/li&gt;
&lt;li&gt;plotting large time series, histograms, scatterplots, images etc.
using matplotlib&lt;/li&gt;
&lt;li&gt;saving/loading large datasets in structured scientific formats such
as netCDF, HDF (depending on interest)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These concepts will be used in coding exercises, in the programming
environnement provided by the Python(x,y) distribution, which is freely
downloadable and includes recent versions of Python, numpy and
matplotlib. The Python(x,y) distribution runs on Windows, which will be
the OS of choice for this session. You should still be able to follow
the examples in other Python distributions, e.g. EPD.&lt;/p&gt;
&lt;p&gt;The entire talk (PDF), code samples and data files can be downloaded
from the following
&lt;a class="reference external" href="http://www.lmd.polytechnique.fr/~noel/EP2011/DivingIntoSci%20entificPython.zip"&gt;archive&lt;/a&gt;&lt;/p&gt;
</summary><category term="analysis"></category><category term="datasets"></category><category term="image"></category><category term="numpy"></category><category term="python,"></category><category term="scientific"></category><category term="scipy"></category></entry><entry><title>Brian Thorne - Computer Vision</title><link href="https://pyvideo.org/kiwi-pycon-2009/brian-thorne---computer-vision.html" rel="alternate"></link><published>2009-11-07T00:00:00+00:00</published><updated>2009-11-07T00:00:00+00:00</updated><author><name>Brian Thorne</name></author><id>tag:pyvideo.org,2009-11-07:kiwi-pycon-2009/brian-thorne---computer-vision.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Computer Vision&lt;/p&gt;
&lt;p&gt;Presented by Brian Thorne&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;An introduction to computer vision in Python, from the general concept
to its implementation with some current open-source libraries (opencv,
scipy, pygame).&lt;/p&gt;
&lt;p&gt;Outline&lt;/p&gt;
&lt;p&gt;The purpose of my presentation is an introduction to computer vision
(CV) and image processing in Python. I will aim to show what is possible
with current libraries, demonstrate their usability, explore their
limitations, and cover elements of best coding practice. Firstly, I will
briefly present the basics, such as video grabbing, image processing and
computer vision algorithms. I will illustrate my presentation with the
Python bindings to the opencv library and show different examples such
as displaying a video image, some filtering algorithms (dilation,
gaussian blur), and how to implement facial recognition. I will describe
after how related tasks can be achieved with other Python tools such as
scipy and pygame. I will show how these three libraries can be used in
conjunction to perform video capturing, image processing and user
interfacing. Finally, I will introduce my basic Python computer vision
framework, which is aimed at inexperienced users, and demonstrate it on
the XO laptop, the inexpensive low-powered sub-notebook distributed as
part of the One Laptop Per Child (OLPC) initiative.&lt;/p&gt;
&lt;p&gt;[VIDEO HAS ISSUES: Sound and video are poor. Slides are hard to read.]&lt;/p&gt;
</summary><category term="kiwipycon"></category><category term="kiwipycon2009"></category><category term="olpc"></category><category term="pygame"></category><category term="scipy"></category><category term="vision"></category></entry><entry><title>Optimal Aircraft Engine Tuner Selection in Python</title><link href="https://pyvideo.org/pycon-us-2011/pycon-2011--optimal-aircraft-engine-tuner-selecti.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Jeffrey Armstrong</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--optimal-aircraft-engine-tuner-selecti.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Optimal Aircraft Engine Tuner Selection in Python&lt;/p&gt;
&lt;p&gt;Presented by Jeffrey Armstrong&lt;/p&gt;
&lt;p&gt;A numerical algorithm for designing on-board aircraft engine diagnostics
has been implemented in Python. Employing the optimization techniques
within SciPy, the code performs a search for an optimal vector of
parameters for estimating engine variables, including exhaust
temperatures and thrust. The algorithm exploits the numerical strengths
of Python and SciPy for speed and interoperability.&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;An emerging field of aircraft engine diagnostics is the inclusion of
on-board engine performance tracking algorithms. These algorithms
utilize data provided by a limited number of engine sensors to determine
the current engine performance, which tends to degrade over time.
However, estimating engine performance instantaneously is problematic
due to the limited number of sensors normally available on a commercial
aircraft engine.&lt;/p&gt;
&lt;p&gt;One common practice is to estimate and track engine performance in
software using a Kalman filter, a mathematical construct for tuning a
numerical model to better track actual measurements (1). A new technique
has been devised to optimize the design of this filter in aircraft
engine applications (2). An optimization procedure to aid in the design
of the filter has been implemented in Python and exercised against the
significant number of minimization and optimization strategies available
in SciPy. The talk focuses on the design of this optimization procedure
in Python. The object-oriented nature of Python offers benefits over
alternative numerical languages; speed, availability, and
maintainability played central roles in the selection of Python as the
implementation language. The availability of the multiprocessing module
allowed for full utilization of modern multi-core CPUs, in contrast with
often limited commercial numerical computing packages, further improving
computational speed.&lt;/p&gt;
&lt;p&gt;Some difficulties were encountered during this design exercise.
Discussion of these obstacles and their eventual solution is presented.
Specifically, iterative solvers for the discrete algebraic Riccati
equation and the discrete Lyapunov equation had to be authored in Python
(3,4). Additional framework for working with discrete state-space
control systems was created, exploiting the object-oriented features of
the language (5).&lt;/p&gt;
&lt;p&gt;The Python implementation was able to verify the solution of the
optimization problem. Comparison with an alternative, reference MATLAB
implementation will be presented briefly. The results of this research
is planned to be presented at the American Society for Mechanical
Engineers Turbo Expo 2011 Conference in June, 2011 (6). The algorithm
design in Python is meant to showcase the ability to perform controls
engineering tasks in the Python language efficiently.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;“Kalman Filter,” Wikipedia:
&lt;a class="reference external" href="ht%20tp://en.wikipedia.org/wiki/Kalman_filter"&gt;http://en.wikipedia.org/wiki/Kalman_filter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Simon, D. L. and Garg, S., “Optimal Tuner Selection for Kalman
Filter-Based Aircraft Engine Performance Estimation”. Journal of
Engineering for Gas Turbines and Power. March 2010, Vol. 132.&lt;/li&gt;
&lt;li&gt;“Algebraic Riccati Equation,” Wikipedia:
&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Algebraic_Riccati_equatio%20n"&gt;http://en.wikipedia.org/wiki/Alge
braic_Riccati_equation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;“Lyapunov Equation,” Wikipedia:
&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Lyapunov_equation"&gt;http://en.wikipedia.org/wiki/Lyapunov_equa
tion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;“State Space,” Wikipedia: &lt;a class="reference external" href="http://en.wikipedia.org/wiki/State-space"&gt;http://en.wikipedia.org/wiki/State-
space&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Simon, D. L., Armstrong, J. B., &amp;quot;Application of an Optimal Tuner
Selection Approach for On-Board Self-Tuning Engine Models,&amp;quot;
Proceedings of the ASME Turbo Expo 2011, GT2011-46408, 2011 (To Be
Published).&lt;/li&gt;
&lt;/ol&gt;
</summary><category term="aircraftenginetuning"></category><category term="casestudy"></category><category term="pycon"></category><category term="pycon2011"></category><category term="scipy"></category></entry><entry><title>Swarming the Web: Evolving the Perfect Config File</title><link href="https://pyvideo.org/pycon-us-2011/pycon-2011--swarming-the-web--evolving-the-perfec.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Kurt Grandis</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--swarming-the-web--evolving-the-perfec.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Swarming the Web: Evolving the Perfect Config File&lt;/p&gt;
&lt;p&gt;Presented by Kurt Grandis&lt;/p&gt;
&lt;p&gt;Deployed web applications are typically run on top of stacks of highly
configurable middleware. The number of tunable parameters and their
impact are rarely fully explored. Using SciPy and a set of common
Python-based web tools this session will present a new method of
automatically tuning a typical LAMP stack for optimal performance.&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;Deployed web applications typically run on top of stacks of configurable
technology (e.g. web servers, interface modules, software load
balancers, databases). Each of these components often has dozens of
tuneable parameters. How many times are those values typically tweaked
before a final set of tuned parameters are settled on? What criteria are
typically used to determine the optimal set?&lt;/p&gt;
&lt;p&gt;This session presents a new method of automatically tuning a common LAMP
stack for optimal performance. We explore a solution using some common
Python-based automated deployment and load testing tools and dive into
scientific computing with SciPy.&lt;/p&gt;
</summary><category term="lamp"></category><category term="pycon"></category><category term="pycon2011"></category><category term="scipy"></category><category term="tuning"></category><category term="webapps"></category></entry></feed>