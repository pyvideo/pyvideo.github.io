<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_jacob-rief.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2018-05-23T00:00:00+00:00</updated><entry><title>Representing Hierarchies in Relational Databases</title><link href="https://pyvideo.org/djangocon-europe-2018/representing-hierarchies-in-relational-databases.html" rel="alternate"></link><published>2018-05-23T00:00:00+00:00</published><updated>2018-05-23T00:00:00+00:00</updated><author><name>Jacob Rief</name></author><id>tag:pyvideo.org,2018-05-23:djangocon-europe-2018/representing-hierarchies-in-relational-databases.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In this talk, I’ll explain the fundamental problem representing deep hierarchies in relational databases. To address this problem, we can use a database design pattern, named Materialized Path Trees.&lt;/p&gt;
&lt;p&gt;Many data structures require a representation, where one parent node can have any arbitrary number of children. Inside relational databases, this typically is represented by a foreign key onto its own table. In Django’s ORM, we use &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;models.ForeignKey('self',&lt;/span&gt; &lt;span class="pre"&gt;...)&lt;/span&gt;&lt;/tt&gt;, to create this kind of recursive relationship.
The major problem with this kind of representation is, that it doesn’t scale for deep trees. Whenever we have to traverse the tree from a given starting node, our code has to perform one database query per hierarchy level.
To circumvent this, some database vendors implemented SQL dialects, to fetch a whole subtree with one query. Long time ago, Oracle for instance implemented 'CONNECT BY', which is proprietary and not part of the SQL standard. Nowadays, newer releases of most major database vendors implemented the 'WITH RECURSIVE' clause, which has been added to the SQL-99 standard. This allows us to build recursive queries.&lt;/p&gt;
&lt;p&gt;Fortunately there is a clever recipe to represent hierarchies in relational databases using standard SQL techniques, but without the mentioned scaling problem: Materialized Path Trees, discovered by Vadim Tropashko. Django’s ecosystem offers two libraries, which implement this design pattern: &lt;strong&gt;django-mptt&lt;/strong&gt; and &lt;strong&gt;django-treebeard&lt;/strong&gt;. I also would like to mention &lt;strong&gt;django-tree&lt;/strong&gt;, which only works on Postgres, using their SQL extension mentioned before.
In this talk I’ll explain the design patterns for Materialized Path Trees. Furthermore I’ll show the pros and cons of both libraries.&lt;/p&gt;
&lt;p&gt;Jacob Rief&lt;/p&gt;
</summary></entry><entry><title>Django-CMS Cascade plugin system</title><link href="https://pyvideo.org/pyconweb-2017/django-cms-cascade-plugin-system.html" rel="alternate"></link><published>2017-05-27T00:00:00+00:00</published><updated>2017-05-27T00:00:00+00:00</updated><author><name>Jacob Rief</name></author><id>tag:pyvideo.org,2017-05-27:pyconweb-2017/django-cms-cascade-plugin-system.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Django-CMS-Cascade, is a feature rich plugin system for Django-CMS, which is easy to extend and without adding new database models.
In this presentation I will show how to integrate this plugin system into a running Django-CMS installation and show how one can quickly create impressive websites.Then I will show how one can create his own plugins with a few lines of Python and HTML code. Furthermore I will show how to extend all plugins with common functionality, such as shared attributes, inline styles and classes, private rendering templates and content versioning.&lt;/p&gt;
</summary><category term="django-cms-cascade"></category></entry><entry><title>Lightning talks - Monday</title><link href="https://pyvideo.org/djangocon-europe-2017/lightning-talks-monday.html" rel="alternate"></link><published>2017-04-03T00:00:00+00:00</published><updated>2017-04-03T00:00:00+00:00</updated><author><name>Peter Bittner</name></author><id>tag:pyvideo.org,2017-04-03:djangocon-europe-2017/lightning-talks-monday.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Lightning talks covering painless.cloud &amp;amp; SCSS&lt;/p&gt;
</summary><category term="lightning talks"></category></entry><entry><title>Make AngularJS play nice together with Django</title><link href="https://pyvideo.org/djangocon-europe-2014/make-angularjs-play-nice-together-with-django.html" rel="alternate"></link><published>2014-05-15T00:00:00+00:00</published><updated>2014-05-15T00:00:00+00:00</updated><author><name>Jacob Rief</name></author><id>tag:pyvideo.org,2014-05-15:djangocon-europe-2014/make-angularjs-play-nice-together-with-django.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Django intentionally has been designed as a pure server side framework,
thus being agnostic about client side programming, except for the Django
admin interface, which uses jQuery. Letting developers choose their
preferred client side framework has been a wise decision by Django
community. However, in most cases the de-facto standard, hence jQuery,
is used. In the past years, other Javascript frameworks have emerged,
namely Knockout, EmberJS, Backbone and AngularJS. They all attempt to
circumvent to shortcomings of jQuery. Since Django developers are
familiar with the concept of Model-View-Control, they might feel even
more comfortable with one of these frameworks, rather than with jQuery.&lt;/p&gt;
&lt;p&gt;In my proposed talk, I would like to give a short introduction into
AngularJS’s two-way data-binding, which can dramatically reduce
boilerplate code, otherwise required when using jQuery. Furthermore,
this talk will handle the following topics: - How to render model-bound
forms for AngularJS, using mixin classes to be added to the built in
Django form. - How Django’s form validation can be used to pre-validate
the form data on the client, using the AngularJS Model controller, but
without duplicating code. - How to securely call Django view’s methods
from inside an AngularJS controller, with a behaviour similar to remote
procedure calls. - How to use dependency injection to separate concern
for external data, either created by Django for production use, or by a
mocking class when writing unit tests for browsers code. - Three-way
data-binding build on top of AngularJS’s two-way data- binding using
websockets for bidirectional synchronization of the browsers view model
with server side data buckets.&lt;/p&gt;
&lt;p&gt;In-depth documentation on the topics of the proposed talk can be found
here: &lt;a class="reference external" href="http://django-angular.readthedocs.org/en/latest/"&gt;http://django-angular.readthedocs.org/en/latest/&lt;/a&gt;
&lt;a class="reference external" href="http://django-websocket"&gt;http://django-websocket&lt;/a&gt;- redis.readthedocs.org/en/latest/&lt;/p&gt;
</summary></entry><entry><title>djangoSHOP is back</title><link href="https://pyvideo.org/pycon-de-2016/djangoshop-is-back.html" rel="alternate"></link><published>2016-10-30T00:00:00+00:00</published><updated>2016-10-30T00:00:00+00:00</updated><author><name>Jacob Rief</name></author><id>tag:pyvideo.org,2016-10-30:pycon-de-2016/djangoshop-is-back.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In 2010 Divio, the company behind djangoCMS started to develop djangoSHOP. Now after two years of silence, a new version of djangoSHOP is back, offering a REST API and a Finite State Machine for programmable workflows. Nevertheless djangoSHOP aims to be a minimalistic, but feature complete e-commerce framework, applying modern concepts such as Atomic Web Design as propagated by Brad Frost. This shifts page centric development with Models, Views and Templates to component based development using Models, Serializers and Atoms or Molecules.&lt;/p&gt;
</summary></entry><entry><title>Django SHOP è ritornato</title><link href="https://pyvideo.org/pycon-italia-2016/django-shop-e-ritornato.html" rel="alternate"></link><published>2016-06-20T00:00:00+00:00</published><updated>2016-06-20T00:00:00+00:00</updated><author><name>Jacob Rief</name></author><id>tag:pyvideo.org,2016-06-20:pycon-italia-2016/django-shop-e-ritornato.html</id><summary type="html"></summary></entry></feed>