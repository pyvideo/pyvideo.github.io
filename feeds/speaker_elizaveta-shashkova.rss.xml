<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org - Elizaveta Shashkova</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Thu, 23 Jul 2020 00:00:00 +0000</lastBuildDate><item><title>Monkey-patching: a magic trick or a powerful tool?</title><link>https://pyvideo.org/europython-2016/monkey-patching-a-magic-trick-or-a-powerful-tool.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Elizaveta Shashkova - Monkey-patching: a magic trick or a powerful tool?
[EuroPython 2016]
[22 July 2016]
[Bilbao, Euskadi, Spain]
(&lt;a class="reference external" href="https://ep2016.europython.eu//conference/talks/monkey-patching-a-magic-trick-or-a-powerful-tool"&gt;https://ep2016.europython.eu//conference/talks/monkey-patching-a-magic-trick-or-a-powerful-tool&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Monkey-patching is a dynamic modification of a class or a module at runtime.&lt;/p&gt;
&lt;p&gt;The Python gives developers a great opportunity to use monkey-patching
almost everywhere. But should developers do it? Is it a magic trick or
a powerful tool? In this talk we will try to give the answers to these
questions and try to figure out pros and cons of using monkey-
patching.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;First of all we will learn what is monkey-patching in Python and
consider some basic examples of using it.&lt;/p&gt;
&lt;p&gt;Of course, monkey-patching may cause some problems in the code. We
will consider bad ways to use it and try to learn different types of
problems monkey-patching may lead to.&lt;/p&gt;
&lt;p&gt;Despite of some bugs that may appear in a patched program, monkey-
patching is used in a real life rather often. There are some reasons
and motives to do it. We will consider the examples of using monkey-
patching in real projects like &lt;cite&gt;gevent&lt;/cite&gt;, in some other libraries and
in testing. Also we will learn some monkey-patch tricks that helps to
solve real-life problems in the Python debugger which is a part of the
PyCharm and the PyDev.&lt;/p&gt;
&lt;p&gt;After that we will compare using of monkey-patching in Python to using
it in an another dynamic language Ruby. Are there any differences
between them? Is our reasoning correct for Ruby?&lt;/p&gt;
&lt;p&gt;Finally we will conclude all our thoughts and examples and try to give
the answer to the question from title.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Elizaveta Shashkova</dc:creator><pubDate>Fri, 05 Aug 2016 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2016-08-05:/europython-2016/monkey-patching-a-magic-trick-or-a-powerful-tool.html</guid><category>EuroPython 2016</category></item><item><title>Debugging in Python 3.6: Better, Faster, Stronger</title><link>https://pyvideo.org/europython-2017/debugging-in-python-36-better-faster-stronger.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python 3.6 was released in December of 2016 and it has a lot of new
cool features. Some of them are quite easy for using: a developer can
read, for example, about f-strings and they can start using them in
their programs as soon as possible. But sometimes features are not so
evident, and a new frame evaluation API is one of them.&lt;/p&gt;
&lt;p&gt;The new frame evaluation API was introduced to CPython in PEP 523 and
it allows to specify a per-interpreter function pointer to handle the
evaluation of frames. It might not be evident how to use this new
feature in everyday life, but it’s quite easy to understand how to
build a fast debugger based on it.&lt;/p&gt;
&lt;p&gt;In this talk we are going to explain how standard way of debugging in
Python works and how a new frame evaluation API may be useful for
creating the fast debugger. Also we will consider why such fast
debugging was not possible in the previous versions of Python. If
someone hasn’t made a final decision to move to Python 3.6 this talk
will provide some new reasons to do it.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Elizaveta Shashkova</dc:creator><pubDate>Mon, 10 Jul 2017 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2017-07-10:/europython-2017/debugging-in-python-36-better-faster-stronger.html</guid><category>EuroPython 2017</category></item><item><title>Visual debugger for Jupyter Notebooks: Myth or Reality?</title><link>https://pyvideo.org/europython-2019/visual-debugger-for-jupyter-notebooks-myth-or-reality.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Many Python developers like Jupyter Notebooks for their flexibility:
they are very useful for interactive prototyping, scientific
experiments, visualizations and many other tasks. There are different
development tools which make working with Jupyter Notebooks easier and
smoother, but all of them lack very important feature: visual debugger.
Since Jupyter Kernel is a usual Python process, it looks reasonably to
use one of existing Python debuggers with it. But is it really possible?&lt;/p&gt;
&lt;p&gt;In this talk we’ll try to understand how Python debugger should be
changed to work with Jupyter cells and how these changes are already
implemented in the PyCharm IDE. After that we’ll look into the whole
Jupyter architecture and try to understand which bottlenecks in it
prevent creation of universal Jupyter debugger at the moment.&lt;/p&gt;
&lt;p&gt;This talk requires a basic knowledge of Jupyter Notebooks and
understanding of Python functions and objects. It will be interesting
for people who want to learn internals of the tools they use every day.
Also it might be an inspiration for people who want to implement a
visual debugger in their favourite IDE.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Elizaveta Shashkova</dc:creator><pubDate>Wed, 10 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-07-10:/europython-2019/visual-debugger-for-jupyter-notebooks-myth-or-reality.html</guid><category>EuroPython 2019</category><category>Debugging</category><category>Jupyter</category><category>Python general</category><category>Tooling</category></item><item><title>The Hidden Power of the Python Runtime</title><link>https://pyvideo.org/europython-2020/the-hidden-power-of-the-python-runtime.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Retrieve useful information from Python runtime and build development tools based on it&lt;/p&gt;
&lt;p&gt;Many people like Python for its simplicity and beauty. But every statement in Python, even the simple one, produces a lot of events during the program execution. These events are usually hidden from a user, so it helps developers to skip low-level implementation details and focus on bigger things.&lt;/p&gt;
&lt;p&gt;At the same time many parts of this hidden information are very useful and interesting to examine. The good news is that Python Runtime allows to retrieve it really simply, so there is no need to configure additional libraries or pass additional parameters to interpreter. Everybody can do it right inside their Python code.&lt;/p&gt;
&lt;p&gt;During this talk we will learn how Python allows to inspect current program state during the execution. We will learn about Python variables, frame objects and useful information they store. After that we will discuss several powerful tools which are based on the runtime information and which can be helpful for any Python programmer in their everyday life.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Elizaveta Shashkova</dc:creator><pubDate>Thu, 23 Jul 2020 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2020-07-23:/europython-2020/the-hidden-power-of-the-python-runtime.html</guid><category>EuroPython 2020</category><category>europython</category><category>europython-2020</category><category>europython-online</category><category>Debugging</category><category>Development</category><category>Python general</category><category>Tooling</category></item><item><title>Debugging in Python 3.6: Better, Faster, Stronger</title><link>https://pyvideo.org/pycon-us-2017/debugging-in-python-36-better-faster-stronger.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Python 3.6 was released in December of 2016 and it has a lot of new
cool features. Some of them are quite easy for using: a developer can
read, for example, about f-strings and they can start using them in
their programs as soon as possible. But sometimes features are not so
evident, and a new frame evaluation API is one of them.&lt;/div&gt;
&lt;div class="line"&gt;The new frame evaluation API was introduced to CPython in PEP 523 and
it allows to specify a per-interpreter function pointer to handle the
evaluation of frames. It might not be evident how to use this new
feature in everyday life, but it’s quite easy to understand how to
build a fast debugger based on it.&lt;/div&gt;
&lt;div class="line"&gt;In this talk we are going to explain how standard way of debugging in
Python works and how a new frame evaluation API may be useful for
creating the fast debugger. Also we will consider why such fast
debugging was not possible in the previous versions of Python. If
someone hasn’t made a final decision to move to Python 3.6 this talk
will provide some new reasons to do it.&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Elizaveta Shashkova</dc:creator><pubDate>Sat, 20 May 2017 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2017-05-20:/pycon-us-2017/debugging-in-python-36-better-faster-stronger.html</guid><category>PyCon US 2017</category></item><item><title>The Hidden Power of the Python Runtime</title><link>https://pyvideo.org/pycon-us-2020/the-hidden-power-of-the-python-runtime.html</link><description></description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Elizaveta Shashkova</dc:creator><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2020-04-17:/pycon-us-2020/the-hidden-power-of-the-python-runtime.html</guid><category>PyCon US 2020</category></item></channel></rss>