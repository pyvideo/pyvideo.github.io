<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/tag_gevent.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2013-10-15T00:00:00+00:00</updated><entry><title>Fast, documented and reliable JSON based webservices with Python</title><link href="https://pyvideo.org/europython-2013/fast-documented-and-reliable-json-based-webservices-with-python.html" rel="alternate"></link><published>2013-07-05T00:00:00+00:00</published><updated>2013-07-05T00:00:00+00:00</updated><author><name>Alessandro Molina</name></author><id>tag:pyvideo.org,2013-07-05:europython-2013/fast-documented-and-reliable-json-based-webservices-with-python.html</id><summary type="html"></summary><category term="web"></category><category term="turbogears"></category><category term="mongodb"></category><category term="json"></category><category term="api"></category><category term="gevent"></category></entry><entry><title>Server side story</title><link href="https://pyvideo.org/europython-2013/server-side-story.html" rel="alternate"></link><published>2013-07-04T00:00:00+00:00</published><updated>2013-07-04T00:00:00+00:00</updated><author><name>Simone Deponti</name></author><id>tag:pyvideo.org,2013-07-04:europython-2013/server-side-story.html</id><summary type="html"></summary><category term="HTTP"></category><category term="networking"></category><category term="deploy"></category><category term="mobile"></category><category term="javascript"></category><category term="desktop"></category><category term="sysadmin"></category><category term="json"></category><category term="gevent"></category><category term="design"></category><category term="software-engineering"></category><category term="best-practices"></category><category term="application-design"></category><category term="websockets"></category><category term="architecture"></category></entry><entry><title>Greenlet-based concurrency</title><link href="https://pyvideo.org/europython-2013/greenlet-based-concurrency.html" rel="alternate"></link><published>2013-07-03T00:00:00+00:00</published><updated>2013-07-03T00:00:00+00:00</updated><author><name>Goran Peretin</name></author><id>tag:pyvideo.org,2013-07-03:europython-2013/greenlet-based-concurrency.html</id><summary type="html"></summary><category term="parallelization"></category><category term="optimization"></category><category term="gevent"></category><category term="greenlet"></category><category term="concurrency"></category><category term="performance"></category></entry><entry><title>How DISQUS does "it" when "it" isn't Django</title><link href="https://pyvideo.org/europython-2013/how-disqus-does-it-when-it-isnt-django.html" rel="alternate"></link><published>2013-07-02T00:00:00+00:00</published><updated>2013-07-02T00:00:00+00:00</updated><author><name>Adam Hitchcock</name></author><id>tag:pyvideo.org,2013-07-02:europython-2013/how-disqus-does-it-when-it-isnt-django.html</id><summary type="html"></summary><category term="web"></category><category term="realtime"></category><category term="mongodb"></category><category term="zookeeper"></category><category term="scalability"></category><category term="django"></category><category term="celery"></category><category term="optimization"></category><category term="gevent"></category><category term="concurrency"></category><category term="performance"></category></entry><entry><title>gevent</title><link href="https://pyvideo.org/pycon-japan-2012/gevent.html" rel="alternate"></link><published>2012-09-16T00:00:00+00:00</published><updated>2012-09-16T00:00:00+00:00</updated><author><name>稲田 直哉</name></author><id>tag:pyvideo.org,2012-09-16:pycon-japan-2012/gevent.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;gevent はコルーチンベースのネットワークプログラミングライブラリです。 主に大量の同時接続を扱う必要がある場面において力を発揮し、 効率の良いプログラムを簡単に書くことができます。
本セッションでは、 gevent の仕組み、他の仕組みに比べた gevent の長所、 そして gevent によるプログラミングについて解説します。&lt;/p&gt;
</summary><category term="gevent"></category></entry><entry><title>PyGotham 2011: Real-time Web: Gevent and Socket.io</title><link href="https://pyvideo.org/pygotham-2011/pygotham-2011-real-time-web-gevent-and-socketi.html" rel="alternate"></link><published>2011-09-16T00:00:00+00:00</published><updated>2011-09-16T00:00:00+00:00</updated><author><name>Richard D. Copeland, Jr.</name></author><id>tag:pyvideo.org,2011-09-16:pygotham-2011/pygotham-2011-real-time-web-gevent-and-socketi.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;There has been a lot of talk lately about how Node.js enables the
real-time web, but did you know you can do the same thing with Python?
This talk will show you how to use Gevent, ZeroMQ, and Socket.io to
build portable Python- powered real-time web applications.&lt;/p&gt;
</summary><category term="gevent"></category><category term="pygotham"></category><category term="pygotham2011"></category><category term="real-time"></category><category term="socket.io"></category><category term="web"></category><category term="zeromq"></category></entry><entry><title>Django on Gevent</title><link href="https://pyvideo.org/djangocon-us-2012/django-on-gevent.html" rel="alternate"></link><published>2012-09-04T00:00:00+00:00</published><updated>2012-09-04T00:00:00+00:00</updated><author><name>Cody Soyland</name></author><id>tag:pyvideo.org,2012-09-04:djangocon-us-2012/django-on-gevent.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;This is an introduction to using the Gevent networking library to
empower your Django application with realtime features and
resource-efficient cooperative concurrency. Django's synchronous APIs
make it impractical to use in a callback-based networking library, but
fast single-threaded concurrency is still possible using the
mind-blowing capabilities of coroutines.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Gevent is an ultra-fast networking library built on top of the greenlet
module. Greenlets are the ideal solution to making Django's synchronous
API calls possible in a cooperative concurrency environment.&lt;/p&gt;
&lt;p&gt;I'll begin with an overview of the models of network programming,
including threading, callbacks, and coroutines. I'll explain how
greenlets (coroutines) work in harmony to provide simple blocking
network APIs while not blocking execution of the entire thread. I'll
show how easy it is to integrate other network services into your app.&lt;/p&gt;
&lt;p&gt;As an exploration into using realtime features in Django, I'll
demonstrate a simple realtime collaboration app that uses websockets for
communication. I will show how to integrate ZeroMQ to allow the app to
scale beyond a single server. I will also show how to attach to and
monitor your web app using gevent.backdoor.&lt;/p&gt;
</summary><category term="django"></category><category term="gevent"></category></entry><entry><title>Introduction to Gevent</title><link href="https://pyvideo.org/europython-2011/introduction-to-gevent.html" rel="alternate"></link><published>2011-07-21T00:00:00+00:00</published><updated>2011-07-21T00:00:00+00:00</updated><author><name>Denis Bilenko</name></author><id>tag:pyvideo.org,2011-07-21:europython-2011/introduction-to-gevent.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Denis Bilenko - 20 June 2011 in &amp;quot;Track Spaghetti&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;&lt;a class="reference external" href="http://gevent.org"&gt;Gevent&lt;/a&gt; is a coroutine-based library that enables
you to write highly-concurrent network and web applications. learn in
detail what Gevent is, what it does and how it does it.&lt;/p&gt;
&lt;p&gt;I will introduce a coroutine-based approach to network programming,
explain it benefits and pitfalls. We will walk through the Gevent API,
including the most recent additions, and understand how it is
implemented. I will make a quick overview of the most interesting 3rd
party add-on and applications after that.&lt;/p&gt;
</summary><category term="gevent"></category><category term="network"></category><category term="web"></category></entry><entry><title>Node Schmode: Pythonic Real-Time Web</title><link href="https://pyvideo.org/pycon-au-2012/node-schmode-pythonic-real-time-web.html" rel="alternate"></link><published>2012-08-22T00:00:00+00:00</published><updated>2012-08-22T00:00:00+00:00</updated><author><name>Dylan Jay</name></author><id>tag:pyvideo.org,2012-08-22:pycon-au-2012/node-schmode-pythonic-real-time-web.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Using gevent, pyramid and socket-io for a micro framework approach to
creating real-time web apps without the braces. Why is gevent so cool
and how it can let you write fast scalable apps with asynchronous IO
without twisting your mind.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Using gevent, pyramid and socket-io for a micro framework approach to
creating real-time web apps without the braces. Why is gevent so cool
and how it can let you write fast scalable apps with asynchronous IO
without twisting your mind.&lt;/p&gt;
</summary><category term="gevent"></category><category term="pyramid"></category><category term="socket-io"></category></entry><entry><title>Echtzeit Browsergames</title><link href="https://pyvideo.org/pycon-de-2012/echtzeit-browsergames.html" rel="alternate"></link><published>2012-10-30T00:00:00+00:00</published><updated>2012-10-30T00:00:00+00:00</updated><author><name>Michael P. Jung</name></author><id>tag:pyvideo.org,2012-10-30:pycon-de-2012/echtzeit-browsergames.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Mit gevent und browserseitigem JavaScript können Mehrspieler
Browsergames entwickelt werden, die Spielerinteraktionen in Echtzeit
zulassen. Dieser Vortrag versucht Lust auf das Echtzeit Web zu machen
und zeigt anhand eines konkreten Spieles (KODEX, &lt;a class="reference external" href="http://kodexgame.com/"&gt;http://kodexgame.com/&lt;/a&gt;)
Lösungen für Entwicklung, Hosting und Vertrieb auf.&lt;/p&gt;
&lt;p&gt;Der Vortrag beleuchtet neben den Implikationen des Realtime Web wie
Caching, Scaling, Same-Origin-Policy und Cross-Origin-Resource-Sharing
auch Strategien zur horizontalen Skalierbarkeit, oder: Wie löst man das
&lt;a class="reference external" href="http://www.kegel.com/c10k.html"&gt;C10K&lt;/a&gt; Problem?&lt;/p&gt;
&lt;p&gt;Während NodeJS oft als &lt;em&gt;die&lt;/em&gt; Lösung für Echtzeitanwendungen angepriesen
wird, kommt hier auf der Serverseite gezielt Python mit gevent zum
Einsatz.&lt;/p&gt;
</summary><category term="django"></category><category term="echtzeit"></category><category term="game"></category><category term="gevent"></category><category term="javascript"></category><category term="python"></category><category term="rabbitmq"></category><category term="realtime"></category><category term="socketio"></category><category term="spiel"></category></entry><entry><title>Echtzeit Web-Apps mit Mushroom</title><link href="https://pyvideo.org/pycon-de-2013/echtzeit-web-apps-mit-mushroom.html" rel="alternate"></link><published>2013-10-15T00:00:00+00:00</published><updated>2013-10-15T00:00:00+00:00</updated><author><name>Michael P. Jung</name></author><id>tag:pyvideo.org,2013-10-15:pycon-de-2013/echtzeit-web-apps-mit-mushroom.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;&lt;a class="reference external" href="https://bitbucket.org/terreon/mushroom"&gt;Mushroom&lt;/a&gt; ist ein einfach zu
verwendendes Echtzeit-Web-Messaging-Framework, welches neben
Browser-Push-Nachrichten auch Funktionen für die
Interprozesskommunikation zur Verfügung stellt.&lt;/p&gt;
&lt;p&gt;Dieser Vortrag versucht, Lust auf das Echtzeit-Web zu machen und
beantwortet grundlegende Fragen zu Themen wie Skalierbarkeit und
Deployment.&lt;/p&gt;
</summary><category term="echtzeit"></category><category term="gevent"></category><category term="http"></category><category term="ipc"></category><category term="javascript"></category><category term="long polling"></category><category term="messagin"></category><category term="mushroom"></category><category term="network"></category><category term="python"></category><category term="real-time"></category><category term="websocket"></category></entry><entry><title>An outsider's look at co-routines.</title><link href="https://pyvideo.org/pycon-us-2011/pycon-2011--an-outsider--39-s-look-at-co-routines.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Peter Portante</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--an-outsider--39-s-look-at-co-routines.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;An outsider's look at co-routines.&lt;/p&gt;
&lt;p&gt;Presented by Peter Portante&lt;/p&gt;
&lt;p&gt;Let's take an outsiders look at coroutines, the underlying concept used
by greenlets. First we'll define what they are conceptually, and show
some typical use cases. Then we'll take a look at a sampling of the
implementations out there to see what they are actually doing to
implement the concept. Finally, we'll show their pluses and minuses, and
highlight some features of packages that use them.&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;Talk outline:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Define what a coroutine is&lt;ul&gt;
&lt;li&gt;Coroutine state not known to operating system&lt;/li&gt;
&lt;li&gt;Difference between a thread or process&lt;/li&gt;
&lt;li&gt;What state is required for tracking&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Show how coroutines are used&lt;ul&gt;
&lt;li&gt;gevent example&lt;/li&gt;
&lt;li&gt;concurrence example&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Review two implementations&lt;ul&gt;
&lt;li&gt;Greenlets&lt;/li&gt;
&lt;li&gt;Python based co-routines using generators&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Advantages/Disadvantages&lt;/li&gt;
&lt;li&gt;Differentiating features of packages that use them&lt;ul&gt;
&lt;li&gt;Concurrence&lt;/li&gt;
&lt;li&gt;Gevent&lt;/li&gt;
&lt;li&gt;Eventlets&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="concurrence"></category><category term="coroutines"></category><category term="gevent"></category><category term="greenlets"></category><category term="pycon"></category><category term="pycon2011"></category></entry><entry><title>Using Coroutines to Create Efficient, High-Concurrency Web Applications</title><link href="https://pyvideo.org/pycon-us-2011/pycon-2011--using-coroutines-to-create-efficient-.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Matt Spitz</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--using-coroutines-to-create-efficient-.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Using Coroutines to Create Efficient, High-Concurrency Web Applications&lt;/p&gt;
&lt;p&gt;Presented by Matt Spitz&lt;/p&gt;
&lt;p&gt;Creating high-concurrency python web applications is inherently
difficult for a variety of reasons. In this talk, I'll discuss the
various iterations of application server paradigms we've used at meebo,
the advantages/disadvantages of each approach, and why we've settled on
a coroutine-based WSGI setup to handle our high-concurrency web
applications going forward.&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;There are a number of ways in which to create a web application in
python. Some examples include a straight-up CGI scripts that run anew
with each request, preforked Apache workers that each handle multiple
requests, and using an asynchronous web framework like Twisted.&lt;/p&gt;
&lt;p&gt;At meebo, we've settled on using gunicorn, a lightweight WSGI server,
which supports gevent, a coroutine-based network library for python.
Gevent monkeypatches python's system modules to make network requests
asynchronous using an event loop based on libevent. This trick allows
the developer to use a simple blocking CGI as a non-blocking web
application that can handle many concurrent requests.&lt;/p&gt;
&lt;p&gt;I'll discuss our iteration process through these approaches to building
web applications, why we ended up choosing gunicorn+gevent, the
challenges this new framework presents, and how we've dealt with them.&lt;/p&gt;
</summary><category term="coroutines"></category><category term="gevent"></category><category term="gunicorn"></category><category term="highconcurrency"></category><category term="libevent"></category><category term="pycon"></category><category term="pycon2011"></category><category term="wsgi"></category></entry></feed>