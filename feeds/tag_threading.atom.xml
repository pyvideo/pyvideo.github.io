<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/tag_threading.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2019-05-05T00:00:00+00:00</updated><entry><title>Sharing is Caring! - how to free the CPU from message passing hell - shared memory saved the day</title><link href="https://pyvideo.org/pycon-italia-2019/sharing-is-caring-how-to-free-the-cpu-from-message-passing-hell-shared-memory-saved-the-day.html" rel="alternate"></link><published>2019-05-05T00:00:00+00:00</published><updated>2019-05-05T00:00:00+00:00</updated><author><name>Andrei Neagu</name></author><id>tag:pyvideo.org,2019-05-05:pycon-italia-2019/sharing-is-caring-how-to-free-the-cpu-from-message-passing-hell-shared-memory-saved-the-day.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;When dealing with a real time application in which you are required to
process a lot of data from multiple sources in parallel, system
resources disappear quickly. Add some CPU intensive processing and you
are set to fail.&lt;/p&gt;
&lt;p&gt;This talk will illustrate a solution to solve a CPU bound problem with a
data stream of tens of megabytes. I will talk about how easy it is to
fail and how to obtain a working solution.&lt;/p&gt;
&lt;p&gt;The following arguments will be discussed:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;threading and its limitations&lt;/li&gt;
&lt;li&gt;multiprocessing and its limitations&lt;/li&gt;
&lt;li&gt;serialization&lt;/li&gt;
&lt;li&gt;shared memory&lt;/li&gt;
&lt;li&gt;a solution: multiprocessing + shared memory&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Code will be provided and shown during the talk.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Feedback form:&lt;/strong&gt; &lt;a class="reference external" href="https://python.it/feedback-1656"&gt;https://python.it/feedback-1656&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;in __on &lt;strong&gt;Sunday 5 May&lt;/strong&gt; at 11:45 &lt;a class="reference external" href="/en/sprints/schedule/pycon10/"&gt;**See
schedule**&lt;/a&gt;&lt;/p&gt;
</summary><category term="threading"></category><category term="SharedMemory"></category><category term="#Python"></category><category term="python3"></category><category term="multiprocessing"></category></entry><entry><title>Machine Learning con Python: previsione in real-time della richiesta di energia elettrica</title><link href="https://pyvideo.org/pycon-italia-2017/machine-learning-con-python-previsione-in-real-time-della-richiesta-di-energia-elettrica.html" rel="alternate"></link><published>2017-04-08T00:00:00+00:00</published><updated>2017-04-08T00:00:00+00:00</updated><author><name>Felice Tuosto</name></author><id>tag:pyvideo.org,2017-04-08:pycon-italia-2017/machine-learning-con-python-previsione-in-real-time-della-richiesta-di-energia-elettrica.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Nel talk si parlerà di come attraverso il linguaggio Python sia
possibile risolvere un problema reale e complesso relativamente alla
trasmissione di energia elettrica. Verrà spiegato il progetto
&lt;strong&gt;RealtimeLoadForecast&lt;/strong&gt; che è stato sviluppato per un importante TSO
(Transmission System Operator). Si tratta di sistema predittivo che
permette di fornire in tempo reale ogni 15 minuti ed entro 5 minuti, le
previsioni delle serie storiche dei consumi di energia elettrica
relativi a circa 500 nodi elettrici.&lt;/p&gt;
&lt;p&gt;Si parlerà dei passi che occorre seguire per ottenere da un semplice
prototipo, un sistema &lt;em&gt;ingegnerizzato&lt;/em&gt; che lavori in tempo reale e di
come sono state utilizzate le librerie di Python per l’acquisizione,
manipolazione e processamento dei dati elettrici ed ambientali.&lt;/p&gt;
&lt;p&gt;Saranno descritte alcune tecniche algoritmiche e di Machine Learning per
ottenere dei modelli predittivi capaci di fornire previsioni accurate ma
con tempi di risposta sfidanti.&lt;/p&gt;
&lt;p&gt;Verrà mostrato un &lt;em&gt;esempio concreto&lt;/em&gt; di implementazione di un algoritmo
predittivo basato sulla libreria Deep Learning &lt;strong&gt;Keras&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Per la comprensione del talk non sono necessari particolari requisiti se
non una conoscenza di base di programmazione in Python e di Machine
Learning.&lt;/p&gt;
</summary><category term="Forecasting"></category><category term="Genetic Algorithms"></category><category term="Keras"></category><category term="Data Mining"></category><category term="programming-paradigms"></category><category term="scikit-learn"></category><category term="bigdata"></category><category term="scalability"></category><category term="Deep-Learning"></category><category term="threading"></category><category term="realtime"></category><category term="Data-Scientist"></category><category term="database"></category><category term="machine-learning"></category><category term="mysql"></category><category term="signal-processing"></category><category term="LoadForecasting"></category><category term="cassandra"></category></entry><entry><title>Nebenläufige Programme mit Python</title><link href="https://pyvideo.org/pycon-de-2012/nebenlaufige-programme-mit-python.html" rel="alternate"></link><published>2012-10-30T00:00:00+00:00</published><updated>2012-10-30T00:00:00+00:00</updated><author><name>Stefan Schwarzer</name></author><id>tag:pyvideo.org,2012-10-30:pycon-de-2012/nebenlaufige-programme-mit-python.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;In diesem Vortrag soll es um Grundlagen nebenläufiger Programme gehen,
wie sie mit den Modulen threading und multiprocessing möglich sind.&lt;/p&gt;
&lt;p&gt;Zuerst wird erklärt, in welchen Fällen Nebenläufigkeit sinnvoll ist.
Danach wird auf die grundsätzlichen Probleme nebenläufiger Programme
eingegangen, insbesondere Änderungen an gemeinsam genutzten Ressourcen
(zum Beispiel Dateien oder auch &amp;quot;nur&amp;quot; Objekte im Speicher) durch mehrere
Threads oder Prozesse. Schließlich wird gezeigt, wie man solche
Ressourcen-Zugriffe durch Locks oder Queues entschärfen kann.&lt;/p&gt;
</summary><category term="deadlock"></category><category term="gil"></category><category term="multiprocessing"></category><category term="nebenläufigkeit"></category><category term="queue"></category><category term="threading"></category></entry></feed>