<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/event_pycon-russia-2015.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2015-09-19T00:00:00+00:00</updated><entry><title>Архитектура RESTful API на Pyramid — приемы проектирования</title><link href="https://pyvideo.org/pycon-russia-2015/arkhitektura-restful-api-na-pyramid-priemy-proektirovaniia.html" rel="alternate"></link><published>2015-09-19T00:00:00+00:00</published><updated>2015-09-19T00:00:00+00:00</updated><author><name>Dmitry Vakhrushev</name></author><id>tag:pyvideo.org,2015-09-19:pycon-russia-2015/arkhitektura-restful-api-na-pyramid-priemy-proektirovaniia.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Pyramid — чрезвычайно гибкий фреймворк, идеально подходящий тем разработчикам, которые точно знают, что им нужно. Обратная сторона его гибкости — отсутствие единственно верных, одобренных авторами, способов решения задач. В этом докладе
я поделюсь своими, проверенными временем, рецептами построения RESTful API на Pyramid. Будут затронуты вопросы:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;общей архитектуры Pyramid приложения;&lt;/li&gt;
&lt;li&gt;проектирования слоя бизнес-логики в виде иерархии ресурсов;&lt;/li&gt;
&lt;li&gt;использования траверсал-роутинга;&lt;/li&gt;
&lt;li&gt;обработки ошибок;&lt;/li&gt;
&lt;li&gt;управления правами доступа с использованием встроенного ACL;&lt;/li&gt;
&lt;li&gt;тестирования;&lt;/li&gt;
&lt;li&gt;интеграции с другими частями проекта.&lt;/li&gt;
&lt;/ul&gt;
</summary></entry><entry><title>Автоматизированные рефакторинги: AST, FST и все-все-все</title><link href="https://pyvideo.org/pycon-russia-2015/avtomatizirovannye-refaktoringi-ast-fst-i-vse-vse-vse.html" rel="alternate"></link><published>2015-09-19T00:00:00+00:00</published><updated>2015-09-19T00:00:00+00:00</updated><author><name>Kirill Borisov</name></author><id>tag:pyvideo.org,2015-09-19:pycon-russia-2015/avtomatizirovannye-refaktoringi-ast-fst-i-vse-vse-vse.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Одна из самых неприятных вещей в работе программиста — рутина. К сожалению, её не избежать — работы по поддержке существующего кода заставляют нас вносить одинаковые изменения в несколько файлов разом. По мере роста проекта эта задача вырастает до десятков правок в сотнях файлов, заставляя даже самого терпеливого программиста задуматься о смысли бытия. Но что делать? Автоматизируйте это! В этом докладе мы расскажем о разных способах работать с исходным кодом из Python, и почему это весело.
В докладе:
- Всякую рутинную работу можно превратить в интересную задачу по автоматизации рутины;
- В «батарейках» Python можно найти достаточно средств для самостоятельного анализа исходного кода;
- Топорный подход с «find/replace» часто не подходит из-за необходимости учитывать контекст каждой конкретной правки, равно как и сохранять по возможности оформление исходного файла;
- Регулярные выражения _не_ подходят для разбора исходного кода на сложных языках программирования;
- Любая достаточно продвинутая программа неотличима от магии.&lt;/p&gt;
</summary></entry><entry><title>Frontera: распределенный робот для обхода интернета в больших объемах</title><link href="https://pyvideo.org/pycon-russia-2015/frontera-raspredelennyi-robot-dlia-obkhoda-interneta-v-bolshikh-obemakh.html" rel="alternate"></link><published>2015-09-19T00:00:00+00:00</published><updated>2015-09-19T00:00:00+00:00</updated><author><name>Alexander Sibiryakov</name></author><id>tag:pyvideo.org,2015-09-19:pycon-russia-2015/frontera-raspredelennyi-robot-dlia-obkhoda-interneta-v-bolshikh-obemakh.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;В этом докладе я собираюсь представить новый open source фреймворк, разработанный в Scrapinghub. Frontera позволяет построить распределенного робота, для скачивания страниц из интернета в больших объемах в реальном времени. Также он может быть использован для построения сфокусированных роботов для выкачивания подмножества заранее известных веб-сайтов.&lt;/p&gt;
&lt;p&gt;Фреймворк предлагает:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;настраиваемое хранилище URL документов (RDBMS или Key Value),&lt;/li&gt;
&lt;li&gt;управление стратегиями обхода,&lt;/li&gt;
&lt;li&gt;абстракцию транспортного уровня,&lt;/li&gt;
&lt;li&gt;абстракцию модуля загрузки.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Помимо описания фреймворка и системных требований, я расскажу о нашем опыте скачивания испанского интернета с помощью Fronter'ы и представлю небольшую статистику.&lt;/p&gt;
</summary></entry><entry><title>Изоморфные приложения и Python</title><link href="https://pyvideo.org/pycon-russia-2015/izomorfnye-prilozheniia-i-python.html" rel="alternate"></link><published>2015-09-19T00:00:00+00:00</published><updated>2015-09-19T00:00:00+00:00</updated><author><name>Vitali Glibin</name></author><id>tag:pyvideo.org,2015-09-19:pycon-russia-2015/izomorfnye-prilozheniia-i-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Доклад будет посвящен проблеме единой шаблонизации на сервере и клиенте. Для чего это нужно? Например, вы делаете классный интернет-магазин на Django и хотите, чтобы в каталоге товаров при изменении каких-то параметров список товаров динамически фильтровался.&lt;/p&gt;
&lt;p&gt;Как было раньше?
Человек нажимает на фильтр, страница перезагружается с новым отфильтрованным списком товаров.
Это было очень медленно, и появился AJAX, разработчики стали при изменении фильтра загружать с сервера только кусочек html с отфильтрованными товарами.
Но и этого показалось мало, теперь с сервера мы получаем JSON, а на клиенте производим отрисовку нового списка товаров.&lt;/p&gt;
&lt;p&gt;Что получаем в итоге?
Есть некий шаблон, который отрисовывает список товаров на сервере, и есть шаблон, который делает это же на клиенте. Соответственно, разработчику часто необходимо поддерживать два шаблона, что может приводить к ошибкам при изменениях. Зато у клиента все быстро :)&lt;/p&gt;
&lt;p&gt;С появлением NodeJS разработчики стали задумываться о том, что теперь и на сервере, и на клиенте можно использовать единую шаблонизацию (единый код), который впоследствии назвали изоморфным. Именно поэтому разработчики часто выбирают NodeJS как основу для своих следующих проектов.&lt;/p&gt;
&lt;p&gt;Я хочу рассказать о том, как можно не отказываться от Python на сервере, при этом получив все преимущества изоморфных приложений: от небольших контентных до сложных сервисных сайтов, на основе своего собственного опыта.&lt;/p&gt;
&lt;p&gt;Плюс расскажу, для чего вообще в 2015 году нужна серверная шаблонизация и почему это важно.&lt;/p&gt;
</summary></entry><entry><title>Lightning Talks - 2</title><link href="https://pyvideo.org/pycon-russia-2015/lightning-talks-2.html" rel="alternate"></link><published>2015-09-19T00:00:00+00:00</published><updated>2015-09-19T00:00:00+00:00</updated><author><name>Various speakers</name></author><id>tag:pyvideo.org,2015-09-19:pycon-russia-2015/lightning-talks-2.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;PyCon RU 2015 second day lightning talks&lt;/p&gt;
</summary><category term="lightning talks"></category></entry><entry><title>Making of external DSL for Django ORM</title><link href="https://pyvideo.org/pycon-russia-2015/making-of-external-dsl-for-django-orm.html" rel="alternate"></link><published>2015-09-19T00:00:00+00:00</published><updated>2015-09-19T00:00:00+00:00</updated><author><name>Pavel Petlinsky</name></author><id>tag:pyvideo.org,2015-09-19:pycon-russia-2015/making-of-external-dsl-for-django-orm.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Рассказ пойдет о том, как мы реализовали в Django механизм такой же, как  Advanced Searching в JIRA, о внутреннем устройстве подобных решений (написание DSL, разбор грамматик и т.п.),
зачем и как мы их применяем на нашем проекте.&lt;/p&gt;
</summary></entry><entry><title>Numpy: векторизация</title><link href="https://pyvideo.org/pycon-russia-2015/numpy-vektorizatsiia.html" rel="alternate"></link><published>2015-09-19T00:00:00+00:00</published><updated>2015-09-19T00:00:00+00:00</updated><author><name>Ekaterina Tuzova</name></author><id>tag:pyvideo.org,2015-09-19:pycon-russia-2015/numpy-vektorizatsiia.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;NumPy — это базовая библиотека для научных вычислений на Python. На основе массивов NumPy построено множество библиотек для различных областей науки: машинного обучения, символьных вычислений, работы с биологическими данными. Однако, для того чтобы использовать NumPy эффективно, приходится слегка изменить свой подход к написанию кода.
Мы увидим, почему циклы в Python работают медленно и как использование векторных операций из Numpy улучшает производительность.&lt;/p&gt;
</summary></entry><entry><title>Оптимизация: на грани и за</title><link href="https://pyvideo.org/pycon-russia-2015/optimizatsiia-na-grani-i-za.html" rel="alternate"></link><published>2015-09-19T00:00:00+00:00</published><updated>2015-09-19T00:00:00+00:00</updated><author><name>Anton Patrushev</name></author><id>tag:pyvideo.org,2015-09-19:pycon-russia-2015/optimizatsiia-na-grani-i-za.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Нередко при разработке мы сталкиваемся с ситуациями, когда для увеличения производительности приложения надо делать крупные рефакторинги, менять архитектуру. Но что делать, если на это нет времени и производительность нужна прямо здесь и сейчас? Конечно, в первую очередь, нужно прибегнуть к традиционной медицине — профилировать и править узкие места. Но об этом уже сказано очень много. Я бы хотел рассказать о нескольких нетрадиционных техниках, которые мне однажды помогли побороть проблемы с производительностью:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Жизнь без GC: как и зачем?&lt;/li&gt;
&lt;li&gt;Выжмем ещё немного, не переписывая весь код: модификация AST при импорте;&lt;/li&gt;
&lt;li&gt;Декораторы и байткод: пару процентов почти за просто так.&lt;/li&gt;
&lt;/ul&gt;
</summary></entry><entry><title>Погружение в полнотекстовый поиск, используя Python</title><link href="https://pyvideo.org/pycon-russia-2015/pogruzhenie-v-polnotekstovyi-poisk-ispolzuia-python.html" rel="alternate"></link><published>2015-09-19T00:00:00+00:00</published><updated>2015-09-19T00:00:00+00:00</updated><author><name>Andrey Soldatenko</name></author><id>tag:pyvideo.org,2015-09-19:pycon-russia-2015/pogruzhenie-v-polnotekstovyi-poisk-ispolzuia-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;В наши дни мир тонет в текстовой информации. Все эти годы существующие технологии были сфокусированы на хранении и структурировании данных. Но что же делать, если нам необходимо принимать решение в режиме реального времени, используя эти данные?
Я с радостью поделюсь накопленным опытом разработки веб-приложений, использующих полнотекстовый поиск, которые написаны на Python с использованием Django-фреймворка, а также расскажу о результатах исследования разных поисковых движков и интеграции веб-приложений с haystack и elasticsearch.
Также поговорим о будущем полнотекстового поиска в контексте Django 1.9 и Python.&lt;/p&gt;
</summary></entry><entry><title>Python: управление памятью</title><link href="https://pyvideo.org/pycon-russia-2015/python-upravlenie-pamiatiu.html" rel="alternate"></link><published>2015-09-19T00:00:00+00:00</published><updated>2015-09-19T00:00:00+00:00</updated><author><name>Valentin Sinitsyn</name></author><id>tag:pyvideo.org,2015-09-19:pycon-russia-2015/python-upravlenie-pamiatiu.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Программистам на Python не нужно задумываться об управлении памятью — за них все делает интерпретатор. Как правило, это все, что необходимо знать об управлении памятью в Python.
Порой подобный «минимализм» приводит к неожиданным последствиям. Память начинает «течь», и понять, кто в этом виноват, оказывается непросто.
В этом докладе мы сделаем обзор подсистемы управления памятью в самой популярной реализации Python — CPython. Будут рассмотрены процедуры выделения памяти и сборки мусора, способы взаимодействия с ними из Python-кода, а также типовые ошибки, которые могут помешать их нормальной работе. Мы также продемонстрируем серию простых экспериментов, доказывающих, что работа с памятью в Python действительно происходит именно так, а не иначе.&lt;/p&gt;
</summary></entry><entry><title>Разработка одностраничных веб-приложений с использованием PonyORM и ReactJS</title><link href="https://pyvideo.org/pycon-russia-2015/razrabotka-odnostranichnykh-veb-prilozhenii-s-ispolzovaniem-ponyorm-i-reactjs.html" rel="alternate"></link><published>2015-09-19T00:00:00+00:00</published><updated>2015-09-19T00:00:00+00:00</updated><author><name>Alexander Kozlovsky</name></author><id>tag:pyvideo.org,2015-09-19:pycon-russia-2015/razrabotka-odnostranichnykh-veb-prilozhenii-s-ispolzovaniem-ponyorm-i-reactjs.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;ReactJS — современная популярная библиотека для построения Single Page Application. ReactJS позволяет создавать понятную и масштабируемую архитектуру веб-приложений, разбивать страницы на независимые компоненты, а также обеспечивает высокую скорость рендеринга. В то же время, ReactJS не описывает, каким образом должен выглядеть уровень «моделей» паттерна MVC и как должно быть организовано взаимодействие с бэкендом.&lt;/p&gt;
&lt;p&gt;PonyORM — это объектно-реляционный маппер на языке Python, который позволяет описать модели сущностей и удобно работать с ними на бэкенде. Теперь, в дополнение к PonyORM, появилась библиотека PonyJS, которая позволяет автоматически генерировать аналогичные модели на фронтенде и работать с ними из языка JavaScript. Теперь вы можете написать запрос с помощью PonyORM, автоматически сериализовать данные в JSON, передать их на фронтенд и работать с ними как с полноценными объектами, а затем передать изменения обратно и сохранить их в базе данных.&lt;/p&gt;
&lt;p&gt;В докладе будет рассказано, как можно создать одностраничное приложение на ReactJS, использующее объекты PonyORM/PonyJS в качестве моделей.&lt;/p&gt;
</summary></entry><entry><title>Секреты здорового питания: полезные рецепты с Celery</title><link href="https://pyvideo.org/pycon-russia-2015/sekrety-zdorovogo-pitaniia-poleznye-retsepty-s-celery.html" rel="alternate"></link><published>2015-09-19T00:00:00+00:00</published><updated>2015-09-19T00:00:00+00:00</updated><author><name>Alexander Shvets</name></author><id>tag:pyvideo.org,2015-09-19:pycon-russia-2015/sekrety-zdorovogo-pitaniia-poleznye-retsepty-s-celery.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;ul class="simple"&gt;
&lt;li&gt;Секретный состав сельдерея или неформальное введение в архитектуру Celery&lt;/li&gt;
&lt;li&gt;Подбираем ингредиенты на пробу. Как правильно логировать и отлаживать очередей&lt;/li&gt;
&lt;li&gt;Заботимся о долгом послевкусии. Как обеспечить стабильную работу очередей без простоя и потери задач&lt;/li&gt;
&lt;li&gt;Готовимся к кулинарному состязанию. Как избежать гонок при выполнении задач&lt;/li&gt;
&lt;li&gt;Несколько профессиональных рецептов шеф-повара по настройке Celery для больших проектов&lt;/li&gt;
&lt;/ul&gt;
</summary></entry><entry><title>«Вещи» на Python</title><link href="https://pyvideo.org/pycon-russia-2015/veshchi-na-python.html" rel="alternate"></link><published>2015-09-19T00:00:00+00:00</published><updated>2015-09-19T00:00:00+00:00</updated><author><name>Sergei Matveenko</name></author><id>tag:pyvideo.org,2015-09-19:pycon-russia-2015/veshchi-na-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Одним из факторов популярности Python является его применение в самых разных областях информационных технологий.&lt;/p&gt;
&lt;p&gt;«Internet of Things» («Интернет вещей») — одно из популярнейших и активно развивающихся сейчас направлений ИТ. Ожидаемо, в IoT тоже используется Python. Я немного расскажу о доступных способах снизить порог входа в IoT, расскажу о возможностях протокола «alljoyn», одного из самых популярных протоколов IoT и покажу на примере натоящего устройства, как с помощью DeviceHive D-Bus Framework можно создавать из любых управляемых устройств, которые у вас есть под рукой, устройства, работающие по протоколу «alljoyn».&lt;/p&gt;
</summary></entry><entry><title>50 оттенков кеширования: обзор актуальных батареек</title><link href="https://pyvideo.org/pycon-russia-2015/50-ottenkov-keshirovaniia-obzor-aktualnykh-batareek.html" rel="alternate"></link><published>2015-09-18T00:00:00+00:00</published><updated>2015-09-18T00:00:00+00:00</updated><author><name>Grigory Petrov</name></author><id>tag:pyvideo.org,2015-09-18:pycon-russia-2015/50-ottenkov-keshirovaniia-obzor-aktualnykh-batareek.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Кеширование так же многообразно, как и варианты использования python. Создавая веб приложение на Django или программируя логику онлайн игры в embedded python, разработчик использует множество стратегий для ускорения работы своего кода.
В обзорном докладе Григорий расскажет о современных подходах к кешированию в разных областях разработки на python, обрисует текущее состояние экосистемы и поделится интересными кейсами из практики.&lt;/p&gt;
</summary></entry><entry><title>Aiohttp</title><link href="https://pyvideo.org/pycon-russia-2015/aiohttp.html" rel="alternate"></link><published>2015-09-18T00:00:00+00:00</published><updated>2015-09-18T00:00:00+00:00</updated><author><name>Andrey Svetlov</name></author><id>tag:pyvideo.org,2015-09-18:pycon-russia-2015/aiohttp.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Aiohttp — самая популярная asyncio-совместимая библиотека на сегодняшний день.
В докладе мы рассмотрим:
* Web-клиент. Примитивный запрос. Использование авторизации и сессий.
* Web-сервер. Примитивный пример. Сложные routes.
* Web-sockets. Клиент и сервер. Обработка параллельных задач (asyncio.wait)
* Тестирование. Явный loop
* Базы данных. Redis, Postgres, Mongo.
* Сессии.
* Авторизация и права доступа.
* Debugtoolbar.
* PEP 492&lt;/p&gt;
&lt;p&gt;Доклад рассчитан на разработчиков, которые хотят попробовать asyncio подход, но не знают, с чего начать :)&lt;/p&gt;
</summary></entry><entry><title>Building a cutting-edge data processing environment on a budget</title><link href="https://pyvideo.org/pycon-russia-2015/building-a-cutting-edge-data-processing-environment-on-a-budget.html" rel="alternate"></link><published>2015-09-18T00:00:00+00:00</published><updated>2015-09-18T00:00:00+00:00</updated><author><name>Gael Varoquaux</name></author><id>tag:pyvideo.org,2015-09-18:pycon-russia-2015/building-a-cutting-edge-data-processing-environment-on-a-budget.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;As a penniless academic I wanted to do &amp;quot;big data&amp;quot; for science. Open
source, Python, and simple patterns were the way forward. Staying on top
of todays growing datasets is an arm race. Data analytics machinery
—clusters, NOSQL, visualization, Hadoop, machine learning, ...— can
spread a team's resources thin. Focusing on simple patterns, lightweight
technologies, and a good understanding of the applications gets us most
of the way for a fraction of the cost. These patterns appear underline
the design of Mayavi, for interactive 3D visualization, scikit-learn, for
easy machine learning, and joblib for out-of-core and parallel computing.&lt;/p&gt;
&lt;p&gt;I will present a personal perspective on ten years of scientific data
processing with Python. What are the emerging patterns in data
processing? How can modern data-mining ideas be used without a big
engineering team? What constraints and design trade-offs govern software
projects like scikit-learn, Mayavi, or joblib? How can we make the most
out of distributed hardware with simple framework-less code?&lt;/p&gt;
</summary></entry><entry><title>Чем аннотации типов могут быть полезны для вас</title><link href="https://pyvideo.org/pycon-russia-2015/chem-annotatsii-tipov-mogut-byt-polezny-dlia-vas.html" rel="alternate"></link><published>2015-09-18T00:00:00+00:00</published><updated>2015-09-18T00:00:00+00:00</updated><author><name>Andrey Vlasovskich</name></author><id>tag:pyvideo.org,2015-09-18:pycon-russia-2015/chem-annotatsii-tipov-mogut-byt-polezny-dlia-vas.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;PEP 484 вводит аннотации типов для Python 3. Аннотации типов могут улучшить читаемость кода как для людей, так и для инструментов анализа кода. Они делают код лучше и безопаснее. В этом докладе мы обсудим, почему это так.&lt;/p&gt;
&lt;p&gt;Мы кратко рассмотрим, что такое аннотации типов и перейдём к практическим примерам того, где они могут быть полезны и что они дают. Далее мы обсудим ряд полезных советов по написанию и использованию аннотаций. Мы увидим, что в большинстве случаев простых аннотаций типов на основе классов и встроенных коллекций вполне достаточно для публичных API наших библиотек. Мы также обсудим, что могут дать аннотации типов для сторонних библиотек.&lt;/p&gt;
</summary></entry><entry><title>Как сделать логирование приятным в быстро развивающемся проекте</title><link href="https://pyvideo.org/pycon-russia-2015/kak-sdelat-logirovanie-priiatnym-v-bystro-razvivaiushchemsia-proekte.html" rel="alternate"></link><published>2015-09-18T00:00:00+00:00</published><updated>2015-09-18T00:00:00+00:00</updated><author><name>Ivan Savin</name></author><id>tag:pyvideo.org,2015-09-18:pycon-russia-2015/kak-sdelat-logirovanie-priiatnym-v-bystro-razvivaiushchemsia-proekte.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Часто логированию уделяется немного внимания и по мере развития приложения править систему логирования становится сложнее. В итоге логи уже не так информативны, чтобы легко понять состояние программы в нужный момент в прошлом, и не так читабельны, чтобы сделать это быстро.&lt;/p&gt;
&lt;p&gt;В докладе будут освещены следующие вопросы:
- Каких ошибок можно избежать при проектировании логирования: способы конфигурации, антипаттерны;
- Как не переписывать все вызовы записи в лог при изменении логики логирования (собственные адаптеры и фильтры);
- Динамический контекст в логировании: как добавить в нужные записи только то, что хотелось бы потом увидеть;
- Реальный и простой пример перехода к современному логированию и анализу логов: Logstash - ElasticSearch - Kibana.&lt;/p&gt;
</summary></entry><entry><title>Lightning Talks - 1</title><link href="https://pyvideo.org/pycon-russia-2015/lightning-talks-1.html" rel="alternate"></link><published>2015-09-18T00:00:00+00:00</published><updated>2015-09-18T00:00:00+00:00</updated><author><name>Various speakers</name></author><id>tag:pyvideo.org,2015-09-18:pycon-russia-2015/lightning-talks-1.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;PyCon RU 2015 first day lightning talks&lt;/p&gt;
</summary><category term="lightning talks"></category></entry><entry><title>Никогда больше так не делай</title><link href="https://pyvideo.org/pycon-russia-2015/nikogda-bolshe-tak-ne-delai.html" rel="alternate"></link><published>2015-09-18T00:00:00+00:00</published><updated>2015-09-18T00:00:00+00:00</updated><author><name>Alexander Shchepanovskiy</name></author><id>tag:pyvideo.org,2015-09-18:pycon-russia-2015/nikogda-bolshe-tak-ne-delai.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Чтобы поддерживать свои стандарты как стиля кодирования, так и его семантики, мы часто используем линтеры. Однако, добавлять свои правила в них достаточно сложно. Поэтому в большинстве команд средства никак или почти никак не подстраиваются ни под конкретный проект, ни под команду в целом.
Ревью кода позволяет частично закрыть этот недостаток, однако, иногда хочется просто ткнуть пальцем и сказать «никогда больше так не делай». Я расскажу о своём проекте-исследовании того, как сделать автоматизацию таких ситуаций простой, а поэтому гибкой и практичной.&lt;/p&gt;
</summary></entry><entry><title>Превращаем свалку проектов в экосистему при помощи setuptools</title><link href="https://pyvideo.org/pycon-russia-2015/prevrashchaem-svalku-proektov-v-ekosistemu-pri-pomoshchi-setuptools.html" rel="alternate"></link><published>2015-09-18T00:00:00+00:00</published><updated>2015-09-18T00:00:00+00:00</updated><author><name>Konstantin Ignatov</name></author><id>tag:pyvideo.org,2015-09-18:pycon-russia-2015/prevrashchaem-svalku-proektov-v-ekosistemu-pri-pomoshchi-setuptools.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;В докладе мы рассмотрим создание файлов setup.py и setup.cfg.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Используем edit-mode при установке пакетов&lt;/li&gt;
&lt;li&gt;Простой setup.py для простого проекта&lt;/li&gt;
&lt;li&gt;Устанавливаем дополнительные файлы&lt;/li&gt;
&lt;li&gt;Строим расширения&lt;/li&gt;
&lt;li&gt;Делаем сложные зависимости&lt;/li&gt;
&lt;li&gt;Добавляем консольные скрипты&lt;/li&gt;
&lt;li&gt;Включаем поддержку плагинов&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Будет полезно всем, кто: разрабатывает &amp;gt;1 взаимодействующих друг с другом проектов, копирует в каждый новый проект папку с любимыми функциями, устанавливает проекты при помощи git clone, copy, rsync и тп,
не пишет расширения из-за сложности развёртывания, пишет консольные скрипты при помощи def main()... if name == '__main__'...,
избегает пакетирования, потому что проекты слишком зависят друг от друга (изменения в одном приводят к изменениям везде).&lt;/p&gt;
</summary></entry><entry><title>Python Packaging Progress</title><link href="https://pyvideo.org/pycon-russia-2015/python-packaging-progress.html" rel="alternate"></link><published>2015-09-18T00:00:00+00:00</published><updated>2015-09-18T00:00:00+00:00</updated><author><name>Benjamin Peterson</name></author><id>tag:pyvideo.org,2015-09-18:pycon-russia-2015/python-packaging-progress.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python packaging is infamous for being brittle and hard to use. Thankfully, a lot of progress has been made in recent years. This talk will explain some of the components and tools in modern Python packaging including pip, PyPI, virtualenv, and wheels.
I'd say the talk is for an intermediate to advanced audience. Ideally, attendees will leave with a clearer idea of how Python packaging works as well as an sense of optimism. :)&lt;/p&gt;
</summary></entry><entry><title>View как чистая функция от состояния базы данных</title><link href="https://pyvideo.org/pycon-russia-2015/view-kak-chistaia-funktsiia-ot-sostoianiia-bazy-dannykh.html" rel="alternate"></link><published>2015-09-18T00:00:00+00:00</published><updated>2015-09-18T00:00:00+00:00</updated><author><name>Ilya Beda</name></author><id>tag:pyvideo.org,2015-09-18:pycon-russia-2015/view-kak-chistaia-funktsiia-ot-sostoianiia-bazy-dannykh.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;В большинстве WEB приложений мы так или иначе взаимодействуем с базой данных. Она хранит в себе информацию, а мы, как программисты, пишем код, преобразующий эти данные в html странички или API интерфейсы.
И так как единой точкой правды является база данных, то и кэшировать WEB приложения нужно, основываясь на её состоянии.
В своем докладе я расскажу про методы кэширования, основанные на ORM. О том, как можно кэшировать запросы к базе данных и функции, зависящие от них. И самое главное, о том, как такой кэш корректно инвалидировать.&lt;/p&gt;
</summary></entry></feed>