<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_valery-calderon.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2019-08-30T00:00:00+00:00</updated><entry><title>Sopita de datos con espinacas (Web scraping)</title><link href="https://pyvideo.org/pycon-latam-2019/sopita-de-datos-con-espinacas-web-scraping.html" rel="alternate"></link><published>2019-08-30T00:00:00+00:00</published><updated>2019-08-30T00:00:00+00:00</updated><author><name>Valery Calder√≥n</name></author><id>tag:pyvideo.org,2019-08-30:pycon-latam-2019/sopita-de-datos-con-espinacas-web-scraping.html</id><summary type="html"></summary></entry><entry><title>Reactive Programming with RxPy</title><link href="https://pyvideo.org/pycon-us-2018/reactive-programming-with-rxpy.html" rel="alternate"></link><published>2018-05-11T00:00:00+00:00</published><updated>2018-05-11T00:00:00+00:00</updated><author><name>Valery Calderon</name></author><id>tag:pyvideo.org,2018-05-11:pycon-us-2018/reactive-programming-with-rxpy.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Web applications contains lots of database operations, network calls, nested callbacks and other computationally expensive tasks that might take a long time to complete or even block other threads until it's done, here is where ReactiveX enters, it doesn't only gives us the facility to convert almost anything to a stream; variables, properties, user inputs, caches, etc to manage it asynchronously. But it also gives us an easy way to handle errors which is a hard task within asynchronous programming. ReactiveX makes our code more flexible, readable, maintainable and easy to write.&lt;/p&gt;
&lt;p&gt;We will be exploring how ReactiveX help us to make things easier with its operators toolbox that can be used to filter, create, transform or unify any of those streams. We will learn that in just a few lines of maintainable code, we can have multiple web sockets which recieves multiple requests all handled by an asynchronous process that serves a filtered output.&lt;/p&gt;
&lt;p&gt;To do that I decided to explain an example of the use with an example by implementing observables, observers/subscribers and subjects. We will start by requesting our data stream from the Github API with a Tornado web socket and then filtering and processing it asynchrounosly.&lt;/p&gt;
</summary></entry></feed>