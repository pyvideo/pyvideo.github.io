<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/tag_tooling.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2019-07-12T00:00:00+00:00</updated><entry><title>And now for something completely different.</title><link href="https://pyvideo.org/europython-2019/and-now-for-something-completely-different.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Danny Engelbarts</name></author><id>tag:pyvideo.org,2019-07-12:europython-2019/and-now-for-something-completely-different.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The goal of this talk is to show the audience a different way of
thinking about and developing regex statements.&lt;/p&gt;
&lt;p&gt;I have been working with UNIX for decades now and, although i always
managed to avoid Perl, i have been intrigued with Regex constructs ever
since my first encounter. These weird unreadable things that can
transform text like nothing else or can find what i’m looking for in
massive files, in no time at all. I’ve created regexes that only appeal
to the most nerdiest of nerds and i’ve stunned colleagues by fixing
their futile regex attempts in just a few keystrokes. But when Damian
Conway showed me how regexes really work i was awestruck. And now i want
to share this knowledge.&lt;/p&gt;
&lt;p&gt;This talk is aimed at pythonistas that have some experience with the re
module. I will take some easy examples and explain in plain english how
a regex engine searches for a match. This will show that a regex is not
some mysterious incomprehensible pattern description or declarative
blueprint. Instead it is a small program that is very good at comparing
single characters. Like any programming language it turns out that once
you understand the rules and structure it suddenly becomes so much
easier to use.&lt;/p&gt;
&lt;p&gt;With this new found knowledge we will up the ante and try some more
difficult stuff, adding other semantics and some tips and tricks. We’ll
look at some pitfalls, maybe compare regex to python solutions and have
a look at some regexes found in the wild (either on my drive or on
github).&lt;/p&gt;
</summary><category term="Compiler and Interpreters"></category><category term="Mind Bending"></category><category term="Programming"></category><category term="Python Skills"></category><category term="Tooling"></category></entry><entry><title>Code quality in Python</title><link href="https://pyvideo.org/europython-2019/code-quality-in-python.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Radosław Ganczarek</name></author><id>tag:pyvideo.org,2019-07-12:europython-2019/code-quality-in-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Four years ago I talked about code quality during EuroPython in
Bilbao. A lot of things changed from that time. Firstly, most tools I
presented were still developed and gained new features, but also new
ones appeared I wanted to discuss with you. Secondly, Python changed,
Python 3 has type hints on board and there is a new tool dedicated to
checking the types. Thirdly - I changed. I'm more distanced form my
zealous approach from four years ago. I got real and reasonable.
That's why I wanted to talk about code quality tools in Python again.&lt;/div&gt;
&lt;div class="line"&gt;I'll talk about all the software that can make code review a bit
simpler by pointing out possible errors, duplicates or unused code.
I'll talk again about formatters and how can they be used in
modern-time projects. And I'll talk about hobgoblins, if you know what
I mean :)&lt;/div&gt;
&lt;/div&gt;
</summary><category term="Best Practice"></category><category term="Code Analysis"></category><category term="Python 3"></category><category term="Tooling"></category><category term="Type-Hinting"></category></entry><entry><title>Go(lang) to Python</title><link href="https://pyvideo.org/europython-2019/golang-to-python.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Stefan Baerisch</name></author><id>tag:pyvideo.org,2019-07-12:europython-2019/golang-to-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python and Go are a great combination. Like Python, Go is easy to learn,
powerful to use and has many useful libraries. Go and Python work great
together: Go has better performance and parallelism, while Python is
more expressive. Wouldn't it be nice if you could combine the benefits
of Go and Python in one program? This talk shows you how.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Why you may want to attend&lt;/div&gt;
&lt;div class="line"&gt;Extension modules written in C/C++ or other languages are one of the
major strength Python. Go is a useful language to extend Python. This
talk explains to you how to implement extension modules in Go.&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Content of the Talk&lt;/div&gt;
&lt;div class="line"&gt;The talk shows how to use CGO to make Go code available as a C library
and then to use Cython to make this library available as a Python
extension module.&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;We start by building a wrapper for simple Go code that adds some
numbers and returns the results. This program is our end-to-end
example to demonstrate the steps necessary to create a Python
extension module in Go.&lt;/div&gt;
&lt;div class="line"&gt;Next, we move to more complex use cases. We look at different ways to
share complex data and to use Python callbacks from Go.&lt;/div&gt;
&lt;div class="line"&gt;Then, we see how to how to handle Go's Garbage Collector when exposing
with Go Objects.&lt;/div&gt;
&lt;div class="line"&gt;Finally, the talk goes into the advantages and disadvantages of Go as
an extension language for Python. We also look at some of the
alternative ways to make Go code available in Python.&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Recommended Prerequisites&lt;/div&gt;
&lt;div class="line"&gt;To get the most out of the talk, you should know about the difference
between native Python modules and extension modules written in other
languages. Some background on concepts like garbage collection, stack
and heap, and dynamic/shared libraries are beneficial. Knowledge of
the Python C API is not required.&lt;/div&gt;
&lt;div class="line"&gt;You do not need to know how to write Go code to follow the talk - the
talk explains all the required Go.&lt;/div&gt;
&lt;/div&gt;
</summary><category term="Cython"></category><category term="Go-Lang"></category><category term="Tooling"></category></entry><entry><title>Deploy Python to the cloud faster with Azure Serverless</title><link href="https://pyvideo.org/europython-2019/deploy-python-to-the-cloud-faster-with-azure-serverless.html" rel="alternate"></link><published>2019-07-11T00:00:00+00:00</published><updated>2019-07-11T00:00:00+00:00</updated><author><name>Jeff Hollan</name></author><id>tag:pyvideo.org,2019-07-11:europython-2019/deploy-python-to-the-cloud-faster-with-azure-serverless.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Bringing your Python scripts or apps and running them in the cloud is
easier than ever with serverless computing. In this talk, we’ll show how
you can use Azure Functions to easily deploy and scale your Python
workloads without having to manage any servers or pay for unused compute
resources. We’ll also show how deep integration with Visual Studio Code
offers a great local development experience with full support for
debugging and testing your app, and allows you to seamlessly deploy your
serverless code to the cloud.&lt;/p&gt;
&lt;p&gt;We’ll start by giving a brief overview of the value of serverless
computing. Next, we'll create a brand new Python app in Visual Studio
Code, and start to add in business logic and ML capabilities. Once we
get the app running debugged locally, we’ll publish it to the cloud as a
serverless function, and demonstrate the serverless scalability.
Finally, we’ll walk you through the tools and capabilities you can
leverage around monitoring and management of your Python Azure
Functions.&lt;/p&gt;
</summary><category term="APIs"></category><category term="Development"></category><category term="Microservices"></category><category term="Scaling"></category><category term="Tooling"></category></entry><entry><title>From Python script to Open Source Project</title><link href="https://pyvideo.org/europython-2019/from-python-script-to-open-source-project.html" rel="alternate"></link><published>2019-07-11T00:00:00+00:00</published><updated>2019-07-11T00:00:00+00:00</updated><author><name>Michał Karzyński</name></author><id>tag:pyvideo.org,2019-07-11:europython-2019/from-python-script-to-open-source-project.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Did you write a cool and useful Python script? Would you like to share
it with the community, but you're not sure how to go about that? If so,
then this talks is for you. We'll go over a list of simple steps which
can turn your script into a fully fledged open-source project.&lt;/p&gt;
&lt;p&gt;The Python community has a rich set of tools which can help verify the
quality of your code through automated code-review and linting. You can
benefit by taking advantage of this ecosystem. Complete the steps in
this checklist, and your project will be easier to maintain, you'll be
ready to take contributions from the community and those contributions
will be up to high standards. Your project will also keep up with other
projects on PyPI and you will be alerted if any new release causes an
incompatibility with your code.&lt;/p&gt;
&lt;p&gt;The same checklist can be used for non open-source projects as well.&lt;/p&gt;
&lt;p&gt;The project maturity checklist includes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Properly structure your code&lt;/li&gt;
&lt;li&gt;Use a setup.py file&lt;/li&gt;
&lt;li&gt;Add entry_points for your script command&lt;/li&gt;
&lt;li&gt;Create a requirements.txt file&lt;/li&gt;
&lt;li&gt;Use Black to format your code&lt;/li&gt;
&lt;li&gt;Create a tox.ini config and include code linters&lt;/li&gt;
&lt;li&gt;Set up a Git repo&lt;/li&gt;
&lt;li&gt;Refactor your code to be unit-testable and add tests&lt;/li&gt;
&lt;li&gt;Add missing docstrings&lt;/li&gt;
&lt;li&gt;Add type annotations and a MyPy verification step&lt;/li&gt;
&lt;li&gt;Upload to GitHub&lt;/li&gt;
&lt;li&gt;Add a continuous integration service (e.g. Travis)&lt;/li&gt;
&lt;li&gt;Add a requirements updater (e.g. pyup.bot)&lt;/li&gt;
&lt;li&gt;Add test coverage checker (e.g. coveralls)&lt;/li&gt;
&lt;li&gt;Add a Readme file and documentation&lt;/li&gt;
&lt;li&gt;Publish your project on PyPI&lt;/li&gt;
&lt;li&gt;Advertise your project&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="Best Practice"></category><category term="Clean Code"></category><category term="Code Analysis"></category><category term="Static Analysis"></category><category term="Tooling"></category></entry><entry><title>Become a command line wizard</title><link href="https://pyvideo.org/europython-2019/become-a-command-line-wizard.html" rel="alternate"></link><published>2019-07-10T00:00:00+00:00</published><updated>2019-07-10T00:00:00+00:00</updated><author><name>Sven-Hendrik Haase</name></author><id>tag:pyvideo.org,2019-07-10:europython-2019/become-a-command-line-wizard.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;There are many modern terminal tools with vastly improved user
experiences as compared to their traditional alternatives. This talk
aims to show off some of those modern terminal tools and compare them
side by side with the traditional ones.&lt;/p&gt;
&lt;p&gt;Python is not only used by software developers with fancy IDEs but also
by DevOps engineers, administrators, and on remote development machines
where using a GUI is impractical. Therefore, many people are stuck with
a terminal interface only and have to use tools like vim, grep, find,
wc, cloc, less and many others to explore their way around their Python
programs.&lt;/p&gt;
&lt;p&gt;However, thanks to the advent of many new and improved tools, we can do
many of the same tasks better, faster and with nicer ergonomics.&lt;/p&gt;
&lt;p&gt;This talk will show off effective use of vim as an IDE with completions
and linting provided by LSP, fd (instead of find) for finding files,
ripgrep (instead of grep) for searching strings, tokei (instead of cloc)
for counting lines of code, bat (instead of cat) for looking at files,
hyperfine for microbenchmarking, httpie (instead of curl) for making
HTTP requests, sd (instead of sed) for text replacement.&lt;/p&gt;
&lt;p&gt;This talk should make terminal work more approachable for all attendees
by showing off how to do some everyday tasks on the terminal.&lt;/p&gt;
</summary><category term="Command-Line"></category><category term="Linux"></category><category term="System Administration"></category><category term="Tooling"></category><category term="Unix"></category></entry><entry><title>Is it me, or the GIL?</title><link href="https://pyvideo.org/europython-2019/is-it-me-or-the-gil.html" rel="alternate"></link><published>2019-07-10T00:00:00+00:00</published><updated>2019-07-10T00:00:00+00:00</updated><author><name>Christoph Heer</name></author><id>tag:pyvideo.org,2019-07-10:europython-2019/is-it-me-or-the-gil.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python's Global Interpreter Lock is a friend and rival at the same time.
We, as developers, can focus on the design and implementation of
applications without the hassle of memory management. On the other side,
we complain about the GIL as the limiting factor of performance
sensitive applications. Therefore, it is common to refactor parts of
systems when the system doesn't perform or scale enough anymore. The
refactoring often includes the switch of the used concurrency paradigms
like replacing multithreading with multiprocessing or asyncio. Another
option is moving logic of CPU-bound workload into C extensions or a full
rewrite in a &amp;quot;GIL-free&amp;quot; language. But how do you know that the GIL is
the actual performance bottleneck?&lt;/p&gt;
&lt;p&gt;While scaling and developing performance sensitive components in Python,
my colleagues and I often also assumed the GIL as cause of our
performance problems because it is a common and simple answer for this
usually complex and varied problems. Instead of starting a rewrite or
major refactoring, we took a step back and tried to prove our
assumption. With the result that analyzing the impact of the GIL
contention on the overall performance is a very interesting problem
without common practices or easy usable set of tools that support Python
developers. Within this talk, I will share and explain the methods and
tools, which we use to analyze the relevance of the GIL on our
application performance and how it helped us to stay focused on the
actual problematic areas of our applications that required improvements
to meet our performance goals.&lt;/p&gt;
</summary><category term="ASYNC / Concurrency"></category><category term="Multi-Threading"></category><category term="Performance"></category><category term="Scaling"></category><category term="Tooling"></category></entry><entry><title>PyRun - Shipping the Python 3.7 runtime in just 4.8MB</title><link href="https://pyvideo.org/europython-2019/pyrun-shipping-the-python-37-runtime-in-just-48mb.html" rel="alternate"></link><published>2019-07-10T00:00:00+00:00</published><updated>2019-07-10T00:00:00+00:00</updated><author><name>Marc-Andre Lemburg</name></author><id>tag:pyvideo.org,2019-07-10:europython-2019/pyrun-shipping-the-python-37-runtime-in-just-48mb.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python has become the defacto standard tool for many people to write
tools, command scripts, smaller applications and even large
applications.&lt;/p&gt;
&lt;p&gt;On Windows, it is fairly easy to build application bundles using e.g.
py2exe, but on Unix, the situation is less obvious, unless you want to
rely on OS specific Python distributions, which often require severall
100MB with of installation on the system and are usually customized in
distribution specific ways.&lt;/p&gt;
&lt;p&gt;Instead of relying on OS installed Python distributions on Unix, our
open- source eGenix PyRun provides a more or less complete Python
runtime (interpreter and stdlib modules) in a single file, which can be
&amp;quot;installed&amp;quot; by simply copying the binary to the destination system. The
file can be as small as 4.8MB for Python 3.7, by using compressors such
as upx.&lt;/p&gt;
&lt;p&gt;Due to its size, it's also the perfect Python distribution for Docker
containers.&lt;/p&gt;
&lt;p&gt;The talk will show how PyRun works, is built, how to customize it to
include additional modules and applications.&lt;/p&gt;
</summary><category term="CPython"></category><category term="Development"></category><category term="Linux"></category><category term="Tooling"></category><category term="Use Case"></category></entry><entry><title>Visual debugger for Jupyter Notebooks: Myth or Reality?</title><link href="https://pyvideo.org/europython-2019/visual-debugger-for-jupyter-notebooks-myth-or-reality.html" rel="alternate"></link><published>2019-07-10T00:00:00+00:00</published><updated>2019-07-10T00:00:00+00:00</updated><author><name>Elizaveta Shashkova</name></author><id>tag:pyvideo.org,2019-07-10:europython-2019/visual-debugger-for-jupyter-notebooks-myth-or-reality.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Many Python developers like Jupyter Notebooks for their flexibility:
they are very useful for interactive prototyping, scientific
experiments, visualizations and many other tasks. There are different
development tools which make working with Jupyter Notebooks easier and
smoother, but all of them lack very important feature: visual debugger.
Since Jupyter Kernel is a usual Python process, it looks reasonably to
use one of existing Python debuggers with it. But is it really possible?&lt;/p&gt;
&lt;p&gt;In this talk we’ll try to understand how Python debugger should be
changed to work with Jupyter cells and how these changes are already
implemented in the PyCharm IDE. After that we’ll look into the whole
Jupyter architecture and try to understand which bottlenecks in it
prevent creation of universal Jupyter debugger at the moment.&lt;/p&gt;
&lt;p&gt;This talk requires a basic knowledge of Jupyter Notebooks and
understanding of Python functions and objects. It will be interesting
for people who want to learn internals of the tools they use every day.
Also it might be an inspiration for people who want to implement a
visual debugger in their favourite IDE.&lt;/p&gt;
</summary><category term="Debugging"></category><category term="Jupyter"></category><category term="Python general"></category><category term="Tooling"></category></entry><entry><title>Wait, IPython can do that?!</title><link href="https://pyvideo.org/europython-2019/wait-ipython-can-do-that.html" rel="alternate"></link><published>2019-07-10T00:00:00+00:00</published><updated>2019-07-10T00:00:00+00:00</updated><author><name>Sebastian Witowski</name></author><id>tag:pyvideo.org,2019-07-10:europython-2019/wait-ipython-can-do-that.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;I've been programming in Python for over 7 years. And from the time
someone introduced me to IPython, it immediately became my default
Python REPL. I enjoyed the syntax highlighting, code completion or the
instant access to the documentation. Over the years, I've picked up more
and more tricks that IPython could do: embedding IPython sessions,
starting IPython automatically when a test fails, taking advantage of
the startup files, not to mention all the various magic functions.&lt;/p&gt;
&lt;p&gt;It took me some time to discover all those features (if there is one
thing I would like you to take away from this talk, it’s that reading
the documentation of a tool that you are using &lt;em&gt;every day&lt;/em&gt; is probably a
good idea) and in this talk, I will give an overview of what you can do
with IPython REPL.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Some of the things I will talk about:&lt;/div&gt;
&lt;div class="line"&gt;- Documentation with ? and ??, running shell functions in IPython,
magic functions&lt;/div&gt;
&lt;div class="line"&gt;- Profiles, startup files, configuration file, kernels, and extensions&lt;/div&gt;
&lt;div class="line"&gt;- How to better use IPython for debugging&lt;/div&gt;
&lt;div class="line"&gt;- How to use IPython for profiling&lt;/div&gt;
&lt;div class="line"&gt;- Alternatives to IPython REPL&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This talk is for you if you are a casual user of IPython - you know some
of its features, but maybe not all of them and instead of reading
through the documentation, you would prefer to see someone giving an
overview of IPython features and how you can use them.&lt;/p&gt;
&lt;p&gt;This talk is NOT for you if you are up to date with IPython
documentation and you think you know most of its features.&lt;/p&gt;
</summary><category term="Best Practice"></category><category term="Development"></category><category term="Ipython"></category><category term="Tooling"></category><category term="iPython"></category></entry><entry><title>Design Your Open Source Project</title><link href="https://pyvideo.org/pycon-philippines-2012/design-your-open-source-project.html" rel="alternate"></link><published>2012-06-30T00:00:00+00:00</published><updated>2012-06-30T00:00:00+00:00</updated><author><name>Bryan Veloso</name></author><id>tag:pyvideo.org,2012-06-30:pycon-philippines-2012/design-your-open-source-project.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Closing Keynote - a practical walkthrough of what to consider when creating an open source project, and several resources to get you started (especially with documentation)&lt;/p&gt;
</summary><category term="open source"></category><category term="keynote"></category><category term="tooling"></category><category term="documentation"></category></entry></feed>