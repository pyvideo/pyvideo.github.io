<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_sebastian-buczynski.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2019-04-14T00:00:00+00:00</updated><entry><title>Serverless</title><link href="https://pyvideo.org/stx-next-tech-power-summit-2018/serverless.html" rel="alternate"></link><published>2019-04-14T00:00:00+00:00</published><updated>2019-04-14T00:00:00+00:00</updated><author><name>Sebastian Buczyński</name></author><id>tag:pyvideo.org,2019-04-14:stx-next-tech-power-summit-2018/serverless.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Presentation on Serverless by Sebastian Buczyński, Python Developer &amp;#64; STX Next&lt;/p&gt;
</summary></entry><entry><title>Clean architecture in Python</title><link href="https://pyvideo.org/pygotham-2018/clean-architecture-in-python.html" rel="alternate"></link><published>2018-10-05T00:00:00+00:00</published><updated>2018-10-05T00:00:00+00:00</updated><author><name>Sebastian Buczyński</name></author><id>tag:pyvideo.org,2018-10-05:pygotham-2018/clean-architecture-in-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Believe me or not, but your database is not your application. Neither are ORM models or even your framework. They are not reasons for building yet another project. The real motivation is to satisfy some business needs. Unfortunately, it might get out of sight due to years spent on writing Django- or Rails-like web applications. Their ORMs usually dominates in applications, coupling business logic to the framework and making it impossible to (unit) test it without database access. The fact is you can develop and test features without even thinking about how business objects map into database tables. Software engineering brought several solutions over last few years, and I want to share with you one of them, called Clean Architecture.&lt;/p&gt;
&lt;p&gt;Clean Architecture is an approach that puts your customer's concerns in the centre of your software. All other issues, such as persistence are treated as implementation details. This is achieved thanks to a careful layering of the project. There are few interesting outcomes. Firstly, business rules layer knows nothing about a framework or a database. Therefore you can develop and test all business logic without saving results anywhere. Secondly, upgrading or even swapping a framework is less painful. The same is true for every third-party service as they are abstracted away. Thirdly, Clean Architecture makes introducing new team members to the project much simpler since everything has its place. Last, but certainly not least - as time passes and project grows Clean Architecture lets you maintain order remain flexible.&lt;/p&gt;
</summary></entry><entry><title>Why you don't need design patterns in Python?</title><link href="https://pyvideo.org/europython-2017/why-you-dont-need-design-patterns-in-python.html" rel="alternate"></link><published>2017-07-11T00:00:00+00:00</published><updated>2017-07-11T00:00:00+00:00</updated><author><name>Sebastian Buczyński</name></author><id>tag:pyvideo.org,2017-07-11:europython-2017/why-you-dont-need-design-patterns-in-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Exactly 23 years have passed since release of one of the biggest IT
classics - &amp;quot;Design Patterns: Elements of Reusable Object-Oriented
Software&amp;quot;.&lt;/p&gt;
&lt;p&gt;Contents of the book had considerable influence on dominant
programming languages of those days. However, design patterns were
not glorified by everyone. Voices of rational critic appeared,
pointing out that design patterns are just ways to compensate for
missing languages features by tons of clumsy code. If one implements
design patterns in Python by the book, they will get code that looks
awkward, at best.&lt;/p&gt;
&lt;p&gt;This talk is to present Python's features that either simplifies or
eliminates need for implementing design patterns. Even if you don't
know what design patterns are - don't worry. You still may see some
new interesting Python's features and their usage.&lt;/p&gt;
</summary></entry><entry><title>Distributed locks with Python and Redis</title><link href="https://pyvideo.org/europython-2015/distributed-locks-with-python-and-redis.html" rel="alternate"></link><published>2015-08-03T00:00:00+00:00</published><updated>2015-08-03T00:00:00+00:00</updated><author><name>Sebastian Buczyński</name></author><id>tag:pyvideo.org,2015-08-03:europython-2015/distributed-locks-with-python-and-redis.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Sebastian Buczyński - Distributed locks with Python and Redis
[EuroPython 2015]
[22 July 2015]
[Bilbao, Euskadi, Spain]&lt;/p&gt;
&lt;p&gt;Traditional methods of coping with concurrent programming problems are
well-known and described in literature. Many programming languages,
including Python, contain in their standard libraries tools and
primitives such as semaphores and can spawn threads or subprocesses.&lt;/p&gt;
&lt;p&gt;However, in the face of increasing interest in service oriented
architecture and building distributed systems, that span across many
independent server nodes, emerges a need to adapt traditional
solutions, so they can be applied in the new environment.&lt;/p&gt;
&lt;p&gt;In this talk I will share my experiences gathered during building a
modern contact center - highly concurrent system, which requires
certain resources to be accessed exclusively by several self-contained
components.&lt;/p&gt;
</summary></entry></feed>