<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_matt-spitz.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2012-03-09T00:00:00+00:00</updated><entry><title>Using Coroutines to Create Efficient, High-Concurrency Web Applications</title><link href="https://pyvideo.org/pycon-us-2011/pycon-2011--using-coroutines-to-create-efficient-.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Matt Spitz</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--using-coroutines-to-create-efficient-.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Using Coroutines to Create Efficient, High-Concurrency Web Applications&lt;/p&gt;
&lt;p&gt;Presented by Matt Spitz&lt;/p&gt;
&lt;p&gt;Creating high-concurrency python web applications is inherently
difficult for a variety of reasons. In this talk, I'll discuss the
various iterations of application server paradigms we've used at meebo,
the advantages/disadvantages of each approach, and why we've settled on
a coroutine-based WSGI setup to handle our high-concurrency web
applications going forward.&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;There are a number of ways in which to create a web application in
python. Some examples include a straight-up CGI scripts that run anew
with each request, preforked Apache workers that each handle multiple
requests, and using an asynchronous web framework like Twisted.&lt;/p&gt;
&lt;p&gt;At meebo, we've settled on using gunicorn, a lightweight WSGI server,
which supports gevent, a coroutine-based network library for python.
Gevent monkeypatches python's system modules to make network requests
asynchronous using an event loop based on libevent. This trick allows
the developer to use a simple blocking CGI as a non-blocking web
application that can handle many concurrent requests.&lt;/p&gt;
&lt;p&gt;I'll discuss our iteration process through these approaches to building
web applications, why we ended up choosing gunicorn+gevent, the
challenges this new framework presents, and how we've dealt with them.&lt;/p&gt;
</summary><category term="coroutines"></category><category term="gevent"></category><category term="gunicorn"></category><category term="highconcurrency"></category><category term="libevent"></category><category term="pycon"></category><category term="pycon2011"></category><category term="wsgi"></category></entry><entry><title>Practical Machine Learning in Python</title><link href="https://pyvideo.org/pycon-us-2012/practical-machine-learning-in-python.html" rel="alternate"></link><published>2012-03-09T00:00:00+00:00</published><updated>2012-03-09T00:00:00+00:00</updated><author><name>Matt Spitz</name></author><id>tag:pyvideo.org,2012-03-09:pycon-us-2012/practical-machine-learning-in-python.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;There are a plethora of options when it comes to deciding how to add a
machine learning component to your python application. In this talk,
I'll discuss why python as a language is well-suited to solving these
particular problems, the tradeoffs of different machine learning
solutions for python applications, and some tricks you can use to get
the most out of whatever package you decide to use.&lt;/p&gt;
</summary></entry></feed>