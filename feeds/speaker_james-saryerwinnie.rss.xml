<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Fri, 12 Jul 2019 00:00:00 +0000</lastBuildDate><item><title>Downloading a Billion Files in Python</title><link>https://pyvideo.org/europython-2019/downloading-a-billion-files-in-python.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;You've been given a task. You need to download some files from a server
to your local machine. The files are fairly small, and you can list and
access these files from the remote server through a REST API. You'd like
to download them as fast as possible. The catch? There's a billion of
them. Yes, one billion files.&lt;/p&gt;
&lt;p&gt;How would would you do this? Would you do this synchronously in a single
for loop? Would you use a producer/consumer queue with threads?
Multiprocessing? Asyncio?&lt;/p&gt;
&lt;p&gt;In this talk, we'll examine 3 different mechanisms for concurrently
downloading files: multithreading, multiprocessing, and asyncio.&lt;/p&gt;
&lt;p&gt;For each of these mechanisms we'll look at design best practices, how to
handle debugging and error handling, and of course the overall
performance. By examining three different approaches using the same data
set, we gain a better understanding of the tradeoffs of each approach so
we can pick the right library for the job.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">James Saryerwinnie</dc:creator><pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-07-12:europython-2019/downloading-a-billion-files-in-python.html</guid><category>ASYNC / Concurrency</category><category>Case Study</category><category>Multi-Processing</category><category>Multi-Threading</category><category>Performance</category></item><item><title>A Crash Course on Serverless Applications in Python</title><link>https://pyvideo.org/pygotham-2018/a-crash-course-on-serverless-applications-in-python.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;There's a new class of applications that are becoming more prevalent these days: serverless applications. Serverless computing allows you to build and run applications without having to think about servers. Serverless apps don't require you to provision or scale any servers.&lt;/p&gt;
&lt;p&gt;How can we take advantage of serverless computing as python developers? What tools and frameworks are available that make writing serverless apps a breeze? And most importantly, how do we design and structure our applications in this serverless world to ensure we're best utilizing the underlying services?&lt;/p&gt;
&lt;p&gt;This is a practical talk on serverless architecture. In this talk, we'll look at several serverless architecture patterns covering real world use cases. We'll also look at actual open source serverless applications so we have concrete code examples we can review. These open source serverless applications leverage various AWS services including AWS Lambda and Amazon API Gateway. We'll also cover common strategies for deploying your serverless applications.&lt;/p&gt;
&lt;p&gt;Come learn how to design serverless applications in python so you can focus on writing your core applications rather than worrying about managing servers.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">James Saryerwinnie</dc:creator><pubDate>Fri, 05 Oct 2018 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2018-10-05:pygotham-2018/a-crash-course-on-serverless-applications-in-python.html</guid></item><item><title>Debugging Your Code with Data Visualization</title><link>https://pyvideo.org/europython-2018/debugging-your-code-with-data-visualization.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Let’s face it. Sometimes our code just isn’t working how we expect it to
work. When this happens, we fall back to our trusty tools to help us
debug: pdb, the logging module, or even simple print statements. But
sometimes that just isn’t enough, we still can’t figure out why our code
is broken. We need something more.&lt;/p&gt;
&lt;p&gt;There are a number of fantastic libraries in python for creating data
visualizations. These libraries are commonly used for analyzing and
visualizing large sets of data, but don’t see as much usage when it
comes to helping us write and debug our code.&lt;/p&gt;
&lt;p&gt;What if we could combine the two? What if we could leverage data
visualization tools to understand what our program is doing? Sometimes,
by seeing a visual representation of what our code is doing, it becomes
much easier to understand why our code is not working. We don’t need to
create publication quality graphs and charts, we just need to generate
quick, one-off visualizations to understand what our code is doing. What
we want is the “data visualization” equivalent to print() statements.&lt;/p&gt;
&lt;p&gt;To help illustrate this point, I will walk through some of the hardest
bugs I’ve had to track down while working on projects such as the AWS
CLI and boto3, the AWS SDK for Python. For each bug, I’ll show you how I
was able to leverage data visualization techniques to troubleshoot and
fix these bugs. Come learn how to debug more efficiently by leveraging
data visualization.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">James Saryerwinnie</dc:creator><pubDate>Thu, 26 Jul 2018 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2018-07-26:europython-2018/debugging-your-code-with-data-visualization.html</guid></item><item><title>Next Level Testing Revisited</title><link>https://pyvideo.org/pygotham-2017/next-level-testing-revisited.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Unit and integration tests are great first steps towards improving the quality of your python project. Ever wonder if there’s even more you can do?   In this talk we’ll cover additional types of tests that can help improve the quality and robustness of your python projects: stateful property-based testing, generative fuzz testing, long term stability testing and advanced multithreaded testing.&lt;/p&gt;
&lt;p&gt;This talk is more than just theory.  We'll look at specific libraries and frameworks that help you write these advanced tests.  I'll also show you real world examples of bugs these tests have found from projects that I maintain.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">James Saryerwinnie</dc:creator><pubDate>Fri, 06 Oct 2017 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2017-10-06:pygotham-2017/next-level-testing-revisited.html</guid></item><item><title>Next Level Testing</title><link>https://pyvideo.org/pycon-us-2017/next-level-testing.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Unit, functional, and integration tests are great first steps towards
improving the quality of your python project. Ever wonder if there’s
even more you can do? Maybe you've heard of property-based testing,
fuzzing, and mutation testing but you're unsure exactly how they can
help you. In this talk we’ll cover additional types of tests that can
help improve the quality and robustness of your python projects:
property-based testing, fuzz testing, stress testing, long term
reliability testing, and mutation testing.&lt;/p&gt;
&lt;p&gt;We’ll also go beyond just covering what these tests are. For each of the
test types above, I’ll give you real world examples from open source
software that I maintain that shows you the types of bugs each test type
can find. I’ll also show you how you can integrate these tests into your
Travis CI and/or Jenkins environment.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">James Saryerwinnie</dc:creator><pubDate>Fri, 19 May 2017 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2017-05-19:pycon-us-2017/next-level-testing.html</guid></item><item><title>Writing Redis in Python with asyncio</title><link>https://pyvideo.org/europython-2016/writing-redis-in-python-with-asyncio.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;James Saryerwinnie - Writing Redis in Python with asyncio
[EuroPython 2016]
[21 July 2016]
[Bilbao, Euskadi, Spain]
(&lt;a class="reference external" href="https://ep2016.europython.eu//conference/talks/writing-redis-in-python-with-asyncio"&gt;https://ep2016.europython.eu//conference/talks/writing-redis-in-python-with-asyncio&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;In this talk, I'll show you how to write redis using asyncio.  You'll
see how you can create a real world application using asyncio by
creating a python port of redis.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;Python has been adding more and more async features to the language.
Starting with asyncio in python 3.4 and including the new async/await
keywords in python 3.5, it's difficult to understand how all these
pieces fit together.  More importantly, it's hard to envision how to
use these new language features in a real world application.  In this
talk we're going to move beyond the basic examples of TCP echo servers
and example servers that can add number together.  Instead I'll show
you a realistic asyncio application.  This application is a port of
redis, a popular data structure server, written in python using
asyncio.  In addition to basic topics such as handling simple redis
commands (GET, SET, APPEND, etc),  we'll look at notifications using
pub/sub, how to implement the MONITOR command, and persistence.  Come
learn how to apply the asyncio library to real world applications.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">James Saryerwinnie</dc:creator><pubDate>Thu, 04 Aug 2016 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2016-08-04:europython-2016/writing-redis-in-python-with-asyncio.html</guid></item><item><title>Supporting Everything - Python2/3, Mac/Linux/Windows</title><link>https://pyvideo.org/pycon-ca-2013/supporting-everything-python23-maclinuxwind.html</link><description>&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;There comes a time in the life of a library where it must leave your
machine and find a home in a far away computer. That computer might even
run windows. This talk will show how you can write a library that
supports Linux/Mac/Windows and runs on python 2 and 3.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">James Saryerwinnie</dc:creator><pubDate>Sat, 10 Aug 2013 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2013-08-10:pycon-ca-2013/supporting-everything-python23-maclinuxwind.html</guid><category>talk</category></item></channel></rss>