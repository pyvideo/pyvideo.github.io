<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org - Serge Sans Paille</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_serge-sans-paille.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2020-07-23T00:00:00+00:00</updated><subtitle></subtitle><entry><title>Tooling for Static Analysis of Python Programs</title><link href="https://pyvideo.org/europython-2020/tooling-for-static-analysis-of-python-programs.html" rel="alternate"></link><published>2020-07-23T00:00:00+00:00</published><updated>2020-07-23T00:00:00+00:00</updated><author><name>Serge Sans Paille</name></author><id>tag:pyvideo.org,2020-07-23:/europython-2020/tooling-for-static-analysis-of-python-programs.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In spite of the dynamic nature of their favorite language, some Python developer have a huge desire to statically analyse it. This can indeed be useful for linters, type inference, auto-completion and all the tooling some developers expect from modern IDE.
We all know that lazy binding prevents even â€¦&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In spite of the dynamic nature of their favorite language, some Python developer have a huge desire to statically analyse it. This can indeed be useful for linters, type inference, auto-completion and all the tooling some developers expect from modern IDE.
We all know that lazy binding prevents even the simplest function call or attribute lookup to be reliably analyzed. Yet we try. And Python as this fabulous &lt;tt class="docutils literal"&gt;ast&lt;/tt&gt; module, saving us from writing a parser! Isn't that a strong incentive to do static analysis?&lt;/p&gt;
&lt;p&gt;This talk presents two modules developers can build upon to build such analyzers:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;gast, a generalization of the Python AST that provides a common API for all the variant of the Python AST, from python 2.7 to Python 3.8&lt;/li&gt;
&lt;li&gt;beniget, an analyzer of the Python AST (built upon gast) that provides a useful and well-known abstraction to understand programs: use-def chains&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Built upon these two modules, memestra is a static analyzer of deprecated function calls, developed in partnership with QuantStack. A tool which, given a module, reports any use of deprecated APIs. Let's explore how such a module can be built and unveil the mysteries of static analysis.&lt;/p&gt;
</content><category term="EuroPython 2020"></category><category term="europython"></category><category term="europython-2020"></category><category term="europython-online"></category><category term="Compiler and Interpreters"></category></entry><entry><title>Crossing the native code frontier</title><link href="https://pyvideo.org/pyparis-2018/crossing-the-native-code-frontier.html" rel="alternate"></link><published>2018-11-14T00:00:00+00:00</published><updated>2018-11-14T00:00:00+00:00</updated><author><name>Serge sans Paille</name></author><id>tag:pyvideo.org,2018-11-14:/pyparis-2018/crossing-the-native-code-frontier.html</id><content type="html"></content><category term="PyParis 2018"></category></entry></feed>