<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org - Benjy Weinberger</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_benjy-weinberger.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2023-10-08T12:15:00+00:00</updated><subtitle></subtitle><entry><title>Managing multiple Django services in a single repo</title><link href="https://pyvideo.org/djangocon-europe-2021/managing-multiple-django-services-in-a-single-repo.html" rel="alternate"></link><published>2021-06-03T00:00:00+00:00</published><updated>2021-06-03T00:00:00+00:00</updated><author><name>Benjy Weinberger</name></author><id>tag:pyvideo.org,2021-06-03:/djangocon-europe-2021/managing-multiple-django-services-in-a-single-repo.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Django projects are standalone by nature, but with the right tooling and practices you can effectively maintain many interrelated Django services in a single streamlined repo, with minimal boilerplate and copypasta.&lt;/p&gt;
&lt;p&gt;Modern software systems often involve developing and deploying multiple related services. The microservice architecture is a prominent example …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Django projects are standalone by nature, but with the right tooling and practices you can effectively maintain many interrelated Django services in a single streamlined repo, with minimal boilerplate and copypasta.&lt;/p&gt;
&lt;p&gt;Modern software systems often involve developing and deploying multiple related services. The microservice architecture is a prominent example of this. These services often share underlying data structures, models, utilities, protocols and other core code.&lt;/p&gt;
&lt;p&gt;Django is an excellent choice for building individual services, and some functionality can be shared between them by reusing apps. But Django projects themselves are standalone by nature, and there is no standard infrastructure for streamlining the management many related services. As a result we're often forced to treat each project as an island, with its own settings and deployment configuration, possibly in its own repo.&lt;/p&gt;
&lt;p&gt;In this workshop we will demonstrate:
- The challenges of maintaining many interrelated Django projects.
- The advantages of having multiple Django projects coexist in a single shared repo.
- The tooling you need to work effectively in a Django monorepo, with a focus on the Pants build system.
- Specific examples of good practices that allow you to maintain a growing yet streamlined stable of interrelated Django-based microservices with minimal boilerplate and copypasta.&lt;/p&gt;
&lt;p&gt;Code along with us, and ask questions along the way!&lt;/p&gt;
</content><category term="DjangoCon Europe 2021"></category><category term="Django"></category><category term="DjangoConEU"></category><category term="djangoconeu2021"></category></entry><entry><title>Pants: Cargo for Python</title><link href="https://pyvideo.org/pybay-2023/Pants_Cargo_for_Python.html" rel="alternate"></link><published>2023-10-08T12:15:00+00:00</published><updated>2023-10-08T12:15:00+00:00</updated><author><name>Benjy Weinberger</name></author><id>tag:pyvideo.org,2023-10-08:/pybay-2023/Pants_Cargo_for_Python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python has a thriving ecosystem of single-purpose tools such as pytest, mypy, black and so on, but no standard orchestration tool to manage them efficiently. This makes it difficult to scale up Python codebases without a lot of bespoke scripting.&lt;/p&gt;
&lt;p&gt;As a result, Python repos tend to be small …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python has a thriving ecosystem of single-purpose tools such as pytest, mypy, black and so on, but no standard orchestration tool to manage them efficiently. This makes it difficult to scale up Python codebases without a lot of bespoke scripting.&lt;/p&gt;
&lt;p&gt;As a result, Python repos tend to be small, focused on building a single library or binary. Dependencies are managed by publishing versioned artifacts from one repo and consuming them in another repo by download.&lt;/p&gt;
&lt;p&gt;But in the age of microservices, cloud functions, continuous delivery, and rapid iteration, this can be untenable. We often need to repeatedly build and deploy many small, interdependent parts out of a single large repo, and the sequential publishing cycle is too slow and cumbersome.&lt;/p&gt;
&lt;p&gt;Pants is a build system with a focus on Python. It aims to be for Python what Cargo is for Rust: the one-stop shop for efficiently testing, typechecking, formatting, packaging and deploying code. Pants uses static analysis to grok your code's dependencies automatically, so you don't have to maintain large amounts of metadata. It uses this dependency data, along with its local and remote caching and concurrency capabilities, to dramatically speed up the development and CI cycle.&lt;/p&gt;
&lt;p&gt;This talk will explain what Pants is and how it works. It will provide canonical examples of how to use Pants effectively with Python code, such Django apps and AWS Lambdas. And how to use it to package your code as a standalone binary or a Docker image.&lt;/p&gt;
</content><category term="PyBay 2023"></category></entry><entry><title>Creating extensible workflows with off-label use of Python</title><link href="https://pyvideo.org/pycon-us-2021/creating-extensible-workflows-with-off-label-use-of-python.html" rel="alternate"></link><published>2021-05-14T00:00:00+00:00</published><updated>2021-05-14T00:00:00+00:00</updated><author><name>Benjy Weinberger</name></author><id>tag:pyvideo.org,2021-05-14:/pycon-us-2021/creating-extensible-workflows-with-off-label-use-of-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Workflow-oriented systems have many uses, including data processing and analysis, ETL, CI/CD, and more. But creating a programmatic interface to a workflow system is a delicate balancing act: we want the API to be flexible enough to support useful work, but also constrained enough that tasks run cooperatively …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Workflow-oriented systems have many uses, including data processing and analysis, ETL, CI/CD, and more. But creating a programmatic interface to a workflow system is a delicate balancing act: we want the API to be flexible enough to support useful work, but also constrained enough that tasks run cooperatively within the larger system.&lt;/p&gt;
&lt;p&gt;We faced this challenge when designing the task API for the Pants build system. We needed to allow custom task code to enjoy the benefits of complex features like caching, concurrency and remote execution, without every task author having to reason about them.&lt;/p&gt;
&lt;p&gt;In this talk we'll show how we found the right balance through unconventional use of Python's type annotations, coroutines, and dataclasses. Combining these seemingly disparate features in the context of a workflow engine allows you to build elegant extensibility APIs with just the right amount of flexibility.&lt;/p&gt;
&lt;p&gt;Slides: &lt;a class="reference external" href="https://docs.google.com/presentation/d/1aWZjk3tZUp37RDmZZxy0j8OjbatzkuWLfuSh84Lzwfk/edit?usp=sharing"&gt;https://docs.google.com/presentation/d/1aWZjk3tZUp37RDmZZxy0j8OjbatzkuWLfuSh84Lzwfk/edit?usp=sharing&lt;/a&gt;&lt;/p&gt;
</content><category term="PyCon US 2021"></category></entry></feed>