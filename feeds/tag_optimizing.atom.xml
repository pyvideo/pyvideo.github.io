<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/tag_optimizing.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2012-08-22T00:00:00+00:00</updated><entry><title>PyOhio 2010: Making it go faster</title><link href="https://pyvideo.org/pyohio-2010/pyohio-2010--making-it-go-faster.html" rel="alternate"></link><published>2010-07-31T00:00:00+00:00</published><updated>2010-07-31T00:00:00+00:00</updated><author><name>W. Matthew Wilson</name></author><id>tag:pyvideo.org,2010-07-31:pyohio-2010/pyohio-2010--making-it-go-faster.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Making it go faster&lt;/p&gt;
&lt;p&gt;Presented by W. Matthew Wilson&lt;/p&gt;
&lt;p&gt;An introduction to profiling python code.&lt;/p&gt;
&lt;p&gt;I'll use cProfile, pstats, and RunSnakeRun to find where code is getting
bogged down in a real-world example. I'll measure the run-time cost with
timeit, refactor, and measure it again.&lt;/p&gt;
&lt;p&gt;Finally, I'll talk about the limits of python optimization and show how
to replace python code with C.&lt;/p&gt;
</summary><category term="cprofile"></category><category term="optimizing"></category><category term="pstats"></category><category term="pyohio"></category><category term="pyohio2010"></category><category term="runsnakerun"></category><category term="timeit"></category></entry><entry><title>PyOhio 2010: PyPy and Unladen Swallow: Making your Python Fast</title><link href="https://pyvideo.org/pyohio-2010/pyohio-2010--pypy-and-unladen-swallow--making-you.html" rel="alternate"></link><published>2010-07-31T00:00:00+00:00</published><updated>2010-07-31T00:00:00+00:00</updated><author><name>Alex Gaynor</name></author><id>tag:pyvideo.org,2010-07-31:pyohio-2010/pyohio-2010--pypy-and-unladen-swallow--making-you.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;PyPy and Unladen-Swallow: Making your Python Fast&lt;/p&gt;
&lt;p&gt;Presented by Alex Gaynor&lt;/p&gt;
&lt;p&gt;Python has a reputation for being a bit slow, but it doesn't have to be
that way. This talk will cover why Python is slow, and what two of the
most exciting virtual machines are doing about it.&lt;/p&gt;
</summary><category term="optimizing"></category><category term="pyohio"></category><category term="pyohio2010"></category><category term="pypy"></category><category term="unladenswallow"></category></entry><entry><title>PyOhio 2011: Squinting at Python Objects</title><link href="https://pyvideo.org/pyohio-2011/pyohio-2011-squinting-at-python-objects.html" rel="alternate"></link><published>2011-07-30T00:00:00+00:00</published><updated>2011-07-30T00:00:00+00:00</updated><author><name>Brandon Rhodes</name></author><id>tag:pyvideo.org,2011-07-30:pyohio-2011/pyohio-2011-squinting-at-python-objects.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Squinting at Python Objects&lt;/p&gt;
&lt;p&gt;Presented by Brandon Craig Rhodes&lt;/p&gt;
&lt;p&gt;Python classes can gain attributes as if by magic. Thanks to properties,
descriptors, and (if all else fails) &lt;strong&gt;getattr&lt;/strong&gt;() and
&lt;strong&gt;getattribute&lt;/strong&gt;(), the attempt to access obj.something can result in
arbitrary code execution. If you are wondering how your Python program
is using memory, this can result in a problem: each time you look to see
if something is there, it &lt;strong&gt;is&lt;/strong&gt;, because it is pulled in dynamically
the moment you look for it. In this talk, you will learn how to prod
Python objects gently, and hopefully learn their secrets - and their
memory usage - without actually invoking code.&lt;/p&gt;
</summary><category term="descriptors"></category><category term="getattr"></category><category term="getattribute"></category><category term="optimizing"></category><category term="properties"></category><category term="pyohio"></category><category term="pyohio2011"></category></entry><entry><title>Secrets of PostgreSQL Performance</title><link href="https://pyvideo.org/djangocon-us-2011/djangocon-2011--secrets-of-postgresql-performance.html" rel="alternate"></link><published>2011-09-05T00:00:00+00:00</published><updated>2011-09-05T00:00:00+00:00</updated><author><name>Frank Wiles</name></author><id>tag:pyvideo.org,2011-09-05:djangocon-us-2011/djangocon-2011--secrets-of-postgresql-performance.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Secrets of PostgreSQL Performance&lt;/p&gt;
&lt;p&gt;Presented by Frank Wiles&lt;/p&gt;
&lt;p&gt;PostgreSQL is effectively the default RDBMS for Django. Learn the dark
arts of optimizing this powerful database to be blazingly fast on your
own hardware or in the cloud.&lt;/p&gt;
</summary><category term="djangocon"></category><category term="djangocon2011"></category><category term="optimize"></category><category term="optimizing"></category><category term="postgresql"></category><category term="rdbms"></category></entry><entry><title>Relate or !Relate</title><link href="https://pyvideo.org/europython-2011/relate-or-relate.html" rel="alternate"></link><published>2011-07-13T00:00:00+00:00</published><updated>2011-07-13T00:00:00+00:00</updated><author><name>Mark Ramm-Christensen</name></author><id>tag:pyvideo.org,2011-07-13:europython-2011/relate-or-relate.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Mark Ramm-Christensen - 21 June 2011 in &amp;quot;Track
Spaghetti&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;To Relate or Not to Relate, that is the question raised by the NoSQL
movement. There is a lot of buzz about Couch, Casandra, MongoDB, and
other non relational databases, and at the same time there are decades
of hard work that's gone into optimizing databases built around the
relational model.&lt;/p&gt;
&lt;p&gt;I would actually argue that there is no such thing as a NoSQL database -
there are a variety of compelling options to relational database - each
of which have different features and different performance
characteristics. So no one- sized fits all comparison will do. So, I'll
try to outline a general taxonomy for persistence mechanisms, and then
proceed to comparing relational DB's to their new friends in practice.&lt;/p&gt;
&lt;p&gt;The talk will contain quite a few stories from the trenches with
CouchDB, MongoDB, MySQL, Postgres, Tokyo Cabinet, ZODB, and other
databases, and will help you think about the data storage needs of your
applications in new ways.&lt;/p&gt;
</summary><category term="database"></category><category term="nosql"></category><category term="optimizing"></category><category term="performance"></category></entry><entry><title>Techniques for improving Python performance</title><link href="https://pyvideo.org/pycon-au-2012/techniques-for-improving-python-performance.html" rel="alternate"></link><published>2012-08-22T00:00:00+00:00</published><updated>2012-08-22T00:00:00+00:00</updated><author><name>Andrew Rowe</name></author><id>tag:pyvideo.org,2012-08-22:pycon-au-2012/techniques-for-improving-python-performance.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Andrew Rowe will detail and demonstrate a number of proven techniques
for improving the performance of large Python programs.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;ul class="simple"&gt;
&lt;li&gt;Using multiprocessing.&lt;/li&gt;
&lt;li&gt;Using custom extensions.&lt;/li&gt;
&lt;li&gt;Refactoring code.&lt;/li&gt;
&lt;li&gt;using comprehensions.&lt;/li&gt;
&lt;li&gt;Dictionaries v. Lists.&lt;/li&gt;
&lt;li&gt;Range v. xrange.&lt;/li&gt;
&lt;li&gt;Profiling.&lt;/li&gt;
&lt;li&gt;Detecting choke points.&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="optimizing"></category></entry></feed>