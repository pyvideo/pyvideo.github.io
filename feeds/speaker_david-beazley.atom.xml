<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_david-beazley.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2019-05-01T09:00:00+00:00</updated><entry><title>Lambda Calculus from the Ground Up</title><link href="https://pyvideo.org/pycon-us-2019/lambda-calculus-from-the-ground-up.html" rel="alternate"></link><published>2019-05-01T09:00:00+00:00</published><updated>2019-05-01T09:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2019-05-01:pycon-us-2019/lambda-calculus-from-the-ground-up.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;These days, programming style guides are all the rage. However, what if
your style guide was so restrictive that it only gave you
single-argument functions and nothing else? No modules, no classes, no
control flow, no data structures, and not even any primitives like
integers or regular expressions. Just functions. Could you actually
program anything at all? Surprisingly, the answer is yes. In this
tutorial, you'll learn how as you work through a ground-up derivation of
the lambda calculus in Python.&lt;/p&gt;
&lt;p&gt;You will learn nothing practically useful in this tutorial. No
packaging. No tools. No libraries. No deployment. No magic Python
programming techniques. And certainly learn nothing you would ever want
to apply to a real project. You will, on the other hand, have a lot of
fun, be completely amazed, and learn some foundational computer science
that is a jumping off point for further explorations of functional
programming, type theory, programming languages, and more.&lt;/p&gt;
</summary><category term="tutorial"></category></entry><entry><title>Die Threads</title><link href="https://pyvideo.org/europython-2018/die-threads.html" rel="alternate"></link><published>2018-07-25T00:00:00+00:00</published><updated>2018-07-25T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2018-07-25:europython-2018/die-threads.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In the brave new world of async, threads are now a thing of the past. Or
are they not?&lt;/p&gt;
</summary></entry><entry><title>Reinventing the Parser Generator</title><link href="https://pyvideo.org/pycon-us-2018/reinventing-the-parser-generator.html" rel="alternate"></link><published>2018-05-13T00:00:00+00:00</published><updated>2018-05-13T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2018-05-13:pycon-us-2018/reinventing-the-parser-generator.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Writing lexers and parsers is a complex problem that often involves the use of special tools and domain specific languages (e.g., the lex/yacc tools on Unix).  In 2001, I wrote Python versions of these tools which can be found in the PLY project.  PLY predates a huge number of modern Python features including the iteration protocol, generators, decorators, metaclasses, and more.  As such, it relied on a variety of clever hacks to layer a domain specific parser specification language on top of Python itself.&lt;/p&gt;
&lt;p&gt;In this talk, I discuss a modernization of the PLY project that abandons its past and freely abuses modern Python features including advanced metaclasses, guaranteed dictionary ordering, class decorators, type hints, and more.   The result of this work can be found in the SLY project.  However, this talk isn't so much about SLY as it is focused on how far you can push Python metaprogramming features to create domain-specific languages.   Prepare to be horrified--and to write code that will break your IDE.&lt;/p&gt;
</summary><category term="ply"></category><category term="sly"></category><category term="parser"></category></entry><entry><title>The Other Async</title><link href="https://pyvideo.org/pygotham-2017/the-other-async.html" rel="alternate"></link><published>2017-10-07T00:00:00+00:00</published><updated>2017-10-07T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2017-10-07:pygotham-2017/the-other-async.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;PyGotham 2017 keynote by David Beazley&lt;/p&gt;
</summary></entry><entry><title>The Fun of Reinvention</title><link href="https://pyvideo.org/pycon-israel-2017/the-fun-of-reinvention.html" rel="alternate"></link><published>2017-06-12T00:00:00+00:00</published><updated>2017-06-12T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2017-06-12:pycon-israel-2017/the-fun-of-reinvention.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In the early days of Python, the &amp;quot;F&amp;quot; may have been a key to its early success.  It was just the sort of magic power that made hard problems easier and impossible problems possible.  It was what made you want to program in your spare time.  It made management ask probing questions such as &amp;quot;who gave you permission to do this?&amp;quot;  No, the &amp;quot;F&amp;quot; was an unstoppable force for good.  As Python has matured, discussions of the &amp;quot;F&amp;quot; have often given way to more serious topics such as Unicode, packaging, and backwards compatibility.   However, it never really went away.  In fact, it's been sitting their in plain sight all along--growing in power.  In this talk,  I'll give a forward-looking discussion of Python's future and exploiting the power of the &amp;quot;F&amp;quot;.&lt;/p&gt;
</summary></entry><entry><title>Keynote: Built in Super Heroes</title><link href="https://pyvideo.org/pydata-chicago-2016/keynote-built-in-super-heroes.html" rel="alternate"></link><published>2016-08-28T00:00:00+00:00</published><updated>2016-08-28T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2016-08-28:pydata-chicago-2016/keynote-built-in-super-heroes.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;PyData Chicago 2016&lt;/p&gt;
</summary></entry><entry><title>Keynote - Topics of Interest (Python Asyncio)</title><link href="https://pyvideo.org/python-brasil-2015/keynote-david-beazley-topics-of-interest-python-asyncio.html" rel="alternate"></link><published>2015-11-10T00:00:00+00:00</published><updated>2015-11-10T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2015-11-10:python-brasil-2015/keynote-david-beazley-topics-of-interest-python-asyncio.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Keynote da Conferência Python Brasil 11 [2015] - São José dos Campos&lt;/p&gt;
&lt;p&gt;A conferência Python Brasil aconteceu dos dias 09 e 10 de Novembro de 2015, no Novotel, em São José dos Campos.&lt;/p&gt;
&lt;p&gt;Keynote do David Beazley, sobre Topics of Interest (Python Asyncio)&lt;/p&gt;
&lt;p&gt;Mais informações:&lt;/p&gt;
&lt;p&gt;Site: &lt;a class="reference external" href="http://pythonbrasil.github.io/pythonb"&gt;http://pythonbrasil.github.io/pythonb&lt;/a&gt;...
Twitter: &amp;#64;pythonbrasil
Facebook: &lt;a class="reference external" href="http://www.facebook.com/pythonbrasil"&gt;http://www.facebook.com/pythonbrasil&lt;/a&gt;
Manual do Big Kahuna: &lt;a class="reference external" href="https://manual-do-big-kahuna.readthed"&gt;https://manual-do-big-kahuna.readthed&lt;/a&gt;...&lt;/p&gt;
</summary></entry><entry><title>Keynote: Fear and Awaiting in Async: A Savage Journey to the Heart of the Coroutine Dream</title><link href="https://pyvideo.org/pyohio-2016/keynote-fear-and-awaiting-in-async-a-savage-journey-to-the-heart-of-the-coroutine-dream.html" rel="alternate"></link><published>2016-07-30T00:00:00+00:00</published><updated>2016-07-30T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2016-07-30:pyohio-2016/keynote-fear-and-awaiting-in-async-a-savage-journey-to-the-heart-of-the-coroutine-dream.html</id><summary type="html"></summary></entry><entry><title>Vintage 1978 Superboard II hacking with some Python3 and ZeroMQ</title><link href="https://pyvideo.org/chipy/vintage-1978-superboard-ii-hacking-with-some-pyth.html" rel="alternate"></link><published>2011-01-13T00:00:00+00:00</published><updated>2011-01-13T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2011-01-13:chipy/vintage-1978-superboard-ii-hacking-with-some-pyth.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;I'm not sure if we're still looking for talks on Thursday, but if so,
I'd like to volunteer to give a talk about using Python to do some
retro-computing hacking involving my vintage 1978 Superboard II. It's
not exactly robotics, but it involves hardware and a lot of low-level
hacking (along with some Python3 and ZeroMQ thrown in for good measure
;-).&lt;/p&gt;
</summary><category term="chipy"></category><category term="cool"></category><category term="python3"></category><category term="zeromq"></category></entry><entry><title>Changes to the GIL in Python 3</title><link href="https://pyvideo.org/chipy/changes-to-the-gil-in-python-3.html" rel="alternate"></link><published>2010-01-14T00:00:00+00:00</published><updated>2010-01-14T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2010-01-14:chipy/changes-to-the-gil-in-python-3.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Follow-up to David's last GIL talk in June 2009. This presentation walks
through changes to the GIL that are being made.&lt;/p&gt;
</summary><category term="chipy"></category><category term="gil"></category><category term="python3"></category></entry><entry><title>Mindblowing Python GIL</title><link href="https://pyvideo.org/chipy/mindblowing-python-gil.html" rel="alternate"></link><published>2009-06-11T00:00:00+00:00</published><updated>2009-06-11T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2009-06-11:chipy/mindblowing-python-gil.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Mindblowing Python GIL&lt;/p&gt;
&lt;p&gt;Presented by David Beazley at ChiPy on June 11, 2009&lt;/p&gt;
&lt;p&gt;David Beazley: mind-blowing presentation about how the Python GIL
actually works and why it's even worse than most people even imagine.&lt;/p&gt;
&lt;p&gt;Slides: &lt;a class="reference external" href="http://www.dabeaz.com/python/GIL.pdf"&gt;http://www.dabeaz.com/python/GIL.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[VIDEO HAS PROBLEMS: audio is fuzzy]&lt;/p&gt;
</summary><category term="chipy"></category><category term="gil"></category><category term="python-advanced"></category></entry><entry><title>PyCon 2009: A Curious Course on Coroutines and Concurrency (Part 3 of 3)</title><link href="https://pyvideo.org/pycon-us-2009/pycon-2009--a-curious-course-on-coroutines-and-c0.html" rel="alternate"></link><published>2009-02-17T00:00:00+00:00</published><updated>2009-02-17T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2009-02-17:pycon-us-2009/pycon-2009--a-curious-course-on-coroutines-and-c0.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;A Curious Course on Coroutines and Concurrency (part 3 of 3)&lt;/p&gt;
&lt;p&gt;Presented at PyCon 2009 by David Beazley&lt;/p&gt;
&lt;p&gt;If you are a programmer who cares about Python and concurrency, then you
should also care about Python coroutines. Although they were first
introduced in Python 2.5, coroutines remain one of Python's most
overlooked features--- often vaguely described as a curious &amp;quot;extension&amp;quot;
of generator functions with little insight as to how they might be
applied to real-world problems. This tutorial examines coroutines in a
more practical light by showing how they are actually a very elegant way
to implement a processing &amp;quot;task.&amp;quot; Using this task abstraction, it is
possible to use coroutines to implement processing pipelines, event
handling systems, and programs based on cooperative multitasking.
Moreover, if you define tasks using coroutines, they can be easily
incorporated into more traditional concurrent programs that utilize
threads or message passing.&lt;/p&gt;
&lt;p&gt;[VIDEO HAS ISSUES: bit of clipping start to finish.]&lt;/p&gt;
</summary><category term="concurrency"></category><category term="coroutines"></category><category term="generator"></category><category term="pycon"></category><category term="pycon2009"></category><category term="python-advanced"></category></entry><entry><title>PyCon 2009: A Curious Course on Coroutines and Concurrency (Part 2 of 3)</title><link href="https://pyvideo.org/pycon-us-2009/pycon-2009--a-curious-course-on-coroutines-and-c1.html" rel="alternate"></link><published>2009-02-17T00:00:00+00:00</published><updated>2009-02-17T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2009-02-17:pycon-us-2009/pycon-2009--a-curious-course-on-coroutines-and-c1.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;A Curious Course on Coroutines and Concurrency (part 2 of 3)&lt;/p&gt;
&lt;p&gt;Presented at PyCon 2009 by David Beazley&lt;/p&gt;
&lt;p&gt;If you are a programmer who cares about Python and concurrency, then you
should also care about Python coroutines. Although they were first
introduced in Python 2.5, coroutines remain one of Python's most
overlooked features--- often vaguely described as a curious &amp;quot;extension&amp;quot;
of generator functions with little insight as to how they might be
applied to real-world problems. This tutorial examines coroutines in a
more practical light by showing how they are actually a very elegant way
to implement a processing &amp;quot;task.&amp;quot; Using this task abstraction, it is
possible to use coroutines to implement processing pipelines, event
handling systems, and programs based on cooperative multitasking.
Moreover, if you define tasks using coroutines, they can be easily
incorporated into more traditional concurrent programs that utilize
threads or message passing.&lt;/p&gt;
&lt;p&gt;[VIDEO HAS ISSUES: bit of clipping start to finish.]&lt;/p&gt;
</summary><category term="concurrency"></category><category term="coroutines"></category><category term="generator"></category><category term="pycon"></category><category term="pycon2009"></category><category term="python-advanced"></category></entry><entry><title>PyCon 2009: A Curious Course on Coroutines and Concurrency (Part 1 of 3)</title><link href="https://pyvideo.org/pycon-us-2009/pycon-2009--a-curious-course-on-coroutines-and-co.html" rel="alternate"></link><published>2009-02-17T00:00:00+00:00</published><updated>2009-02-17T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2009-02-17:pycon-us-2009/pycon-2009--a-curious-course-on-coroutines-and-co.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;A Curious Course on Coroutines and Concurrency (part 1 of 3)&lt;/p&gt;
&lt;p&gt;Presented at PyCon 2009 by David Beazley&lt;/p&gt;
&lt;p&gt;If you are a programmer who cares about Python and concurrency, then you
should also care about Python coroutines. Although they were first
introduced in Python 2.5, coroutines remain one of Python's most
overlooked features--- often vaguely described as a curious &amp;quot;extension&amp;quot;
of generator functions with little insight as to how they might be
applied to real-world problems. This tutorial examines coroutines in a
more practical light by showing how they are actually a very elegant way
to implement a processing &amp;quot;task.&amp;quot; Using this task abstraction, it is
possible to use coroutines to implement processing pipelines, event
handling systems, and programs based on cooperative multitasking.
Moreover, if you define tasks using coroutines, they can be easily
incorporated into more traditional concurrent programs that utilize
threads or message passing.&lt;/p&gt;
&lt;p&gt;[VIDEO HAS ISSUES: bit of clipping start to finish.]&lt;/p&gt;
</summary><category term="concurrency"></category><category term="coroutines"></category><category term="generator"></category><category term="pycon"></category><category term="pycon2009"></category><category term="python-advanced"></category></entry><entry><title>Mastering Python 3 I/O (part 1)</title><link href="https://pyvideo.org/pycon-us-2010/pycon-2010--mastering-python-3-i-o.html" rel="alternate"></link><published>2010-02-19T00:00:00+00:00</published><updated>2010-02-19T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2010-02-19:pycon-us-2010/pycon-2010--mastering-python-3-i-o.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Mastering Python 3 I/O&lt;/p&gt;
&lt;p&gt;Presented by David Beazley&lt;/p&gt;
&lt;p&gt;As most Python programmers know, Python 3 breaks backwards compatibility
with Python 2 in a number of significant ways. Although guides to Python
3 tend to focus on superficial incompatibilities such as the new print
function, changes to exception handling, or new language features, the
most substantial changes concern the strict separation of Unicode and
bytes as well as the new I/O stack. Not only do these changes have
far-reaching effects throughout the standard library, but changes to I/O
are likely to be the most major source of problems for anyone porting an
existing Python application to Python 3. In this tutorial, we're going
to take a top-to-bottom tour of the entire Python 3 I/O system. We'll
focus on how to properly handle both text and binary data, changes to
standard library modules, examine advanced features such as the buffer
API, perform some performance experiments, and end with practical advice
for programmers working on porting applications from Python 2 to 3.
Intended Audience&lt;/p&gt;
&lt;p&gt;Intermediate to advanced Python programmers who are either developing
new applications or contemplating a migration to Python 3. Attendees
should already be familiar with the basics of Python programming
including standard datatypes and commonly used library modules. A
background in systems programming topics such as file handling,
subprocesses, and socket programming is also recommended. Class Outline&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Introducing Python 3 (with a focus on I/O)&lt;/li&gt;
&lt;li&gt;Text Processing&lt;/li&gt;
&lt;li&gt;Binary Data Handling&lt;/li&gt;
&lt;li&gt;Dealing with System Interfaces and External Programs&lt;/li&gt;
&lt;li&gt;The New io library&lt;/li&gt;
&lt;li&gt;Network programming&lt;/li&gt;
&lt;li&gt;The revised buffer API and direct I/O&lt;/li&gt;
&lt;li&gt;Porting from Python 2 to 3.&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="io"></category><category term="pycon"></category><category term="pycon2010"></category><category term="python3"></category><category term="tutorial"></category></entry><entry><title>Understanding the Python GIL (#82)</title><link href="https://pyvideo.org/pycon-us-2010/pycon-2010--understanding-the-python-gil---82.html" rel="alternate"></link><published>2010-02-19T00:00:00+00:00</published><updated>2010-02-19T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2010-02-19:pycon-us-2010/pycon-2010--understanding-the-python-gil---82.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Understanding the Python GIL&lt;/p&gt;
&lt;p&gt;Presented by David Beazley&lt;/p&gt;
&lt;p&gt;The Python Global Interpreter Lock (GIL) is a frequent source of debate
and concern for programmers working with threads and concurrency.
Although most Python programmers generally know that the GIL restricts
Python's ability to utilize multiple CPUs, few know the inner details of
how it actually works and how it impacts applications. This talk will
dive into the inner workings of the GIL like you've never seen before.
Topics include details about the execution of the Python interpreter,
thread implementation, the GILs surprising behavior on multicore CPUs,
and more.&lt;/p&gt;
</summary><category term="concurrency"></category><category term="gil"></category><category term="pycon"></category><category term="pycon2010"></category><category term="threads"></category></entry><entry><title>Using Python 3 to Build a Cloud Computing Service for my Superboard II</title><link href="https://pyvideo.org/pycon-us-2011/pycon-2011--using-python-3-to-build-a-cloud-compu.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--using-python-3-to-build-a-cloud-compu.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Using Python 3 to Build a Cloud Computing Service for my Superboard II&lt;/p&gt;
&lt;p&gt;Presented by David Beazley&lt;/p&gt;
&lt;p&gt;The OSI Superboard II was the computer on which I first learned to
program back in 1979. Python is why programming remains fun today. In
this tale of old meets new, I describe how I have used Python 3 to
create a cloud computing service for my still-working Superboard--a
problem complicated by it only having 8Kb of RAM and 300-baud cassette
tape audio ports for I/O.&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;Python 3, what good is it? Cloud computing? Bah! In this talk, I
describe how I have used Python 3 to build a distributed cloud-computing
service for my Superboard II system. Originally built in 1978, the
Superboard is an obvious candidate for cloud computing due to its
extremely constrained memory (8Kb), slow processor (a 1Mhz 6502),
crippled I/O (300 baud over audio), and retro programming environment
(Microsoft Basic 1.0). The only question is how to do it?&lt;/p&gt;
&lt;p&gt;To answer that question, this talk consist of two main parts. In the
first part, I discuss the problem of building a communications stack
between the Superboard and a Mac using nothing but audio
line-in/line-out ports--a problem involving a tricky I/O handling,
real-time audio signal processing, and the creation of a data-link layer
communication protocol. In the second part, I discuss the creation of a
distributed cloud-computing service and related topics including
messaging systems, key-value stores, map-reduce, etc.&lt;/p&gt;
&lt;p&gt;The primary implementation language for all of this work is Python 3.
Throughout the talk, I will mention interesting Python 3 programming
idioms along with pros and cons. I'll conclude by summarizing my
experience trying to build a significant project entirely in Python 3.&lt;/p&gt;
</summary><category term="pycon"></category><category term="pycon2011"></category><category term="soawesome"></category><category term="superboard"></category></entry><entry><title>David Beazley Keynote: Tinkering with PyPy</title><link href="https://pyvideo.org/pycon-us-2012/keynote-david-beazley.html" rel="alternate"></link><published>2012-03-10T00:00:00+00:00</published><updated>2012-03-10T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2012-03-10:pycon-us-2012/keynote-david-beazley.html</id><summary type="html"></summary><category term="pypy"></category></entry><entry><title>Python: A "Toy" Language</title><link href="https://pyvideo.org/pycon-us-2013/python-a-toy-language.html" rel="alternate"></link><published>2013-03-15T00:00:00+00:00</published><updated>2013-03-15T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2013-03-15:pycon-us-2013/python-a-toy-language.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;A very special guest speaker will talk about solving important &amp;quot;toy&amp;quot;
problems with Python.&lt;/p&gt;
</summary><category term="talk"></category></entry><entry><title>Python 3 Metaprogramming</title><link href="https://pyvideo.org/pycon-us-2013/python-3-metaprogramming.html" rel="alternate"></link><published>2013-03-14T00:00:00+00:00</published><updated>2013-03-14T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2013-03-14:pycon-us-2013/python-3-metaprogramming.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Some of the most significant changes in Python 3 are related to
metaprogramming. In this tutorial, I'll cover decorators, class
decorators, descriptors, and metaclasses. However, the focus will be on
idioms and examples that are only made possible using features that are
unique to Python 3. For instance, making free use of function
annotations, signatures, new metaclass features and more.&lt;/p&gt;
</summary><category term="tutorial"></category></entry><entry><title>Learn Python Through Public Data Hacking</title><link href="https://pyvideo.org/pycon-us-2013/learn-python-through-public-data-hacking.html" rel="alternate"></link><published>2013-03-13T00:00:00+00:00</published><updated>2013-03-13T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2013-03-13:pycon-us-2013/learn-python-through-public-data-hacking.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;What's more fun than learning Python? Learning Python by hacking on
public data! In this tutorial, you'll learn Python basics by reading
files, scraping the web, building data structures, and analyzing real
world data. By the end, you will have set up your Python environment,
installed some useful packages, and learned how to write simple programs
that you can use to impress your friends.&lt;/p&gt;
</summary><category term="tutorial"></category></entry><entry><title>Discovering Python</title><link href="https://pyvideo.org/pycon-us-2014/discovering-python.html" rel="alternate"></link><published>2014-04-13T00:00:00+00:00</published><updated>2014-04-13T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2014-04-13:pycon-us-2014/discovering-python.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;So, what happens when you lock a Python programmer in a secret vault
containing 1.5 TBytes of C++ source code and no internet connection?
Find out as I describe how I used Python as a secret weapon of
&amp;quot;discovery&amp;quot; in an epic legal battle.&lt;/p&gt;
</summary></entry><entry><title>Generators: The Final Frontier</title><link href="https://pyvideo.org/pycon-us-2014/generators-the-final-frontier.html" rel="alternate"></link><published>2014-04-12T00:00:00+00:00</published><updated>2014-04-12T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2014-04-12:pycon-us-2014/generators-the-final-frontier.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Python generators have long been useful for solving all sorts of
problems involving iteration and data flow. However, one of their more
powerful uses is in customizing various aspects of program control flow.
In this tutorial, we'll look at some more exotic uses of generators such
as writing context managers, inlining callback functions, eliminating
recursion, implementing actors, and more.&lt;/p&gt;
</summary></entry><entry><title>Python Concurrency From the Ground Up: LIVE!</title><link href="https://pyvideo.org/pycon-us-2015/python-concurrency-from-the-ground-up-live.html" rel="alternate"></link><published>2015-04-11T00:00:00+00:00</published><updated>2015-04-11T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2015-04-11:pycon-us-2015/python-concurrency-from-the-ground-up-live.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;There are currently three popular approaches to Python concurrency:
threads, event loops, and coroutines. Each is shrouded by various
degrees of mystery and peril. In this talk, all three approaches will be
deconstructed and explained in a epic ground-up live coding battle.&lt;/p&gt;
</summary></entry><entry><title>Modules and Packages: Live and Let Die!</title><link href="https://pyvideo.org/pycon-us-2015/modules-and-packages-live-and-let-die.html" rel="alternate"></link><published>2015-04-10T00:00:00+00:00</published><updated>2015-04-10T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2015-04-10:pycon-us-2015/modules-and-packages-live-and-let-die.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;All Python programmers use the import statement, but do you really know
how it works and what it allows? This tutorial aims to take a deep dive
into every diabolical issue related to modules, packages, and imports.
When we're done, you'll finally be ready to unleash your million line
micro framework on the world!&lt;/p&gt;
</summary></entry></feed>