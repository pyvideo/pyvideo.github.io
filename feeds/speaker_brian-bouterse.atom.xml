<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_brian-bouterse.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2017-02-05T00:00:00+00:00</updated><entry><title>Debugging Hung Python Processes with GDB</title><link href="https://pyvideo.org/fosdem-2017/debugging-hung-python-processes-with-gdb.html" rel="alternate"></link><published>2017-02-05T00:00:00+00:00</published><updated>2017-02-05T00:00:00+00:00</updated><author><name>Brian Bouterse</name></author><id>tag:pyvideo.org,2017-02-05:fosdem-2017/debugging-hung-python-processes-with-gdb.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;When things go wrong in production, it can be necessary to troubleshoot problems where they occur, instead of in a development environment. In those situations having a working knowledge of GDB, GDB Python Extensions, and strace is very helpful. You will see some  simple techniques to get insight into those situations. This talk  outlines several techniques for connecting to an already running, &amp;quot;stuck&amp;quot;, or deadlocked Python process using GDB for debugging.During the talk, we will:inspect the current state of threads withuse and demo the GDB macros for Pythoninspect a locally running process and a core dump collected from a remote machineuse strace to gather system call information about a processdiscuss  the SIGTRAP handler as a proactive way to make rpdb available in production.I have had to debug several hard-to-find bugs that were very infrequent deadlocks using Python. Furthermore it was happening on remote machines I could not have network access to. This technique was invaluable in those situations.&lt;/p&gt;
</summary></entry></feed>