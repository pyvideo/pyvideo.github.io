<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_claudio-freire.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2018-11-24T00:00:00+00:00</updated><entry><title>Caching para hordas y estampidas</title><link href="https://pyvideo.org/pycon-ar-2013/caching-para-hordas-y-estampidas.html" rel="alternate"></link><published>2013-10-24T00:00:00+00:00</published><updated>2013-10-24T00:00:00+00:00</updated><author><name>Claudio Freire</name></author><id>tag:pyvideo.org,2013-10-24:pycon-ar-2013/caching-para-hordas-y-estampidas.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Caching para muchos es functools.lrucache, o (dios) un diccionario. Para muchos es memcache y chau pichi. Pero cuando se implementa a gran escala, las hordas y las estampidas, ambas de miedo por sí solas, se juntan en el fenómeno de las &amp;quot;stampeding herds&amp;quot;. No es moco'e pavo combatir semejante alianza, y en esta charla, espero introducir a quienes estén interesados al mundo del cacheo más complejo, del que hace falta cuando se tienen decenas de servers en unísono.&lt;/p&gt;
&lt;p&gt;Help us caption &amp;amp; translate this video!&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://amara.org/v/DKnw/"&gt;http://amara.org/v/DKnw/&lt;/a&gt;&lt;/p&gt;
</summary></entry><entry><title>Todo lo que no querés saber de async</title><link href="https://pyvideo.org/pycon-ar-2018/todo-lo-que-no-queres-saber-de-async.html" rel="alternate"></link><published>2018-11-24T00:00:00+00:00</published><updated>2018-11-24T00:00:00+00:00</updated><author><name>Claudio Freire</name></author><id>tag:pyvideo.org,2018-11-24:pycon-ar-2018/todo-lo-que-no-queres-saber-de-async.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Async está de moda, y todo el mundo dice que la rompe. Pero tiene sus falencias, y también hay que hablar de ellas.&lt;/p&gt;
&lt;p&gt;Async, todo el mundo habla de lo genial que es. No me gustaría ser uno del montón, así que... voy a hablar de lo genial que NO es. Todas las aristas cortantes de async, o muchas al menos. Todos quieren hacerte creer que Async es la solución si puteaste con threads, pero con async también vas a putear. He sudado sange y derramado sudor (no lágrimas) por async, hora de compartir el dolor, y ver posta para qué es bueno Async.&lt;/p&gt;
</summary></entry><entry><title>Inferencia de tipos en Python</title><link href="https://pyvideo.org/pycon-ar-2012/inferencia-de-tipos-en-python.html" rel="alternate"></link><published>2012-11-17T00:00:00+00:00</published><updated>2012-11-17T00:00:00+00:00</updated><author><name>Claudio Freire</name></author><id>tag:pyvideo.org,2012-11-17:pycon-ar-2012/inferencia-de-tipos-en-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Muchos trabajos y papers intentaron realizar inferencia de tipos en
Python. Siendo un lenguaje dinámico, con un uso pervasivo de Duck
Typing, se hace difícil. Intentaré exponer en esta charla mi experiencia
en el tema, en particular, con inferencia &amp;quot;en tiempo de importación&amp;quot;, un
concepto relativamente nuevo, relacionado con compilación JIT, pero no
del todo lo mismo.&lt;/p&gt;
</summary></entry><entry><title>Multiprocesamiento en python</title><link href="https://pyvideo.org/pycon-ar-2012/multiprocesamiento-en-python.html" rel="alternate"></link><published>2012-11-17T00:00:00+00:00</published><updated>2012-11-17T00:00:00+00:00</updated><author><name>Claudio Freire</name></author><id>tag:pyvideo.org,2012-11-17:pycon-ar-2012/multiprocesamiento-en-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Tomar ventaja del multiprocesamiento de los sistemas modernos en sus
varias formas es todo un reto. Esta charla revisará las varias técnicas
disponibles a los desarrolladores, y las lecciones aprendidas mediante
la experiencia ganada al enfrentar estos problemas en Livra.com,
notoriamente, una manera de conseguir concurrencia real utilizando
multithreading y CPython, junto con formas de comunicación interproceso
eficientes cuando multithreading simplemente no es suficiente.&lt;/p&gt;
</summary></entry><entry><title>Efficient shared memory data structures</title><link href="https://pyvideo.org/pycon-us-2018/efficient-shared-memory-data-structures.html" rel="alternate"></link><published>2018-05-13T00:00:00+00:00</published><updated>2018-05-13T00:00:00+00:00</updated><author><name>Claudio Freire</name></author><id>tag:pyvideo.org,2018-05-13:pycon-us-2018/efficient-shared-memory-data-structures.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Multithreading makes shared memory easy, but true parallelism next to impossible. Multiprocessing gives us true parallelism, but it makes sharing memory very difficult, and high overhead. In this talk, we'll explore techniques to share memory between processes efficiently, with a focus on sharing read-only massive data structures.&lt;/p&gt;
</summary></entry><entry><title>Caching para hordas y estampidas</title><link href="https://pyvideo.org/pycon-uy-2013/caching-para-hordas-y-estampidas.html" rel="alternate"></link><published>2013-11-02T00:00:00+00:00</published><updated>2013-11-02T00:00:00+00:00</updated><author><name>Claudio Freire</name></author><id>tag:pyvideo.org,2013-11-02:pycon-uy-2013/caching-para-hordas-y-estampidas.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Caching para muchos es functools.lrucache, o (dios) un diccionario. Para muchos es memcache y chau pichi. Pero cuando se implementa a gran escala, las hordas y las estampidas, ambas de miedo por sí solas, se juntan en el fenómeno de las &amp;quot;stampeding herds&amp;quot;. No es moco'e pavo combatir semejante alianza, y en esta charla, espero introducir a quienes estén interesados al mundo del cacheo más complejo, del que hace falta cuando se tienen decenas de servers en unísono.&lt;/p&gt;
</summary></entry><entry><title>Compartiendo memoria eficientemente con proxies</title><link href="https://pyvideo.org/pycon-ar-2016/compartiendo-memoria-eficientemente-con-proxies.html" rel="alternate"></link><published>2016-11-25T00:00:00+00:00</published><updated>2016-11-25T00:00:00+00:00</updated><author><name>Claudio Freire</name></author><id>tag:pyvideo.org,2016-11-25:pycon-ar-2016/compartiendo-memoria-eficientemente-con-proxies.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;PyconAR 2016 - Bahía Blanca&lt;/p&gt;
&lt;p&gt;Compartiendo memoria eficientemente con proxies por Claudio Freire&lt;/p&gt;
&lt;p&gt;Audience level: Avanzada&lt;/p&gt;
&lt;p&gt;Descripción&lt;/p&gt;
&lt;p&gt;¿Cuántas tuviste que escalar, con multiprocessing, o tu framework favorito? ¿Notaste que los requisitos de memoria se te iban a las nubes? Presentaré una lib recién salida de la panadería, sharedbuffers, y las técnicas y conceptos detrás de la misma. Cómo crear segmentos de memoria compartida, cómo usarlos para compartir objetos y estructuras complejas, e incluso que no entran en memoria.&lt;/p&gt;
&lt;p&gt;Resumen&lt;/p&gt;
&lt;p&gt;La charla intenta exponer dos cosas:&lt;/p&gt;
&lt;p&gt;Por un lado, técnicas interesantes para compartir memoria de forma eficiente en Python, algo que suele ser complejo con las herramientas normalmente a disposición de los desarrolladores.&lt;/p&gt;
&lt;p&gt;Por otro lado, expone una librería que hice a tal efecto, sharedbuffers, con el objetivo de hacer la tarea más sencilla para el próximo que intente.&lt;/p&gt;
&lt;p&gt;Se van a cubrir conceptos de alto nivel, aptos para usuarios intermedios, como es el uso de la librería, pero para poder sacar el provecho máximo a la charla, en particular la segunda parte en que se exponen los detalles de la implementación, es necesario tener conocimientos más avanzados. Así que la estoy marcando como una charla avanzada.&lt;/p&gt;
&lt;p&gt;Y sí, no tengo ni idea si se dice librería o biblioteca. Pero se instala en /usr/lib así que yo le digo librería :-p&lt;/p&gt;
&lt;p&gt;El flujo de la charla está planeado a grandes rasgos como sigue:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Motivación 4'&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;El cache que no entra en memoria 7 veces&lt;/li&gt;
&lt;li&gt;Cuando el costo de serialización se vuelve prohibitivo&lt;/li&gt;
&lt;li&gt;Transición de un cache a un bundle compartido&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Ejemplo rápido 3'&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;Base de user agents de 30GB&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;La técnica por arriba 12'&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;Compartiendo un buffer de bytes mediante archivos mapeados 2'&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Embebiendo objetos simples en el buffer 5'&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;Definición de schemas 2'&lt;/li&gt;
&lt;li&gt;Manipulación sin deserialización con proxies 3'&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Complejizando los objetos 5'&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;Colecciones 1'&lt;/li&gt;
&lt;li&gt;Estructuras jerárquicas 2'&lt;/li&gt;
&lt;li&gt;Estructuras cíclicas 2'&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;La técnica a bajo nivel 16'&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Estructura en memoria de un objeto 4'&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;Atributos con tipos estáticos&lt;/li&gt;
&lt;li&gt;Wrappers con RTTI para atributos con tipo dinámico&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;Secuencias lineales 4'&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Mapeos 8'&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;El hash table compacto 5'&lt;/li&gt;
&lt;li&gt;Características de performance 3'&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Logrando que vaya rápido 6'&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;Cython magic 3'&lt;/li&gt;
&lt;li&gt;Reuso de proxies, transmutación de tipos 3'&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;El futuro 4'&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;Compatibilidad/chequeo de schemas 1'&lt;/li&gt;
&lt;li&gt;Proxies transparentes transmutando mixins 1'&lt;/li&gt;
&lt;li&gt;Estructuras mutables y lockless 2'&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;Preguntas&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Slides:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Slides de la charla, en &lt;a class="reference external" href="http://ar.pycon.org/proposals/document/6/2003fb75-dd55-44f1-90ca-d1496e8a818a.pdf"&gt;formato pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Slides de la charla, en &lt;a class="reference external" href="http://ar.pycon.org/proposals/document/5/ff4059c7-f10e-4c1f-b34e-47739f212464.odp"&gt;formato libreoffice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</summary></entry></feed>