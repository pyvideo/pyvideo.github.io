<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/tag_ci.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2011-07-18T00:00:00+00:00</updated><entry><title>Large Problems in Django, Mostly Solved</title><link href="https://pyvideo.org/djangocon-us-2010/djangocon-2010--large-problems-in-django--mostly-.html" rel="alternate"></link><published>2010-09-08T00:00:00+00:00</published><updated>2010-09-08T00:00:00+00:00</updated><author><name>Eric Holscher</name></author><id>tag:pyvideo.org,2010-09-08:djangocon-us-2010/djangocon-2010--large-problems-in-django--mostly-.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;This talk is based on my popular series of blog posts highlighting
applications from the community. I will highlight some of the best
applications that the Django/Python community has put together, talk
about places that are lacking, and talk about what these popular
applications have in common.&lt;/p&gt;
&lt;p&gt;Part 1&lt;/p&gt;
&lt;p&gt;I have written a series of blog posts about &amp;quot;Large problems&amp;quot; in the
community, and how they have been solved by members of our community
with reusable apps. Previously I have covered:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Delayed Execution&lt;/li&gt;
&lt;li&gt;Search&lt;/li&gt;
&lt;li&gt;APIs&lt;/li&gt;
&lt;li&gt;Documentation&lt;/li&gt;
&lt;li&gt;Database Migrations&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I will update my thoughts on these issues, as well as talking about a
couple of other new issues that I think that have been solved in a
decent way. These include:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Remote Command Execution&lt;/li&gt;
&lt;li&gt;Debugging in Development&lt;/li&gt;
&lt;li&gt;Continuous Integration&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Part 2&lt;/p&gt;
&lt;p&gt;In this part I will highlight issues that are still headaches for the
Community. These are places where there is a good chance for growth for
third party apps, and places where I have personally found some friction
in my development. A couple examples of this are:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Deployment&lt;/li&gt;
&lt;li&gt;Class Based Views / Thread Safety&lt;/li&gt;
&lt;li&gt;Debugging Production Environments&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Part 3&lt;/p&gt;
&lt;p&gt;From the above applications that are well done, what makes a popular
reusable app? This won't be my thoughts, but more looking at apps that
have been successful and trying to see what they have in common. A good
app and a good reusable app are necessarily different, and I think it
will be interesting to look at what traits make reusable apps popular.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://ericholscher.com/tag/largeproblems/"&gt;Large problems posts&lt;/a&gt;&lt;/p&gt;
</summary><category term="api"></category><category term="ci"></category><category term="continuousintegration"></category><category term="databasemigrations"></category><category term="debugging"></category><category term="delayedexecutions"></category><category term="deployment"></category><category term="djangocon"></category><category term="djangocon2010"></category><category term="documentation"></category><category term="migrations"></category><category term="safety"></category><category term="search"></category></entry><entry><title>Gestione di processi clinici in Python: un caso d'uso</title><link href="https://pyvideo.org/europython-2011/gestione-di-processi-clinici-in-python-un-caso-d.html" rel="alternate"></link><published>2011-07-18T00:00:00+00:00</published><updated>2011-07-18T00:00:00+00:00</updated><author><name>Federico Caboni</name></author><id>tag:pyvideo.org,2011-07-18:europython-2011/gestione-di-processi-clinici-in-python-un-caso-d.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Federico Caboni - 23 June 2011 in &amp;quot;Track Italiana Big
Mac &amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In questo seminario descriverò la nostra esperienza positiva d'uso di
Python per lo sviluppo di un sistema di etichettatura di provette per il
prelievo sanguigno in ambito di laboratorio e corsia ospedaliera. Il
sistema è basato sui Technical Framework di IHE –standard industriale
per la modellazione di processi clinici– ed è progettato per ridurre gli
errori umani e assicurare la tracciabilità del processo.&lt;/p&gt;
&lt;p&gt;Durante il seminario spiegherò perché abbiamo scelto Python in primo
luogo, e descriverò come siamo stati in grado di sfruttarne le
caratteristiche peculiari nello specifico del nostro dominio, esaminando
le limitazioni e i problemi affrontati.&lt;/p&gt;
&lt;p&gt;Mostrerò specifici casi d'uso di Python in parti differenti del
progetto, come un driver di basso livello per la gestione della robotica
di laboratorio, un modulo di comunicazione asincrona, l'implementazione
di attori IHE, e l'inevitabile applicazione web sviluppata in Django.&lt;/p&gt;
&lt;p&gt;Usare Python ha contribuito enormemente alla progettazione del sistema,
e ci ha consentito di adottare cicli di prototipizzazione estremamente
rapidi, sia per l'hardware che per il software. Durante il seminario
parlerò anche di ciò che, secondo noi, ancora manca perché Python possa
guadagnarsi il posto che gli spetta come piattaforma credibile per
l'implementazione di processi clinici basati sui più diffusi standard
internazionali.&lt;/p&gt;
</summary><category term="ci"></category><category term="framework"></category><category term="web"></category></entry><entry><title>Sqlkit: database ad accesso immediato</title><link href="https://pyvideo.org/europython-2011/sqlkit-database-ad-accesso-immediato.html" rel="alternate"></link><published>2011-07-18T00:00:00+00:00</published><updated>2011-07-18T00:00:00+00:00</updated><author><name>Alessandro Dentella</name></author><id>tag:pyvideo.org,2011-07-18:europython-2011/sqlkit-database-ad-accesso-immediato.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Alessandro Dentella - 21 June 2011 in &amp;quot;Track Italiana
Big Mac&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;È molto facile accedere ad un database con Python e ci sono molti ORM
che permettono un alto livello di astrazione. Da qui c'é ancora una
lunga strada per arrivare a manipolare interattivamente i dati anche per
semplici compiti.&lt;/p&gt;
&lt;p&gt;Sqlkit cerca di coprire questa distanza fornendo alcuni mega-widgets che
permettono di costruire ogni applicazione GUI o accedere direttamente ai
dati con l'applicazione 'sqledit', che viene distribuita con sqlkit.
Sqlkit è costruita con PyGTK e SQLAlchemy.&lt;/p&gt;
&lt;p&gt;Questa presentazione esplora alcune fra le più potenti caratteristiche
di sqlkit e mostra quanto sia semplice costruire piccoli programmini ad
uso personale o applicazioni ricche ed articolate. Si focalizza
principalmente su due punti: quanto sia facile creare maschere per
editare dati (anche relazioni on2many o many2many, grazie al modo
originale di definire i layout) e al sistema di template basato su
OpenOffice che rende incredibilmente semplice creare report.&lt;/p&gt;
&lt;p&gt;Questa presentazione vuole mostrare come sqlkit può essere usato sia
come framework di sviluppo di applicazioni, sia come strumento che ci
aiuta mentre sviluppiamo altre applicazioni (es.: Django, OpenERP,… ).&lt;/p&gt;
&lt;p&gt;Per rendere la presentazione più graduale, sfrutteremo il sistema di
configurazione di sqledit Partendo da una configurazione minima -un URL-
aggiungeremo elementi fino ad ottenere una vera applicazione.&lt;/p&gt;
</summary><category term="ci"></category><category term="database"></category><category term="framework"></category><category term="gui"></category><category term="openoffice"></category><category term="orm"></category></entry><entry><title>Come costruire un'azienda distribuita con Python</title><link href="https://pyvideo.org/europython-2011/come-costruire-unazienda-distribuita-con-python.html" rel="alternate"></link><published>2011-07-07T00:00:00+00:00</published><updated>2011-07-07T00:00:00+00:00</updated><author><name>Maurizio Delmonte</name></author><id>tag:pyvideo.org,2011-07-07:europython-2011/come-costruire-unazienda-distribuita-con-python.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Maurizio Delmonte - 22 June 2011 in &amp;quot;Track Italiana
Big Mac &amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Il nostro gruppo di lavoro, composto da varie figure professionali, da
anni lavora su più progetti in parallelo, e con team di persone che si
incontrano solo virtualmente.&lt;/p&gt;
&lt;p&gt;Non è sufficiente dire: facciamolo!&lt;/p&gt;
&lt;p&gt;Per non perdere la testa, gestire in modo agile i progetti e vivere
felici affiniamo continuamente le nostre tecniche di gestione e gli
strumenti che ci permettono di tenere sotto controllo la situazione:
Extreme Management tool, Poi Tracker, Buildout sono solo alcuni degli
strumenti che rendono il nostro lavoro fluido ed efficace.&lt;/p&gt;
&lt;p&gt;Presenterò le nostre modalità operative, dimostrando che lavorare con un
team composto da persone contemporaneamente a Milano, Napoli, Torino e
Ancona è possibile. Non solo: è il futuro!&lt;/p&gt;
</summary><category term="agile"></category><category term="ci"></category></entry><entry><title>Creare videogames con Panda3D</title><link href="https://pyvideo.org/europython-2011/creare-videogames-con-panda3d.html" rel="alternate"></link><published>2011-07-07T00:00:00+00:00</published><updated>2011-07-07T00:00:00+00:00</updated><author><name>Claudio Desideri</name></author><id>tag:pyvideo.org,2011-07-07:europython-2011/creare-videogames-con-panda3d.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Claudio Desideri - 21 June 2011 in &amp;quot;Track Italiana Big
Mac&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In questo talk spiegherò quali opportunità ci offre il game-engine
Panda3D nel momento in cui vogliamo creare un videogioco da zero.
Spiegherò com'è strutturato al suo interno e i concetti di base per
capire come funziona, ma mostrerò anche prove pratiche e pezzi di
codice.&lt;/p&gt;
&lt;p&gt;Può partecipare chiunque abbia una conoscenza di base di Python, anche
se non ha mai lavorato con applicazioni realtime 3D. L'obiettivo è
mostrare come creare un semplice videogioco che risponda agli input
immessi dall'utente e come utilizzare al meglio questo potente engine.&lt;/p&gt;
</summary><category term="ci"></category><category term="panda3d"></category><category term="python,"></category><category term="realtime"></category></entry><entry><title>Why not run all your tests all the time? A study of continuous integration systems (#160)</title><link href="https://pyvideo.org/pycon-us-2010/pycon-2010--why-not-run-all-your-tests-all-the-ti.html" rel="alternate"></link><published>2010-02-19T00:00:00+00:00</published><updated>2010-02-19T00:00:00+00:00</updated><author><name>C. Titus Brown</name></author><id>tag:pyvideo.org,2010-02-19:pycon-us-2010/pycon-2010--why-not-run-all-your-tests-all-the-ti.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Why not run all your tests at all the time? A study of continuous
integration systems&lt;/p&gt;
&lt;p&gt;Presented by Dr. C. Titus Brown (Michigan State University)&lt;/p&gt;
&lt;p&gt;There are an increasing number of continuous integration (CI) systems
available for use by Pythonistas, but no clear guide to how to choose a
CI system for your project. I will examine the architecture choices made
by buildbot, bitten, Hudson, continuum, CruiseControl, DART, and
pony-build, and discuss the configuration and customization of several
of these systems for Pythonic needs, as well as give short demos (for
buildbot, bitten, Hudson, and pony-build).&lt;/p&gt;
</summary><category term="bitten"></category><category term="buildbot"></category><category term="ci"></category><category term="cruisecontrol"></category><category term="dart"></category><category term="hudson"></category><category term="pony-build"></category><category term="pycon"></category><category term="pycon2010"></category><category term="testing"></category></entry><entry><title>Continuous deployment</title><link href="https://pyvideo.org/pycon-us-2011/pycon-2011--continuous-deployment.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Laurens Van Houtven</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--continuous-deployment.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Continuous deployment&lt;/p&gt;
&lt;p&gt;Presented by Laurens Van Houtven&lt;/p&gt;
&lt;p&gt;This talk is about continuous deployment practices and tools, lessons
learned from implementing it, and putting them into perspective. The
goal is to give other people tips and pointers for applying these ideas
themselves.&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;Continuous deployment is the practice of putting the latest revision of
software into production use all the time, as opposed to working towards
larger releases. The important difference is iteration time: whereas
large software packages produce new software in timeframes of years or
months, continuous deployment teams typically put new code into
production in timeframes of hours or less.&lt;/p&gt;
&lt;p&gt;The practice is slowly attracting a small but growing group of loyal
followers, just like continuous integration over the past few years and
test- driven development did before that. They can be explained in terms
of being natural extensions of each other. Like TDD and CI, CD gets eyed
somewhat suspiciously (and rightfully so: skeptical analysis is great),
but the undersigned believes there's a legitimate advantage for many
applications.&lt;/p&gt;
&lt;p&gt;Many years ago, TTD and testing tools in general were mostly ad-hockery.
Now, with many different production-quality testing tools, this has
become unthinkable. Similarly, continuous integration was something
other people did for a long time, but now we have tools such as Buildbot
and Hudson. Continuous deployment is still somewhat in the early stage
in terms of ready-to-use tools, but it's likely that we'll see a similar
evolution.&lt;/p&gt;
&lt;p&gt;Here's a rough outline of what I plan to cover:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;a short history of people developed software&lt;/li&gt;
&lt;li&gt;from the recent models to CD (sort of a working definition of CD
here)&lt;/li&gt;
&lt;li&gt;when is it a good idea? pros/cons&lt;/li&gt;
&lt;li&gt;requirements &amp;amp; battle plan for applying CD in an existing development
environment (and possibly code base)&lt;/li&gt;
&lt;li&gt;an overview of existing tools and how they work together&lt;/li&gt;
&lt;li&gt;caveat emptors, known pitfalls (deployment and recovery strategies go
here, since most implementations figure out they need them after
stuff blows up)&lt;/li&gt;
&lt;li&gt;questions! (hopefully lots of people who've tried or are thinking
about implementing something similar -- like I said, there are a lot
of people implementing it but not too many ideas being bounced
around)&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="cd"></category><category term="ci"></category><category term="continuousdeployment"></category><category term="deployment"></category><category term="pycon"></category><category term="pycon2011"></category><category term="softwaredevelopment"></category><category term="tdd"></category><category term="workflow"></category></entry><entry><title>Supporting All Versions of Python All The Time With Tox</title><link href="https://pyvideo.org/pycon-us-2011/pycon-2011--supporting-all-versions-of-python-all.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Kumar McMillan</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--supporting-all-versions-of-python-all.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Supporting All Versions of Python All The Time With Tox&lt;/p&gt;
&lt;p&gt;Presented by Kumar McMillan&lt;/p&gt;
&lt;p&gt;This talk explains the modern techniques that every module maintainer
needs to know in order to support all major versions of Python. You
probably already have a massive test suite using a tool like nosetests,
py.test, unittest, or a custom runner. Using the tox command line tool,
you'll see how to run your tests in Python 2.x, 3.x, Jython, and
whatever else in parallel.&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;tox is a new tool that lets you set up isolated virtual environments to
test your module's deployment and compatibility with all major versions
of Python. It's easy to install and is flexible enough that it probably
already supports your existing test suite. With one simple command you
can execute your test suite in each version of Python, you can build its
documentation with Sphinx, and get a nice printout of the results. It
has also been designed from the ground up to integrate into continuous
integration (CI) tools like Hudson.&lt;/p&gt;
&lt;p&gt;Using practical examples, this talk will show you how to toxify your
existing test suite and trick it out with the tox.ini config file.
You'll also see how to leverage Hudson's matrix build so that each code
checkin will run tests in all versions of Python and report detailed
failures.&lt;/p&gt;
&lt;p&gt;Your app supports Python 3, right? No? Tox is the best way to develop in
parallel with 2.x and 3.x. We'll go over how to set up tox for that.&lt;/p&gt;
</summary><category term="ci"></category><category term="hudson"></category><category term="pycon"></category><category term="pycon2011"></category><category term="testing"></category><category term="tox"></category></entry></feed>