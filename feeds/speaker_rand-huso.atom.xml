<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_rand-huso.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2015-09-05T00:00:00+00:00</updated><entry><title>Message Passing Interface and Inversion of Control</title><link href="https://pyvideo.org/kiwi-pycon-2015/message-passing-interface-and-inversion-of-contro.html" rel="alternate"></link><published>2015-09-05T00:00:00+00:00</published><updated>2015-09-05T00:00:00+00:00</updated><author><name>Rand Huso</name></author><id>tag:pyvideo.org,2015-09-05:kiwi-pycon-2015/message-passing-interface-and-inversion-of-contro.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The myriad of methods available for MPI programming is daunting by
itself, and largely unnecessary. The solutions proposed by the
developers of MPI and the new languages in this space are all addressing
the problem the way it's always been addressed. What I present is a way
to attack the massively parallel problem that reduces the complexity of
MPI programming to that of implementing a very simple state machine.
I've used this combination of MPI and IoC to write state-of-the-art
applications that run on some of the largest supercomputers around the
world.&lt;/p&gt;
</summary></entry></feed>