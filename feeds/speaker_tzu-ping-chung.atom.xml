<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_tzu-ping-chung.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2016-09-21T00:00:00+00:00</updated><entry><title>You Might Not Want Async (in Python)</title><link href="https://pyvideo.org/pycon-japan-2016/you-might-not-want-async-in-python.html" rel="alternate"></link><published>2016-09-21T00:00:00+00:00</published><updated>2016-09-21T00:00:00+00:00</updated><author><name>Tzu-ping Chung</name></author><id>tag:pyvideo.org,2016-09-21:pycon-japan-2016/you-might-not-want-async-in-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Async programming is hot®, but also difficult. Since Python is fundamentally designed for sequential (as in “not parallel”) programming, asynchrony doesn’t feel natural, and requires more mentally to comprehend than, say, a language that can go async directly (bad pun intended).
Abstract&lt;/p&gt;
&lt;p&gt;Asynchrony in Python had gathered much momentum recently, with interests from core developers, as evidenced by the introduction of &lt;tt class="docutils literal"&gt;asyncio&lt;/tt&gt; in Python 3.4, and a great boom of related third-party projects following it. By utilising more functionalities from the underlying operating system, it is a great solution to many existing problems in Python applications, gaining practical concurrency without working around the well-known GIL (global interpreter lock) problem.&lt;/p&gt;
&lt;p&gt;With all its advantages, asynchrony is, however, still a relatively new concept in Python, and as a result could be somewhat mistaken, even misunderstood by some people. One of these misconceptions, probably the most serious, is to mistake concurrency through asynchrony for parallelism. Although &lt;tt class="docutils literal"&gt;asyncio&lt;/tt&gt; (and other similar solutions) lets multiple parts of your program executes without interfering each other, it does not allow them to run together—this is still impossible, at least in CPython, due to the continued existence of the GIL. This makes asynchrony suitable for only a certain, instead of all, kinds of problems. Evaluation is therefore required before a programmer can decide whether the asynchrony model is suitable for a particular application.&lt;/p&gt;
&lt;p&gt;Furthermore, partly due to its relatively short existence, paradigms in asynchrony programming do not necessarily fit well with other parts of Python, including libraries, either built-in or third-party ones. Since only blocking libraries were available in most of Python’s history, many assumptions they made may not work well with async programs out-of-the-box. Adopting asynchrony, at least at the present time, will therefore introduce more technical debt to your program. These are all important aspects that require much consideration before you dive head-first into asynchrony.&lt;/p&gt;
</summary></entry><entry><title>You Might Not Want Async</title><link href="https://pyvideo.org/pycon-apac-2016/you-might-not-want-async.html" rel="alternate"></link><published>2016-08-31T00:00:00+00:00</published><updated>2016-08-31T00:00:00+00:00</updated><author><name>Tzu-ping Chung</name></author><id>tag:pyvideo.org,2016-08-31:pycon-apac-2016/you-might-not-want-async.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;발표자: Tzu-ping Chung
슬라이드: &lt;a class="reference external" href="https://speakerdeck.com/uranusjr/you-might-not-want-async"&gt;https://speakerdeck.com/uranusjr/you-might-not-want-async&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Asynchrony topics in Python had gain much momentum recently, with interests from core developers, as evidenced by the introduction of asyncio in Python 3.4, and a great boom of related third-party projects following it.&lt;/p&gt;
&lt;p&gt;With all its advantages, asynchrony is, however, still a relatively new concept in Python, and as a result could be somewhat mistaken, even misunderstood by some people. One of these misconceptions, probably the most serious, is to mistake concurrency through asynchrony with parallelism. Although asyncio (and other similar solutions) lets multiple parts of your program executes without interfering each other, it does not allow them to run together—this is still impossible, at least in CPython, due to the continued existence of the GIL (global interpreter lock). This makes asynchrony suitable for only a certain, instead of all, kinds of problems, and requires evaluation before a programmer can decide whether it is suitable for a particular application.&lt;/p&gt;
&lt;p&gt;Partly due to its relatively short existence, paradigms in asynchrony programming does not necessarily fit well with other parts of Python, including libraries, either built-in or third-party ones. Many assumptions made in parts of Python, and its vast amounts of libraries, may not work well with async programs out-of-the-box. Adopting asynchrony, at least at the present day, will therefore introduce more technical debt to your program. These are all important aspects that require much consideration before you jump head-first into asynchnocy.&lt;/p&gt;
</summary></entry><entry><title>Yielding a Tulip</title><link href="https://pyvideo.org/pycon-apac-2014/yielding-a-tulip-pycon-apac-2014.html" rel="alternate"></link><published>2014-08-11T00:00:00+00:00</published><updated>2014-08-11T00:00:00+00:00</updated><author><name>Tzu-ping Chung</name></author><id>tag:pyvideo.org,2014-08-11:pycon-apac-2014/yielding-a-tulip-pycon-apac-2014.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Asynchronised operations are good. Callbacks are not. Named callbacks
clutter scopes and are disruptive. Anonymous callbacks create deeply
nested code and become totally unreadable—Python does not even support
that because it just lacks style! We deserve better. Let's take a look
on how Python 3.4's new &amp;quot;asyncio&amp;quot; (aka Tulip) brings elegance to async
tasks.&lt;/p&gt;
&lt;p&gt;About the speaker&lt;/p&gt;
&lt;p&gt;TP is a professional software engineer enjoying building things. He
writes C++ because his boss pays him to do so, but loves Python and
constantly tries to sneak it into his work as much as he can.&lt;/p&gt;
&lt;p&gt;個人網頁連結&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://uranusjr.com/"&gt;https://uranusjr.com/&lt;/a&gt; Twitter &amp;#64;uranusjr 組織/公司 BIMETEK Co. Ltd. 頭銜
Lead Software Engineer&lt;/p&gt;
</summary></entry><entry><title>R0 DAY1-04 The Future of GUI Programming with Python - Tzu-ping Chung (PyCon APAC 2015)</title><link href="https://pyvideo.org/pycon-apac-2015/r0-day1-04-the-future-of-gui-programming-with-tzu.html" rel="alternate"></link><published>2015-08-24T00:00:00+00:00</published><updated>2015-08-24T00:00:00+00:00</updated><author><name>Tzu-ping Chung</name></author><id>tag:pyvideo.org,2015-08-24:pycon-apac-2015/r0-day1-04-the-future-of-gui-programming-with-tzu.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Speaker: Tzu-ping Chung&lt;/p&gt;
&lt;p&gt;Python is a great programming language suitable for a wide variety of purposes. Among all these exciting things, however, there is one area with which Python is not great: GUI applications. In this talk, we will first take a look at existed solutions for GUI programming in Python, comparing their characteristics and features. We will then discuss how GUI programming with Python should be done in an ideal world, and what can be done (or is being done) to take us one step closer to our ideal.&lt;/p&gt;
&lt;p&gt;About the speaker&lt;/p&gt;
&lt;p&gt;個人網頁連結&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://uranusjr.com/"&gt;https://uranusjr.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Twitter &amp;#64;uranusjr
組織/公司 BIMEtek Co. Ltd.
頭銜 Software Architect&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://tw.pycon.org/2015apac/zh/program/18"&gt;https://tw.pycon.org/2015apac/zh/program/18&lt;/a&gt;&lt;/p&gt;
</summary></entry></feed>