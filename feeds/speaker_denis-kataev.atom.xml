<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_denis-kataev.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2018-06-22T00:00:00+00:00</updated><entry><title>SQLAlchemy: Python vs Raw SQL</title><link href="https://pyvideo.org/pycon-russia-2018/sqlalchemy-python-vs-raw-sql.html" rel="alternate"></link><published>2018-06-22T00:00:00+00:00</published><updated>2018-06-22T00:00:00+00:00</updated><author><name>Денис Катаев</name></author><id>tag:pyvideo.org,2018-06-22:pycon-russia-2018/sqlalchemy-python-vs-raw-sql.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Денис Катаев&lt;/strong&gt; , Тинькофф&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://pycon.ru/2018/en/program/content/kataev/"&gt;**SQLAlchemy: Python vs Raw SQL**&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Мы ежедневно работаем с реляционными базами данных: изменяем объекты,
накатываем миграции, создаем индексы. Но иногда нужно агрегировать
данные по нескольким полям или хочется попробовать свежие возможности
реляционных баз данных, например, оператор Union. Django или PeeWee
умеют выражать только простые вещи, поэтому приходится использовать
сырой SQL.&lt;/p&gt;
&lt;p&gt;А вот библиотека SQLAlchemy может выразить любой сложный запрос на
чистом Питоне. Это позволяет писать понятный код и с легкостью его
рефакторить.&lt;/p&gt;
&lt;p&gt;Разберемся на примерах, как SQLAlchemy устроена изнутри, как она
упрощает нашу работу и когда стоит ее применять (спойлер — всегда).&lt;/p&gt;
</summary></entry></feed>