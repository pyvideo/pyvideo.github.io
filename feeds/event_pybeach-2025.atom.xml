<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org - PyBeach 2025</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/event_pybeach-2025.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2025-09-27T00:00:00+00:00</updated><subtitle></subtitle><entry><title>Back off and Give up: The Art of Graceful System Degradation</title><link href="https://pyvideo.org/pybeach-2025/back-off-and-give-up-the-art-of-graceful-system-degradation.html" rel="alternate"></link><published>2025-09-27T00:00:00+00:00</published><updated>2025-09-27T00:00:00+00:00</updated><author><name>Moshe Zadka</name></author><id>tag:pyvideo.org,2025-09-27:/pybeach-2025/back-off-and-give-up-the-art-of-graceful-system-degradation.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In distributed systems, how we handle failure is often more important than how we handle success. This talk challenges the &amp;quot;never give up&amp;quot; mentality by demonstrating why intelligent retreat strategies consistently outperform blind persistence when systems are under stress.&lt;/p&gt;
&lt;p&gt;We'll explore the powerful combination of exponential back-off with jitter …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In distributed systems, how we handle failure is often more important than how we handle success. This talk challenges the &amp;quot;never give up&amp;quot; mentality by demonstrating why intelligent retreat strategies consistently outperform blind persistence when systems are under stress.&lt;/p&gt;
&lt;p&gt;We'll explore the powerful combination of exponential back-off with jitter for managing retries, and explain why quickly &amp;quot;giving up&amp;quot; through strategic load shedding often leads to better overall system health than dogged persistence. We'll show how these complementary approaches can prevent cascading failures, improve user experience during degraded conditions, and help systems recover faster.&lt;/p&gt;
</content><category term="PyBeach 2025"></category></entry><entry><title>In Memorium: Goodwill</title><link href="https://pyvideo.org/pybeach-2025/in-memorium-goodwill.html" rel="alternate"></link><published>2025-09-27T00:00:00+00:00</published><updated>2025-09-27T00:00:00+00:00</updated><author><name>Esther Nam</name></author><id>tag:pyvideo.org,2025-09-27:/pybeach-2025/in-memorium-goodwill.html</id><content type="html"></content><category term="PyBeach 2025"></category></entry><entry><title>Keynote</title><link href="https://pyvideo.org/pybeach-2025/keynote.html" rel="alternate"></link><published>2025-09-27T00:00:00+00:00</published><updated>2025-09-27T00:00:00+00:00</updated><author><name>Carol Willing</name></author><id>tag:pyvideo.org,2025-09-27:/pybeach-2025/keynote.html</id><content type="html"></content><category term="PyBeach 2025"></category></entry><entry><title>pathlib: why and how to use it</title><link href="https://pyvideo.org/pybeach-2025/pathlib-why-and-how-to-use-it.html" rel="alternate"></link><published>2025-09-27T00:00:00+00:00</published><updated>2025-09-27T00:00:00+00:00</updated><author><name>Trey Hunner</name></author><id>tag:pyvideo.org,2025-09-27:/pybeach-2025/pathlib-why-and-how-to-use-it.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;If your Python code works with file paths, you should be using &lt;cite&gt;pathlib&lt;/cite&gt;. This standard library module may seem a bit cumbersome at first, but &lt;cite&gt;pathlib&lt;/cite&gt;-using code is often more readable the alternative.&lt;/p&gt;
&lt;p&gt;Python's many path-oriented utilities used to expect a string representation for all file paths. That's …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;If your Python code works with file paths, you should be using &lt;cite&gt;pathlib&lt;/cite&gt;. This standard library module may seem a bit cumbersome at first, but &lt;cite&gt;pathlib&lt;/cite&gt;-using code is often more readable the alternative.&lt;/p&gt;
&lt;p&gt;Python's many path-oriented utilities used to expect a string representation for all file paths. That's not the case anymore. Now, every important path-consuming library will accept &lt;cite&gt;pathlib.Path&lt;/cite&gt; objects.&lt;/p&gt;
&lt;p&gt;During this talk, we'll see why &lt;cite&gt;pathlib.Path&lt;/cite&gt; objects make for more maintainable code. We'll visit a number of useful &lt;cite&gt;pathlib&lt;/cite&gt; examples and recipes along the way.&lt;/p&gt;
&lt;p&gt;By the end of this talk, you'll be tempted to convert all your path-handling code to use &lt;cite&gt;pathlib&lt;/cite&gt;.&lt;/p&gt;
</content><category term="PyBeach 2025"></category></entry><entry><title>Patterns and Anti-patterns in Python's Structural Pattern Matching</title><link href="https://pyvideo.org/pybeach-2025/patterns-and-anti-patterns-in-pythons-structural-pattern-matching.html" rel="alternate"></link><published>2025-09-27T00:00:00+00:00</published><updated>2025-09-27T00:00:00+00:00</updated><author><name>Brett Slatkin</name></author><id>tag:pyvideo.org,2025-09-27:/pybeach-2025/patterns-and-anti-patterns-in-pythons-structural-pattern-matching.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Have you used Python's &lt;cite&gt;match&lt;/cite&gt; statement? How do you decide when to use &lt;cite&gt;match&lt;/cite&gt; instead of a typical &lt;cite&gt;if&lt;/cite&gt;/&lt;cite&gt;elif&lt;/cite&gt;/&lt;cite&gt;else&lt;/cite&gt; statement? Although structural pattern matching functionality has been available in Python for years, many Python developers still aren't sure about the best way to employ &lt;cite&gt;match&lt;/cite&gt; in their …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Have you used Python's &lt;cite&gt;match&lt;/cite&gt; statement? How do you decide when to use &lt;cite&gt;match&lt;/cite&gt; instead of a typical &lt;cite&gt;if&lt;/cite&gt;/&lt;cite&gt;elif&lt;/cite&gt;/&lt;cite&gt;else&lt;/cite&gt; statement? Although structural pattern matching functionality has been available in Python for years, many Python developers still aren't sure about the best way to employ &lt;cite&gt;match&lt;/cite&gt; in their own programs.&lt;/p&gt;
&lt;p&gt;This talk will explore effective patterns that work well with the new &lt;cite&gt;match&lt;/cite&gt; statement, and common pitfalls to avoid. It will highlight when &lt;cite&gt;if&lt;/cite&gt;/&lt;cite&gt;elif&lt;/cite&gt;/&lt;cite&gt;else&lt;/cite&gt; constructs are a better fit, and how to judge when it's time to consider moving from one style to another. The talk will also cover other approaches to matching patterns, including look-up tables for performance and unpacking for sequences.&lt;/p&gt;
&lt;p&gt;After attending this talk, you'll be able to confidently use the &lt;cite&gt;match&lt;/cite&gt; statement to enhance your programs and discern when &lt;cite&gt;match&lt;/cite&gt; will harm the readability of your code.&lt;/p&gt;
</content><category term="PyBeach 2025"></category></entry><entry><title>Python Packaging Expressway: A Path Worth Taking</title><link href="https://pyvideo.org/pybeach-2025/python-packaging-expressway-a-path-worth-taking.html" rel="alternate"></link><published>2025-09-27T00:00:00+00:00</published><updated>2025-09-27T00:00:00+00:00</updated><author><name>Parul Gupta</name></author><id>tag:pyvideo.org,2025-09-27:/pybeach-2025/python-packaging-expressway-a-path-worth-taking.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python's popularity comes from its vast ecosystem of open-source packages, especially for the development for AI modeling and support. However, many Python programmers struggle to share their scripts and packages with others due to a lack of understanding about Python packaging.
Join me on a journey to demystify modern …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python's popularity comes from its vast ecosystem of open-source packages, especially for the development for AI modeling and support. However, many Python programmers struggle to share their scripts and packages with others due to a lack of understanding about Python packaging.
Join me on a journey to demystify modern Python packaging and learn the end-to-end mechanism of creating, publishing, and managing Python packages. Whether you are new to Python packaging or want to sharpen your skills around modern Python packaging techniques or are a curious Pythonista, I hope for everyone to learn something new here or just have fun with packaging!&lt;/p&gt;
</content><category term="PyBeach 2025"></category></entry><entry><title>Real-Time Collaborative Sessions for New Contributors *and* Maintainers</title><link href="https://pyvideo.org/pybeach-2025/real-time-collaborative-sessions-for-new-contributors-and-maintainers.html" rel="alternate"></link><published>2025-09-27T00:00:00+00:00</published><updated>2025-09-27T00:00:00+00:00</updated><author><name>Laura Langdon</name></author><id>tag:pyvideo.org,2025-09-27:/pybeach-2025/real-time-collaborative-sessions-for-new-contributors-and-maintainers.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;New contributors and maintainers new to accepting contributions face surprisingly similar challenges: anxiety about &amp;quot;getting it right&amp;quot;, unclear expectations, and unwritten cultural norms. This talk presents a practical model for real-time collaborative sessions that address both groups' needs simultaneously, creating stronger, more welcoming open source communities from day one …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;New contributors and maintainers new to accepting contributions face surprisingly similar challenges: anxiety about &amp;quot;getting it right&amp;quot;, unclear expectations, and unwritten cultural norms. This talk presents a practical model for real-time collaborative sessions that address both groups' needs simultaneously, creating stronger, more welcoming open source communities from day one.&lt;/p&gt;
</content><category term="PyBeach 2025"></category></entry><entry><title>Shipping means keeping the boat afloat: why engineering quality matters</title><link href="https://pyvideo.org/pybeach-2025/shipping-means-keeping-the-boat-afloat-why-engineering-quality-matters.html" rel="alternate"></link><published>2025-09-27T00:00:00+00:00</published><updated>2025-09-27T00:00:00+00:00</updated><author><name>Esther Nam</name></author><id>tag:pyvideo.org,2025-09-27:/pybeach-2025/shipping-means-keeping-the-boat-afloat-why-engineering-quality-matters.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;More software is being produced today than ever before. Good software developers want to maintain high standards for quality, but may find it challenging to do so in the face of day-to-day pressures, deadlines, and distractions. Non-developers may feel it's acceptable to stop short of full engineering practice. In …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;More software is being produced today than ever before. Good software developers want to maintain high standards for quality, but may find it challenging to do so in the face of day-to-day pressures, deadlines, and distractions. Non-developers may feel it's acceptable to stop short of full engineering practice. In this talk we'll explore what engineering rigor looks like and discuss ways to uphold standards, even in the face of resistance. Attendees should come away with an understanding that engineering quality is more than just an ideal worth striving for, but a pragmatic way to keep our users happy, and to stay productive without burning out.&lt;/p&gt;
</content><category term="PyBeach 2025"></category></entry><entry><title>The Paradox of Statically Typed Python &amp; Polymorphic C</title><link href="https://pyvideo.org/pybeach-2025/the-paradox-of-statically-typed-python-polymorphic-c.html" rel="alternate"></link><published>2025-09-27T00:00:00+00:00</published><updated>2025-09-27T00:00:00+00:00</updated><author><name>Christopher Ariza</name></author><id>tag:pyvideo.org,2025-09-27:/pybeach-2025/the-paradox-of-statically-typed-python-polymorphic-c.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python implements dynamic type behavior using a statically typed language (C), only to then offer static type annotations on top of a dynamically typed language (Python). This paradox is the focus of this talk. We will look at the basics of type annotations, how polymorphism is implemented in C …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python implements dynamic type behavior using a statically typed language (C), only to then offer static type annotations on top of a dynamically typed language (Python). This paradox is the focus of this talk. We will look at the basics of type annotations, how polymorphism is implemented in C with &lt;cite&gt;PyObject&lt;/cite&gt; and &lt;cite&gt;PyObject_HEAD&lt;/cite&gt;, and how CPython API functions like  &lt;cite&gt;PyObject_TypeCheck()&lt;/cite&gt; work. Despite the chasm between type annotations and runtime reality, their benefits will be demonstrated.&lt;/p&gt;
</content><category term="PyBeach 2025"></category></entry></feed>