<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org - abstractions</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Fri, 03 Jun 2022 00:00:00 +0000</lastBuildDate><item><title>Don't start with a database</title><link>https://pyvideo.org/europython-2019/dont-start-with-a-database.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;What you do when you start a new project? Usually, we begin with
database design, then we prepare a migration system, user registration,
and all different stuff that distracts us from doing what is most
important - business logic. With the clean architecture, we can learn
how to start a project in another way and this will be one of two main
topics of my talk. The second one will be about new features in Python.
You probably heard about typings, mypy, and dataclasses, but I will show
you how they can be used in real life project that can be developed over
many years in production lifecycle. There will be no &amp;quot;hello world&amp;quot; app,
no copy &amp;amp; paste of documentation, only practical knowledge learned
through many years of practice.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Grzegorz Kocjan</dc:creator><pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-07-12:/europython-2019/dont-start-with-a-database.html</guid><category>EuroPython 2019</category><category>APIs</category><category>Abstractions</category><category>Architecture</category><category>Best Practice</category><category>Clean Code</category></item><item><title>Software patterns for productive teams</title><link>https://pyvideo.org/europython-2019/software-patterns-for-productive-teams.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Software development is a team game.&lt;/p&gt;
&lt;p&gt;When we want to deliver more work, one of the variables that we can
change is the team size. But as we all know, increasing the team size
does not automatically translate into increased productivity &amp;amp; more
features shipped.&lt;/p&gt;
&lt;p&gt;If things are left unmanaged, people can step on each other toes, block
each other &amp;amp; generally decrease the overall productivity of a given
software project.&lt;/p&gt;
&lt;p&gt;In this talk we'll identify different problems teams can face &amp;amp; see how
we can solve them using different strategies &amp;amp; patterns.&lt;/p&gt;
&lt;p&gt;In the end, we want to enable the team to perform better &amp;amp; ship features
with high confidence. We want enable the team &amp;amp; put its potential into
building good software.&lt;/p&gt;
&lt;p&gt;Problems we are going to cover:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Constant merge conflicts / working in the same files&lt;/li&gt;
&lt;li&gt;Blocking each other on different features / Feature deadlock&lt;/li&gt;
&lt;li&gt;Constantly switching between bugfixing &amp;amp; feature development&lt;/li&gt;
&lt;li&gt;Constant regressions and things breaking down&lt;/li&gt;
&lt;li&gt;Fighting with local setup &amp;amp; not being able to properly test things,
especially when working with 3rd parties&lt;/li&gt;
&lt;li&gt;Merge strategies &amp;amp; improving the work with git &amp;amp; GitHub&lt;/li&gt;
&lt;li&gt;Communication between team members &amp;amp; ego fights&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For each problem, we are going to propose different solutions with
provided real-life examples from our experience &amp;amp; projects.&lt;/p&gt;
&lt;p&gt;The examples show are going to be in the context of large Python /
Django projects.&lt;/p&gt;
&lt;p&gt;This talk is the natural sequel of the following talks from previous
EuroPythons:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;EuroPython 2017 - Practical Debugging - Tips, Tricks and Ways to
think - &lt;a class="reference external" href="https://www.youtube.com/watch?v=9Ys4gCUtTh8"&gt;https://www.youtube.com/watch?v=9Ys4gCUtTh8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;EuroPython 2018 - Django structure for scale and longevity -
&lt;a class="reference external" href="https://www.youtube.com/watch?v=yG3ZdxBb1oo"&gt;https://www.youtube.com/watch?v=yG3ZdxBb1oo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Radoslav Georgiev</dc:creator><pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-07-12:/europython-2019/software-patterns-for-productive-teams.html</guid><category>EuroPython 2019</category><category>Abstractions</category><category>Best Practice</category><category>Communication</category><category>Django Projects</category><category>Management</category></item><item><title>The soul of the beast</title><link>https://pyvideo.org/europython-2019/the-soul-of-the-beast.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;div class="section" id="why"&gt;
&lt;h4&gt;Why&lt;/h4&gt;
&lt;p&gt;The audience will discover one of the core pieces of the language that
sits at the middle of the decisions about what new rules can or cannot
be implemented in the Python programming language. They will learn how
the particularities of the grammar limit what can be achieved but also
serve to maintain the language consistent, powerful but straightforward.
Attendants will learn how core developers solved some challenging
scenarios that arise as a consequence of said limitations or how others
cannot be resolved unless Python gets a significant transformation in
the internal mechanism that parses the grammar. Finally, they will learn
how a new rule is added to the CPython grammar, serving as a perfect
example of how all the pieces come together. In summary, the audience
will gain a more technical response to why people perceive the Python
programming language as easy but powerful one and at the same time will
gain some insight on how to understand and extend the pieces that form
it. This talk will not only help members of the audience understand
better the design of the language a how grammars and parser work, but
will also help people wanting to contribute to CPython understanding the
general structure of the compiler pipeline and how to work on it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="who"&gt;
&lt;h4&gt;Who&lt;/h4&gt;
&lt;p&gt;This talk is for those that want to understand Python a bit deeper: not
only how everything works under the hood but also what are the technical
decisions in its making and what are the consequences. The talk is
targeted to all Python programmers, no matter the skill level as
everyone will find something for their particular level of expertise:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Beginner programmers will be introduced in the topic of language
grammars and will learn what a Grammar is and what are the building
blocks. Also, the audience members in this level will gain insight into
how everything is thread together in CPython.&lt;/li&gt;
&lt;li&gt;Medium and advanced programmers will learn some in-depth technical
details and how they relate to features they already know and
understand. The talk not only will try to enlight some new areas related
to grammar technicalities, parser features and design and CPython
implementation details but will also connect many pieces of information
to explain how the small technical decisions impact the bigger picture.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="outline"&gt;
&lt;h4&gt;Outline&lt;/h4&gt;
&lt;p&gt;Who am I&lt;/p&gt;
&lt;p&gt;What is the Python Grammar&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;What is grammar?&lt;/li&gt;
&lt;li&gt;How they look like.&lt;/li&gt;
&lt;li&gt;Elements: terminal symbols, nonterminal symbols, productions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The properties of Python Grammar?&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Leftmost derivation&lt;/li&gt;
&lt;li&gt;1 token lookahead&lt;/li&gt;
&lt;li&gt;No epsilon productions! (Plus what epsilon productions are)&lt;/li&gt;
&lt;li&gt;Some immediate consequences of these properties.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;How the Python parser generator works&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;General structure of the parser generator.&lt;/li&gt;
&lt;li&gt;Non Deterministic Finite Automata&lt;/li&gt;
&lt;li&gt;Deterministic Finite Automata.&lt;/li&gt;
&lt;li&gt;Some examples (with cool graphs!) generated from the
python grammar and the parser generator of the actual
finite automatas that Python uses.&lt;/li&gt;
&lt;li&gt;Concrete syntax trees.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Advantages of the grammar (or &amp;quot;why Python is so easy to understand)&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;LL(1) grammars are context-free (no state to maintain while
parsing).&lt;/li&gt;
&lt;li&gt;LL(1) grammars are simple to implement and very fast to parse.&lt;/li&gt;
&lt;li&gt;LL(1) grammars are very limited, keeping the language simple&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Disadvantages of the grammar:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Grammar ambiguity.&lt;/li&gt;
&lt;li&gt;LL(1) grammars need some hacks for very simple things.&lt;/li&gt;
&lt;li&gt;How keyword arguments were incorporated in the grammar with a hack:
The grammar rule is very strange because it is &amp;quot;fixed&amp;quot; in the Abstract
syntax tree&lt;/li&gt;
&lt;li&gt;Why parenthesized with statements cannot be implemented (with
statements
formed of multiple elements surrounded by parenthesis and separated by
commas).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Implementing a new grammar rule in CPython: the arrow operator :&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;A complete mini-tutorial on how to introduce a new operator: A -&amp;gt; B
that gets executed as A.&lt;strong&gt;rarrow&lt;/strong&gt;(B).&lt;/li&gt;
&lt;li&gt;Altering the grammar and generating the new parser.&lt;/li&gt;
&lt;li&gt;Introducing a new token.&lt;/li&gt;
&lt;li&gt;Changing the tokenizer.&lt;/li&gt;
&lt;li&gt;Changing the Abstract Syntax Tree Generator.&lt;/li&gt;
&lt;li&gt;Changing the compiler.&lt;/li&gt;
&lt;li&gt;Implementing the new opcode.&lt;/li&gt;
&lt;li&gt;Implementing the &lt;strong&gt;rarrow&lt;/strong&gt; protocol.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The future and summary of the talk:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;We have been discussing in the CPython discourse to change the
parser generator to something
more powerful.&lt;/li&gt;
&lt;li&gt;Dangers and advantages of other parser generators.&lt;/li&gt;
&lt;li&gt;What other implementations are using?&lt;/li&gt;
&lt;li&gt;Summary of the talk&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Pablo Salgado</dc:creator><pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-07-12:/europython-2019/the-soul-of-the-beast.html</guid><category>EuroPython 2019</category><category>Abstractions</category><category>CPython</category><category>Performance</category><category>python</category></item><item><title>Clean Architectures in Python</title><link>https://pyvideo.org/europython-2020/clean-architectures-in-python.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;A practical approach to better software design&lt;/p&gt;
&lt;p&gt;Architectural considerations are often overlooked by developers or completely delegated to a framework. We should start once again discussing how applications are structured, how components are connected and how to lower coupling between different parts of a system, to avoid creating software that cannot easily be maintained or changed.&lt;/p&gt;
&lt;p&gt;The “clean architecture” model predates Robert Martin, who recently brought it back to the attention of the community, and is a way of structuring applications that leverages layers separation and internal APIs to achieve a very tidy, fully-tested, and loosely coupled system. The talk introduces the main ideas of the architecture, showing how the layers can be implemented in Python, following the content of the book “Clean Architectures in Python”. The book recently reached 11,000 downloads and many readers found it useful to start learning how to test software and how to structure an application without relying entirely on the framework.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Leonardo Giordani</dc:creator><pubDate>Thu, 23 Jul 2020 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2020-07-23:/europython-2020/clean-architectures-in-python.html</guid><category>EuroPython 2020</category><category>europython</category><category>europython-2020</category><category>europython-online</category><category>Abstractions</category><category>Architecture</category><category>Clean Code</category><category>Development</category><category>TDD</category></item><item><title>Flasync Await</title><link>https://pyvideo.org/europython-2020/flasync-await.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Async is all the rage, mostly because it simplifies waiting for an operation that takes some time to finish. Python went all in on asyncio by changing the language to support it (async/await) iIn this microservices era where many of the applications we develop consume several 3rd party API services, async is the fast track to success. In this talk, I’ll demonstrate the benefits of going async for a web application, justify choosing Sanic over other web frameworks like aiohttp. I’ll do so by transforming a Flask backed application to a Sanic backed application. Finally, I’ll provide tips &amp;amp; tricks from my experience on measuring, monitoring and testing async code.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">David Bordeynik</dc:creator><pubDate>Thu, 23 Jul 2020 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2020-07-23:/europython-2020/flasync-await.html</guid><category>EuroPython 2020</category><category>europython</category><category>europython-2020</category><category>europython-online</category><category>ASYNC / Concurreny</category><category>Abstractions</category><category>Best Practice</category><category>Web</category></item><item><title>How to write multi-paradigm code</title><link>https://pyvideo.org/europython-2020/how-to-write-multi-paradigm-code.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;... without making a mess&lt;/p&gt;
&lt;p&gt;Python is a powerful multi-paradigm language which combines elements of object-orientation and functional programming. Both concepts can be really powerful if used right. But what if you use them together? It can be pragmatic and very efficient, but things can also get messy really quickly.&lt;/p&gt;
&lt;p&gt;This talk explores peaceful co-existence of oo-classes and pure functions in the same code base. The focus is on identifying the right tool for the right job and bringing together the best of both. The main topics are:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Code Structure&lt;/li&gt;
&lt;li&gt;Data Structures&lt;/li&gt;
&lt;li&gt;State Handling&lt;/li&gt;
&lt;li&gt;Multiple implementations&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Prerequisites:
There are no formal prerequisites for this course, although it is recommended that participants have a strong background in Python and its code structuring mechanisms, as well as a deep understanding of at least one of the paradigms of OOP and FP.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Elias Mistler</dc:creator><pubDate>Thu, 23 Jul 2020 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2020-07-23:/europython-2020/how-to-write-multi-paradigm-code.html</guid><category>EuroPython 2020</category><category>europython</category><category>europython-2020</category><category>europython-online</category><category>Abstractions</category><category>Architecture</category><category>Best Practice</category><category>Clean Code</category><category>Functional Programming</category></item><item><title>Pluggable Architecture</title><link>https://pyvideo.org/europython-2020/pluggable-architecture.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Extend functionality without touching existing code&lt;/p&gt;
&lt;p&gt;Applications and libraries with a pluggable architecture allow developers to add custom functionality. Plugins can customize user interfaces, create new workflows, and interface with legacy systems. Designing a plugin is often difficult - documentation is sparse, outdated, or non-existent. You end up diving into a unfamiliar codebase to figure out what to do.&lt;/p&gt;
&lt;p&gt;This talk examines Pluggable Architecture by creating a custom plugin system: we will design an interface, think about where to hook in custom behavior, and discuss testing techniques. Understanding these principles will enable us to write custom plugins for third-party libraries. Extend the functionality of your favourite library without touching existing code!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Aly Sivji</dc:creator><pubDate>Thu, 23 Jul 2020 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2020-07-23:/europython-2020/pluggable-architecture.html</guid><category>EuroPython 2020</category><category>europython</category><category>europython-2020</category><category>europython-online</category><category>Abstractions</category><category>Architecture</category><category>Development</category><category>Software Design</category><category>System Architecture</category></item><item><title>Yet another package for multi-tenancy in Django</title><link>https://pyvideo.org/europython-2020/yet-another-package-for-multi-tenancy-in-django.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Exploring the challenges of having multi-tenancy in the Django web framework&lt;/p&gt;
&lt;p&gt;Django is a popular, solid web framework for perfectionists with deadlines, with a wide ecosystem of packages that extend its powers in multiple directions. In the era of peaking popularity of Node/Deno, microservices, and heavyweight browser rendered webapps, Django still remains a triumphant monolith maker, very capable of major undertakings in the web arena.&lt;/p&gt;
&lt;p&gt;For all you Django-lovers out there, it seems to me like a matter of time before you have to do some form of multi-tenancy in Django. Taking a solution that works well for one tenant and extending it to multiple tenants should still be a problem for perfectionists with deadlines. Interestingly, when it comes to covering all the many facets of multi-tenancy, Django can be not so batteries included, as one might end up working around or 'hacking' the framework in order to get things done.&lt;/p&gt;
&lt;p&gt;In this talk I will walk you through the challenges of bringing multi-tenancy to a Django project. We'll cover the fundamental plumbing required to make it work reliably, securely, and elegantly. You will be expected to have a basic knowledge of Django (models, settings, users, URL reversing), and you will learn the working logic behind popular multi-tenancy packages like [django-tenant-schemas](&lt;a class="reference external" href="https://github.com/bernardopires/django-tenant-schemas"&gt;https://github.com/bernardopires/django-tenant-schemas&lt;/a&gt;) and [django-tenants](&lt;a class="reference external" href="https://github.com/tomturner/django-tenants"&gt;https://github.com/tomturner/django-tenants&lt;/a&gt;).&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Lorenzo Peña</dc:creator><pubDate>Thu, 23 Jul 2020 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2020-07-23:/europython-2020/yet-another-package-for-multi-tenancy-in-django.html</guid><category>EuroPython 2020</category><category>europython</category><category>europython-2020</category><category>europython-online</category><category>Abstractions</category><category>Architecture</category><category>Databases</category><category>Django</category><category>Django Projects</category></item><item><title>Librerie Python per Explainable Artificial Intelligence</title><link>https://pyvideo.org/pycon-italia-2022/librerie-python-per-explainable-artificial-intelligence.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Librerie Python per Explainable Artificial Intelligence - PyCon Italia
2022&lt;/p&gt;
&lt;p&gt;Alcuni modelli di Intelligenza Artificiale creano black-box in cui è
difficile capire come decidono. IA spiegabile (XAI) descrive il
funzionamento con modelli di spiegazione e visualizzazione dei dati, per
creare fiducia nei risultati. Il talk presenta librerie XAI, righe di
codice ed esempi di uso. Alcuni modelli di Intelligenza Artificiale
creano black-box in cui si può conoscere input e output, ma è difficile
capire come generano le decisioni al loro interno, tanto da renderli
inutili per risolvere certi problemi. IA spiegabile (XAI) descrive il
funzionamento con modelli di spiegazione e visualizzazione dei dati, per
creare fiducia nei risultati e gestire il rischio di malfunzionamento.
Perciò, XAI è una importante linea di ricerca e sviluppo. Il talk
presenta librerie XAI, righe di codice ed esempi di uso riguardanti:
Shap, Lime, Shapash, ExplainerDashboard, Dalex, ELI5. Link dove
scaricare le slide&lt;/p&gt;
&lt;p&gt;Speaker: Roberto Marmo&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Roberto Marmo</dc:creator><pubDate>Fri, 03 Jun 2022 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2022-06-03:/pycon-italia-2022/librerie-python-per-explainable-artificial-intelligence.html</guid><category>PyCon Italia 2022</category><category>abstractions</category><category>machine learning</category><category>performance</category><category>predictions</category></item><item><title>Modern Python: Alla scoperta delle ultime novità di (C)Python</title><link>https://pyvideo.org/pycon-italia-2022/modern-python-alla-scoperta-delle-ultime-novita-di-cpython.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Modern Python: Alla scoperta delle ultime novità di (C)Python - PyCon
Italia 2022&lt;/p&gt;
&lt;p&gt;Vi siete mai chiesti se ci fosse un modo migliore di scrivere il vostro
codice? Una qualche feature di Python oscura di cui eravate all’oscuro?
Sì? Ebbene, insieme demistificheremo alcune delle ultime feature più
interessanti e più sottovalutate del vecchio serpentone: sarà uno
spasso, promesso! Modern Python: Alla scoperta delle ultime novità di
(C)Python&lt;/p&gt;
&lt;p&gt;Pubblico Consigliato&lt;/p&gt;
&lt;p&gt;Questa presentazione è diretta a sviluppatori Python con almeno qualche
anno di esperienza sulle spalle e che siano interessati a rendere il
proprio codice più leggibile, idiomatico e magari anche più &lt;em&gt;veloce&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Introduzione Vi siete mai trovati a dover scrivere codice simile a
questo:&lt;/p&gt;
&lt;pre class="code python literal-block"&gt;
&lt;span class="n"&gt;some_var&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;some_function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;some_var&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;    &lt;span class="o"&gt;...&lt;/span&gt;    &lt;span class="n"&gt;Code&lt;/span&gt; &lt;span class="n"&gt;Here&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;e aver pensato: &lt;em&gt;”Cavolo, quell’assegnamento sembra proprio di
troppo!”&lt;/em&gt;? Se la risposta è sì, allora questa presentazione fa per voi!
Vi mostrerò come migliorare l’estetica, e magari anche la performance,
del vostro codice, mantenendo la medesima funzionalità. Imparerete
concetti avanzati quali i generatori asincroni, introdotti nel lontano
Python 3.6, il mitico operatore “tricheco”, la nuova e scintillante
istruzione &lt;tt class="docutils literal"&gt;match&lt;/tt&gt;, per un efficiente ed elegante pattern matching, ed
altro ancora: Sarà una figata, promesso!&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;Immagino già che qualcuno di voi si stia chiedendo, &lt;em&gt;”Ma, Matt, Python
3.6? É vecchissimo! Perchè sei venuto a parlarci di una feature
introdotta nel 2016?”&lt;/em&gt;: Okay, diciamo che ho mentito (giusto un
pochino).&lt;/p&gt;
&lt;p&gt;Non tutte le funzionalità di cui parlerò in questa presentazione sono
&lt;em&gt;esattamente&lt;/em&gt; nuove di zecca, ma ho sempre avuto la sensazione che
alcune— specialmente i generatori asincroni— non abbiano mai ricevuto
l’attenzione che meritavano e che siano andate piuttosto in sordina: ciò
è stato probabilmente dovuto dal rilascio di Python 3.5 (che per
rinfrescarvi la memoria ha finalmente standardizzato la programmazione
asincrona, introducendo il concetto di coroutine e vari altri nuovi
oggetti), e con questa presentazione vorrei rendere loro giustizia e al
tempo stesso far notare alcune delle (spesso ben nascoste!) trappole in
cui si può cadere facendone uso. Giusto per dare un’assaggio degli
argomenti che voglio trattare, ecco cosa spero impariate dalla
presentazione: - Migliorare le performance del vostro codice,
parallelizzando le operazioni di I/O basata su file, utilizzando un solo
thread grazie all’aiuto dei generatori asincroni - Risparmiare prezioso
spazio e tempo sostituendo &lt;tt class="docutils literal"&gt;typing.Union[A, B, C]&lt;/tt&gt; con il suo
(magnificamente idiomatico) equivalente &lt;tt class="docutils literal"&gt;A | B | C&lt;/tt&gt; - Imparare la
maniera &lt;em&gt;”Pythonica”&lt;/em&gt; di effettuare pattern matching grazie all’uso
della nuova istruzione &lt;tt class="docutils literal"&gt;match&lt;/tt&gt; introdotta in Python 3.10. Potete dire
finalmente addio a codice del tipo
&lt;tt class="docutils literal"&gt;python&amp;nbsp; cases = {1: &amp;quot;one&amp;quot;, 2: &amp;quot;two&amp;quot;, 3: &amp;quot;three&amp;quot;}&amp;nbsp; one_two_three = cases.get(some_var, default_value)&lt;/tt&gt;
- Altro ancora! Ma vi toccherà venire alla presentazione per scoprirlo
:)&lt;/p&gt;
&lt;p&gt;Speaker: Mattia Giambirtone&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Mattia Giambirtone</dc:creator><pubDate>Fri, 03 Jun 2022 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2022-06-03:/pycon-italia-2022/modern-python-alla-scoperta-delle-ultime-novita-di-cpython.html</guid><category>PyCon Italia 2022</category><category>abstractions</category><category>best practice</category><category>clean code</category><category>cpython</category><category>performance</category><category>type hinting</category></item><item><title>Optimal design &amp; control of a telecommunications network</title><link>https://pyvideo.org/pycon-italia-2022/optimal-design-control-of-a-telecommunications-network.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Optimal design &amp;amp; control of a telecommunications network - PyCon Italia
2022&lt;/p&gt;
&lt;p&gt;Everyone wants to go faster on the Internet, or design faster networks.
You can throw a lot of money to it or you can squeeze every bit from it.
I’ll show through a research project how can we do the latter and create
better networks. These two years have shown big weaknesses in the design
and usage of the Internet and many other important enterprise networks.
A good Quality of Experience and cost-effectiveness are paramount for
network operators and designers. Enter optimal design and control…
Through the use of optimal control it’s possibile to double the
performance with respect to how it’s operated today, furthermore it
allows us to better organize the network in order to minimally distrupt
the users in the event of a failure. I’ll show through two examples the
algorithms, the theory behind them and the code.&lt;/p&gt;
&lt;p&gt;Speaker: Andi Dulla&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Andi Dulla</dc:creator><pubDate>Fri, 03 Jun 2022 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2022-06-03:/pycon-italia-2022/optimal-design-control-of-a-telecommunications-network.html</guid><category>PyCon Italia 2022</category><category>abstractions</category><category>architecture</category><category>case study</category><category>communication</category></item><item><title>Stupid Things I've Done With Python</title><link>https://pyvideo.org/pycon-italia-2022/stupid-things-ive-done-with-python.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Stupid Things I’ve Done With Python - PyCon Italia 2022&lt;/p&gt;
&lt;p&gt;On every computer I’ve had for the past 20 years, I’ve created a folder
called “stupid python tricks”. It’s where I put code that should never
see the light of day. Code that abuses features like decorators,
metaclasses, and dynamic typing to do terrible things.&lt;/p&gt;
&lt;p&gt;Code I’m going to teach you. I have a GitHub repository that contains a
compilation of all the awful code I’ve written over the years, abusing
features like metaclasses, decorators, various &lt;strong&gt;dunder&lt;/strong&gt; methods, and
the mutable nature of Python’s underlying data structures.&lt;/p&gt;
&lt;p&gt;It’s a funny way to see how Python works under the hood, but it’s also
educational.&lt;/p&gt;
&lt;p&gt;Really!&lt;/p&gt;
&lt;p&gt;Each of the tricks is entertainingly terrible. But they’re also mostly
self-contained ways to see what happens when you override certain
behaviours of the Python language. Anyone with an intermediate level of
Python understanding should be able to follow along and learn something.&lt;/p&gt;
&lt;p&gt;I will cover:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Replacing an imported module with a class, so attribute lookups can
be &amp;#64;properties, with &lt;em&gt;hilarious&lt;/em&gt; results.&lt;/li&gt;
&lt;li&gt;Overriding the &lt;tt class="docutils literal"&gt;__sub__&lt;/tt&gt; magic method to create a hyphenated,
fuzzy-matching version of a boolean.&lt;/li&gt;
&lt;li&gt;Using &lt;tt class="docutils literal"&gt;__getattr__&lt;/tt&gt; to save time implementing all the functions in
the &lt;tt class="docutils literal"&gt;math&lt;/tt&gt; module.&lt;/li&gt;
&lt;li&gt;Using &lt;tt class="docutils literal"&gt;__eq__&lt;/tt&gt; to make things that aren’t really the same look the
same.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This talk is an entertaining tour of the Python Data Model, and the
things you can do - if you’re so inclined.&lt;/p&gt;
&lt;p&gt;Speaker: Mark Smith&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Mark Smith</dc:creator><pubDate>Fri, 03 Jun 2022 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2022-06-03:/pycon-italia-2022/stupid-things-ive-done-with-python.html</guid><category>PyCon Italia 2022</category><category>abstractions</category><category>best practice</category><category>teaching</category></item><item><title>The Design of Everyday APIs</title><link>https://pyvideo.org/pycon-italia-2022/the-design-of-everyday-apis.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The Design of Everyday APIs - PyCon Italia 2022&lt;/p&gt;
&lt;p&gt;What makes a good API for a library? Or more importantly, what makes it
bad? This talk will discuss the principles of what goes into
user-centered design, and how best to apply those principles when
writing a Python library for fellow developers. What makes a good API
for a library? Or more importantly, what makes it bad?&lt;/p&gt;
&lt;p&gt;Implementing an API is an art. It’s the connection between the user and
the library itself. How can we optimize that connection to make the
experience more pleasing? What makes a user reach for one library over
another? What goes into an ergonomic API?&lt;/p&gt;
&lt;p&gt;This talk will first discuss what makes an API good: documentation,
simplicity, consistency, completeness, and flexibility. We will apply
those elements by looking at developing and iterating on our own
library.&lt;/p&gt;
&lt;p&gt;Speaker: Lynn Root&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Lynn Root</dc:creator><pubDate>Fri, 03 Jun 2022 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2022-06-03:/pycon-italia-2022/the-design-of-everyday-apis.html</guid><category>PyCon Italia 2022</category><category>abstractions</category><category>apis</category><category>best practice</category></item></channel></rss>