<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Fri, 12 Jul 2019 00:00:00 +0000</lastBuildDate><item><title>Don't start with a database</title><link>https://pyvideo.org/europython-2019/dont-start-with-a-database.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;What you do when you start a new project? Usually, we begin with
database design, then we prepare a migration system, user registration,
and all different stuff that distracts us from doing what is most
important - business logic. With the clean architecture, we can learn
how to start a project in another way and this will be one of two main
topics of my talk. The second one will be about new features in Python.
You probably heard about typings, mypy, and dataclasses, but I will show
you how they can be used in real life project that can be developed over
many years in production lifecycle. There will be no &amp;quot;hello world&amp;quot; app,
no copy &amp;amp; paste of documentation, only practical knowledge learned
through many years of practice.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Grzegorz Kocjan</dc:creator><pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-07-12:europython-2019/dont-start-with-a-database.html</guid><category>APIs</category><category>Abstractions</category><category>Architecture</category><category>Best Practice</category><category>Clean Code</category></item><item><title>Software patterns for productive teams</title><link>https://pyvideo.org/europython-2019/software-patterns-for-productive-teams.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Software development is a team game.&lt;/p&gt;
&lt;p&gt;When we want to deliver more work, one of the variables that we can
change is the team size. But as we all know, increasing the team size
does not automatically translate into increased productivity &amp;amp; more
features shipped.&lt;/p&gt;
&lt;p&gt;If things are left unmanaged, people can step on each other toes, block
each other &amp;amp; generally decrease the overall productivity of a given
software project.&lt;/p&gt;
&lt;p&gt;In this talk we'll identify different problems teams can face &amp;amp; see how
we can solve them using different strategies &amp;amp; patterns.&lt;/p&gt;
&lt;p&gt;In the end, we want to enable the team to perform better &amp;amp; ship features
with high confidence. We want enable the team &amp;amp; put its potential into
building good software.&lt;/p&gt;
&lt;p&gt;Problems we are going to cover:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Constant merge conflicts / working in the same files&lt;/li&gt;
&lt;li&gt;Blocking each other on different features / Feature deadlock&lt;/li&gt;
&lt;li&gt;Constantly switching between bugfixing &amp;amp; feature development&lt;/li&gt;
&lt;li&gt;Constant regressions and things breaking down&lt;/li&gt;
&lt;li&gt;Fighting with local setup &amp;amp; not being able to properly test things,
especially when working with 3rd parties&lt;/li&gt;
&lt;li&gt;Merge strategies &amp;amp; improving the work with git &amp;amp; GitHub&lt;/li&gt;
&lt;li&gt;Communication between team members &amp;amp; ego fights&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For each problem, we are going to propose different solutions with
provided real-life examples from our experience &amp;amp; projects.&lt;/p&gt;
&lt;p&gt;The examples show are going to be in the context of large Python /
Django projects.&lt;/p&gt;
&lt;p&gt;This talk is the natural sequel of the following talks from previous
EuroPythons:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;EuroPython 2017 - Practical Debugging - Tips, Tricks and Ways to
think - &lt;a class="reference external" href="https://www.youtube.com/watch?v=9Ys4gCUtTh8"&gt;https://www.youtube.com/watch?v=9Ys4gCUtTh8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;EuroPython 2018 - Django structure for scale and longevity -
&lt;a class="reference external" href="https://www.youtube.com/watch?v=yG3ZdxBb1oo"&gt;https://www.youtube.com/watch?v=yG3ZdxBb1oo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Radoslav Georgiev</dc:creator><pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-07-12:europython-2019/software-patterns-for-productive-teams.html</guid><category>Abstractions</category><category>Best Practice</category><category>Communication</category><category>Django Projects</category><category>Management</category></item><item><title>The soul of the beast</title><link>https://pyvideo.org/europython-2019/the-soul-of-the-beast.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;div class="section" id="why"&gt;
&lt;h4&gt;Why&lt;/h4&gt;
&lt;p&gt;The audience will discover one of the core pieces of the language that
sits at the middle of the decisions about what new rules can or cannot
be implemented in the Python programming language. They will learn how
the particularities of the grammar limit what can be achieved but also
serve to maintain the language consistent, powerful but straightforward.
Attendants will learn how core developers solved some challenging
scenarios that arise as a consequence of said limitations or how others
cannot be resolved unless Python gets a significant transformation in
the internal mechanism that parses the grammar. Finally, they will learn
how a new rule is added to the CPython grammar, serving as a perfect
example of how all the pieces come together. In summary, the audience
will gain a more technical response to why people perceive the Python
programming language as easy but powerful one and at the same time will
gain some insight on how to understand and extend the pieces that form
it. This talk will not only help members of the audience understand
better the design of the language a how grammars and parser work, but
will also help people wanting to contribute to CPython understanding the
general structure of the compiler pipeline and how to work on it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="who"&gt;
&lt;h4&gt;Who&lt;/h4&gt;
&lt;p&gt;This talk is for those that want to understand Python a bit deeper: not
only how everything works under the hood but also what are the technical
decisions in its making and what are the consequences. The talk is
targeted to all Python programmers, no matter the skill level as
everyone will find something for their particular level of expertise:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Beginner programmers will be introduced in the topic of language
grammars and will learn what a Grammar is and what are the building
blocks. Also, the audience members in this level will gain insight into
how everything is thread together in CPython.&lt;/li&gt;
&lt;li&gt;Medium and advanced programmers will learn some in-depth technical
details and how they relate to features they already know and
understand. The talk not only will try to enlight some new areas related
to grammar technicalities, parser features and design and CPython
implementation details but will also connect many pieces of information
to explain how the small technical decisions impact the bigger picture.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="outline"&gt;
&lt;h4&gt;Outline&lt;/h4&gt;
&lt;p&gt;Who am I&lt;/p&gt;
&lt;p&gt;What is the Python Grammar&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;What is grammar?&lt;/li&gt;
&lt;li&gt;How they look like.&lt;/li&gt;
&lt;li&gt;Elements: terminal symbols, nonterminal symbols, productions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The properties of Python Grammar?&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Leftmost derivation&lt;/li&gt;
&lt;li&gt;1 token lookahead&lt;/li&gt;
&lt;li&gt;No epsilon productions! (Plus what epsilon productions are)&lt;/li&gt;
&lt;li&gt;Some immediate consequences of these properties.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;How the Python parser generator works&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;General structure of the parser generator.&lt;/li&gt;
&lt;li&gt;Non Deterministic Finite Automata&lt;/li&gt;
&lt;li&gt;Deterministic Finite Automata.&lt;/li&gt;
&lt;li&gt;Some examples (with cool graphs!) generated from the
python grammar and the parser generator of the actual
finite automatas that Python uses.&lt;/li&gt;
&lt;li&gt;Concrete syntax trees.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Advantages of the grammar (or &amp;quot;why Python is so easy to understand)&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;LL(1) grammars are context-free (no state to maintain while
parsing).&lt;/li&gt;
&lt;li&gt;LL(1) grammars are simple to implement and very fast to parse.&lt;/li&gt;
&lt;li&gt;LL(1) grammars are very limited, keeping the language simple&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Disadvantages of the grammar:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Grammar ambiguity.&lt;/li&gt;
&lt;li&gt;LL(1) grammars need some hacks for very simple things.&lt;/li&gt;
&lt;li&gt;How keyword arguments were incorporated in the grammar with a hack:
The grammar rule is very strange because it is &amp;quot;fixed&amp;quot; in the Abstract
syntax tree&lt;/li&gt;
&lt;li&gt;Why parenthesized with statements cannot be implemented (with
statements
formed of multiple elements surrounded by parenthesis and separated by
commas).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Implementing a new grammar rule in CPython: the arrow operator :&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;A complete mini-tutorial on how to introduce a new operator: A -&amp;gt; B
that gets executed as A.&lt;strong&gt;rarrow&lt;/strong&gt;(B).&lt;/li&gt;
&lt;li&gt;Altering the grammar and generating the new parser.&lt;/li&gt;
&lt;li&gt;Introducing a new token.&lt;/li&gt;
&lt;li&gt;Changing the tokenizer.&lt;/li&gt;
&lt;li&gt;Changing the Abstract Syntax Tree Generator.&lt;/li&gt;
&lt;li&gt;Changing the compiler.&lt;/li&gt;
&lt;li&gt;Implementing the new opcode.&lt;/li&gt;
&lt;li&gt;Implementing the &lt;strong&gt;rarrow&lt;/strong&gt; protocol.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The future and summary of the talk:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;We have been discussing in the CPython discourse to change the
parser generator to something
more powerful.&lt;/li&gt;
&lt;li&gt;Dangers and advantages of other parser generators.&lt;/li&gt;
&lt;li&gt;What other implementations are using?&lt;/li&gt;
&lt;li&gt;Summary of the talk&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Pablo Salgado</dc:creator><pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-07-12:europython-2019/the-soul-of-the-beast.html</guid><category>Abstractions</category><category>CPython</category><category>Performance</category><category>python</category></item></channel></rss>