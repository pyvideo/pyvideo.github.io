<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_ben-sigelman.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2016-08-21T00:00:00+00:00</updated><entry><title>Turnkey Distributed Tracing: OpenTracing and Python</title><link href="https://pyvideo.org/pybay-2016/turnkey-distributed-tracing-opentracing-and-python.html" rel="alternate"></link><published>2016-08-21T00:00:00+00:00</published><updated>2016-08-21T00:00:00+00:00</updated><author><name>Ben Sigelman</name></author><id>tag:pyvideo.org,2016-08-21:pybay-2016/turnkey-distributed-tracing-opentracing-and-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;This talk underlines the importance of distributed tracing in microservices, reveals the need for standardization of tracing instrumentation, and explains how the OpenTracing project addresses that need. We will showcase OpenTracing’s set of consistent, expressive, explicitly vendor-neutral tracing APIs with working examples using python gRPC, Flask, and possibly other frameworks if time allows.
​
Abstract
Microservice architectures offer many benefits but are notoriously difficult to observe or debug, especially as transactions inevitably cross process boundaries. I focused on this problem at Google and built Dapper, Google’s production distributed tracing system. I learned from Dapper’s design eccentricities that—in order to facilitate ubiquitous, transparent distributed tracing in OSS-heavy applications—as an industry we must find a way to make open-source software components interoperate from a tracing standpoint.&lt;/p&gt;
&lt;p&gt;This need for standardized tracing instrumentation across open source brings us to OpenTracing. By offering consistent, expressive, vendor-neutral, open-source APIs for popular platforms, OpenTracing provides a semantic and syntactic standard for distributed tracing instrumentation, allowing developers to add (or switch) tracing implementations with an O(1) configuration change.&lt;/p&gt;
&lt;p&gt;I will explain OpenTracing’s data model and the motivations behind it, describe how it generalizes across tracing systems and instrumentation languages (with a focus on Python), and show demos of how it integrates with frameworks (like Flask and gRPC) and applications. We will then cover the “hello world” of tracing: creating and linking traces that traverse process boundaries. Finally, I’ll share what’s in store for the rest of 2016 and 2017 and talk about ways to get involved.&lt;/p&gt;
</summary></entry></feed>