<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_f-haard.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2012-07-04T00:00:00+00:00</updated><entry><title>Protocol specifications written in python</title><link href="https://pyvideo.org/europython-2012/protocol-specifications-written-in-python.html" rel="alternate"></link><published>2012-07-04T00:00:00+00:00</published><updated>2012-07-04T00:00:00+00:00</updated><author><name>F Haard</name></author><id>tag:pyvideo.org,2012-07-04:europython-2012/protocol-specifications-written-in-python.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2012] F Haard - 4 JULY 2012 in &amp;quot;Track Ravioli&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Rapidly updating the requirements and implementation of a
machine-to-machine communication protocol is hard in itself, and keeping
a protocol specification and documentation up-to-date is always a
burden, and sometimes becomes an impossibility. At Visual Units, when
this became a problem with the protocol between the embedded software
and the fleet management server, we changed the approach and specified
the protocol in Python. This allows us to use the specification directly
when generating and parsing messages, as well as making it possible to
generate protocol documentation, and source code for our Java (J2ME)
client software. We implemented everything from scratch, and found it
surprisingly easy to do without documentation and specifications
external to The Code. This talk will focus on lessons learned and
pitfalls found during the implementation of this solution, with code
examples from our current state of art as well as showcases of some of
the mistakes we made and the types of magic used in different iterations
- most notably metaclasses and the inspect and imp modules. It will
follow the evolution from the first (quite horrible) attempts, to our
current implementation. I will also discuss what has been gained by
adopting this solution and the tradeoffs that we have made. The intended
audience is developers and designers who work with and design protocols,
as well as developers with a general interest in code as specification.
This is not a presentation of a framework for use in any application
(although code is available), but an in-depth look at how far you can go
with custom-built tools.&lt;/p&gt;
</summary></entry></feed>