<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Thu, 11 Jul 2019 00:00:00 +0000</lastBuildDate><item><title>Building Industry 4.0 logistics applications with MicroPython and ESP32 MCUs</title><link>https://pyvideo.org/europython-2019/building-industry-40-logistics-applications-with-micropython-and-esp32-mcus.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;div class="line-block"&gt;
&lt;div class="line"&gt;In this session, we will report about a forklift hailing application
we built using MicroPython and the ESP32-based prototyping hardware
M5Stack.&lt;/div&gt;
&lt;div class="line"&gt;In a production facility, machine operators can hail a forklift using
an ESP32 device running MicroPython. The device sends a request to a
forklift dispatcher software, written in Python. The request is queued
and subsequently, the next available forklift is notified and sent to
the machine. Each forklift is also fitted with an ESP32 device. In
this project, the prototyping hardware M5Stack was used. It features
an ESP32 micro controller with Bluetooth, WIFI, GPIO, three buttons,
and a display.&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Attendees will learn how MicroPython and prototyping hardware can be
used to scale from an idea on the developers desk to a working system in
a rough Industry 4.0 production environment. The talk will recap our
journey with MicroPython, the lessons learned, and the pitfalls to
avoid. Furthermore, the tooling setup will be introduced, including our
M5Stack GUI-simulator to mock the M5Stack display.&lt;/p&gt;
&lt;p&gt;The central dispatch server is built using Python and deployed in a
Docker container. Messages are exchanged using MQTT, a popular IoT
message protocol. The talk will conclude with a live demonstration of
the forklift hailing system. Attendees should be comfortable with the
Python syntax but are not expected to have any MicroPython, MQTT, Docker
or domain knowledge.&lt;/p&gt;
&lt;p&gt;Materials can be found at &lt;a class="reference external" href="https://gitlab.com/fwahl/europython2019"&gt;https://gitlab.com/fwahl/europython2019&lt;/a&gt;.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Florian Wahl</dc:creator><pubDate>Thu, 11 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-07-11:europython-2019/building-industry-40-logistics-applications-with-micropython-and-esp32-mcus.html</guid><category>Cross-Platform-Development</category><category>DIY</category><category>Hardware/IoT</category><category>Internet of Things (IoT)</category><category>MicroPython</category></item><item><title>Python for realtime audio processing in a live music context</title><link>https://pyvideo.org/europython-2019/python-for-realtime-audio-processing-in-a-live-music-context.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;At Les Chemins de Traverse we explore ways of &amp;quot;augmenting&amp;quot; acoustical
musical instruments with new sonic possibilities offered by computers.
For doing so, we need ultra-low latency real-time audio processing
programs. Pretty much the typical situation where python should &lt;em&gt;not&lt;/em&gt; be
used, right? Wrong. As it happens, that's exactly what we've been doing
for the past few years.&lt;/p&gt;
&lt;p&gt;Building on Olivier Belanger's wonderful pyo module and (ab)using
python's flexibility, we developed custom software to allow us to
express our musical ideas.&lt;/p&gt;
&lt;p&gt;If you want to hear how it sounds, you should go to Europython's social
event that will feature a gig based on python-augmented (!) instruments.
And if you want to know how we came to use python in this context and
how we do it, you should come to this talk!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Matthieu Amiguet</dc:creator><pubDate>Wed, 10 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-07-10:europython-2019/python-for-realtime-audio-processing-in-a-live-music-context.html</guid><category>Augmented Reality</category><category>DIY</category><category>Linux</category><category>Use Case</category></item><item><title>MIDI-Geräte drahtlos steuern mit OSC, Raspberry Pi und python-rtmidi</title><link>https://pyvideo.org/pycon-de-2013/midi-gerate-drahtlos-steuern-mit-osc-raspberry-p.html</link><description>&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Mit der &lt;a class="reference external" href="https://pypi.python.org/pypi/python-rtmidi"&gt;python-rtmidi&lt;/a&gt;
Bibliothek lässt sich mit Python unter den drei gängigsten
Betriebssystemen Windows, OS X und Linux auf MIDI-Schnittstellen
zugreifen und MIDI-Daten senden und empfangen. Viele elektronische
Musikinstrumente und anderes Soundequipment werden noch immer vorwiegend
über das MIDI-Protokoll gesteuert und besitzen nur herkömmliche
MIDI-Interfaces. Mit Hilfe einer auf &lt;em&gt;python-rtmidi&lt;/em&gt; und
&lt;a class="reference external" href="http://das.nasophon.de/pyliblo/"&gt;pyliblo&lt;/a&gt; aufsetzenden Software, der
&lt;em&gt;OSC-MIDI-Bridge&lt;/em&gt;, einem Raspberry Pi und je einem billigen WLAN- und
USB-MIDI-Interface, lassen sich solche Geräte kostengünstig in ein
drahtloses Netzwerk einbinden und z.B. über Tablet-Computer steuern, auf
denen entsprechende Software installiert ist, die OSC (&lt;a class="reference external" href="http://opensoundcontrol.org/"&gt;Open Sound
Control&lt;/a&gt;) unterstützt (z.B.
&lt;a class="reference external" href="http://hexler.net/software/touchosc"&gt;TouchOSC&lt;/a&gt; oder &lt;a class="reference external" href="http://www.thiburce.com/TBStuff/"&gt;TB MIDI
Stuff&lt;/a&gt;). Dies ist insbesondere für
Situationen praktisch, in denen kein sperriger Desktop-Computer oder
Laptop mit MIDI-Schnittstelle vor Ort vorhanden oder gewünscht ist.&lt;/p&gt;
&lt;p&gt;Mit einer &amp;quot;Live&amp;quot;-Demonstration zeigt der Referent diese von ihm
implementierte Software in Aktion (ca. 4 min) und erläutert dann kurz
die dabei benutzten Protokolle (MIDI und OSC) (5 min), stellt die
verwendeten Python-Bibliotheken &lt;em&gt;python-rtmidi&lt;/em&gt; und &lt;em&gt;pyliblo&lt;/em&gt; vor (4
min) und erläutert die eingesetzten Software-Techniken. Dabei wird
insbesondere auf die asynchrone Behandlung von MIDI-Input und Output via
des &lt;em&gt;multiprocessing&lt;/em&gt;-Moduls der Standardbibliothek eingegangen (5 min).
Abschliessend werden noch einige Anregungen für weitere Einsatzzwecke
von &lt;em&gt;python-rtmidi&lt;/em&gt; und der OSC-MIDI-Bridge gegeben (2 min).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;python-rtmidi&lt;/em&gt; ist ein Python-Bindung für die C++-Bibliothek
&lt;a class="reference external" href="http://www.music.mcgill.ca/~gary/rtmidi/index.html"&gt;RtMidi&lt;/a&gt; und
wurde mit &lt;a class="reference external" href="http://cython.org"&gt;Cython&lt;/a&gt; realisiert. Die Software
befindet sich noch im Alpha-Status, da momentan noch die Unterstützung
der Kernel Streaming API unter Windows fehlt (Windows wird aber über das
WinMM-Framework unterstützt). Die vorhandene Funktionalität ist jedoch
stabil und es ist geplant, vor der PyCon.DE eine Beta-Version zu
veröffentlichen. Die darauf aufsetzende OSC-MIDI Bridge ist bisher nur
als Beispielskript in der &lt;em&gt;python-rtmidi&lt;/em&gt;-Distribution verfügbar, wird
aber stetig weiterentwickelt und voraussichtlich demnächst in ein
eigenes Projekt ausgegliedert.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Christopher Arndt</dc:creator><pubDate>Wed, 16 Oct 2013 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2013-10-16:pycon-de-2013/midi-gerate-drahtlos-steuern-mit-osc-raspberry-p.html</guid><category>diy</category><category>midi</category><category>musik</category><category>osc</category><category>raspberry pi</category><category>remote control</category></item></channel></rss>