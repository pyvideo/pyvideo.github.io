<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_chen-rotem-levy.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2017-06-13T00:00:00+00:00</updated><entry><title>Unit testing in the real world with mock</title><link href="https://pyvideo.org/pycon-israel-2017/unit-testing-in-the-real-world-with-mock.html" rel="alternate"></link><published>2017-06-13T00:00:00+00:00</published><updated>2017-06-13T00:00:00+00:00</updated><author><name>Chen Rotem Levy</name></author><id>tag:pyvideo.org,2017-06-13:pycon-israel-2017/unit-testing-in-the-real-world-with-mock.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Everybody agree that unit-tests are important, however learning how to write unit-tests is hard. Most of the instructional material you might try to read will use as its' examples some well behaved functions with known input and deterministic outputs. Code that is trivial to write tests around. However the real world isn't so well behaved. It has legacy code, it inspects the world, has side effects, calls external services and might have random components. Writing unit-tests for such a code is anything but trivial. One technique to allow writing unit-tests around such real world code is to replace all that ugliness with mocks, and the standard unittest.mock library is a grate tool for that. The abilities of this library surprised and delighted me in more then one occasion as I straggled to raise my code coverage. However, in my experience both the concept of mocking and the unittest.mock library are not widely known. I hope to help change that in a small way.&lt;/p&gt;
</summary><category term="unittest.mock"></category></entry></feed>