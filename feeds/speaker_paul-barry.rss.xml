<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Sun, 06 Nov 2016 00:00:00 +0000</lastBuildDate><item><title>My 25 year love/hate relationship with databases</title><link>https://pyvideo.org/pycon-ireland-2015/my-25-year-lovehate-relationship-with-databases.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;We all use existing decorators all the time (athough Python 3.5 is overloading the &amp;#64; symbol, which will likely confuse a lot of us ol' timers). However, writing a decorator ourselves can sometimes be daunting. This talk/tutorial walks through an example case study which demonstrates when to create a decorator (and why), and proves - all being well - that decorators aren't all that scary afterall.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Paul Barry</dc:creator><pubDate>Sun, 25 Oct 2015 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2015-10-25:pycon-ireland-2015/my-25-year-lovehate-relationship-with-databases.html</guid></item><item><title>The Bluffer's Guide to Data Science</title><link>https://pyvideo.org/pycon-ireland-2016/the-bluffers-guide-to-data-science.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;A light-hearted look at the world of Data Science for Python programmers
who are eyeing-up the Data Science problem domain and thinking: &amp;quot;It
can't be all that hard, can it?&amp;quot;. In his talk, Paul presents his
thinking on what Python programmers need to know in order to
convincingly pass themselves off as a &amp;quot;real&amp;quot; Data Scientist.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Paul Barry</dc:creator><pubDate>Sun, 06 Nov 2016 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2016-11-06:pycon-ireland-2016/the-bluffers-guide-to-data-science.html</guid></item><item><title>Try, try, and try again</title><link>https://pyvideo.org/pycon-ireland-2016/try-try-and-try-again.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Writing code in Python is easier than most other programming languages.
So much so, in fact, that it's easy to quickly knock-up something to
solve a problem, especially if your code is ultimately &amp;quot;throw-away&amp;quot;. As
a language, Python's great at not getting in your way: you write your
code, it runs, then you move onto something else. But, how easy is it to
to write robust code in Python? What if your code has to hang around for
a long time? What if you need to write code which not only runs but also
has to handle problems should they occur? In this talk, Paul attempts to
answer these questions by presenting some working code, which he then
dissects to highlight some of the things that can go wrong, before
describing how it's possible to handle and survive the identified
problems (should they occur).&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Paul Barry</dc:creator><pubDate>Sat, 05 Nov 2016 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2016-11-05:pycon-ireland-2016/try-try-and-try-again.html</guid></item></channel></rss>