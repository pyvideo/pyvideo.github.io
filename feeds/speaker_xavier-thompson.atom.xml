<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org - Xavier Thompson</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_xavier-thompson.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2024-07-08T00:00:00+00:00</updated><subtitle></subtitle><entry><title>Extending Cython with GIL-free types</title><link href="https://pyvideo.org/europython-2021/extending-cython-with-gil-free-types.html" rel="alternate"></link><published>2021-07-26T00:00:00+00:00</published><updated>2021-07-26T00:00:00+00:00</updated><author><name>Xavier Thompson</name></author><id>tag:pyvideo.org,2021-07-26:/europython-2021/extending-cython-with-gil-free-types.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Extending Cython with GIL-free types
[EuroPython 2021 - Talk - 2021-07-28 - Brian]
[Online]&lt;/p&gt;
&lt;p&gt;By Xavier Thompson&lt;/p&gt;
&lt;p&gt;Cython is a compiled language, largely inspired by Python, which can already provide both massive speedups and seamless interoperability with C libraries. In Cython, Python and C can freely mix thanks to a unified syntax …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Extending Cython with GIL-free types
[EuroPython 2021 - Talk - 2021-07-28 - Brian]
[Online]&lt;/p&gt;
&lt;p&gt;By Xavier Thompson&lt;/p&gt;
&lt;p&gt;Cython is a compiled language, largely inspired by Python, which can already provide both massive speedups and seamless interoperability with C libraries. In Cython, Python and C can freely mix thanks to a unified syntax and gradual typing. This opens the door to bypassing the GIL by restricting oneself to the C side of Cython, but it entails letting go of all the high-level semantics of Python and going back to low-level manual memory management, pointer arithmetic and good old segmentation faults... Not to mention all the joys of multi-threading in C!&lt;/p&gt;
&lt;p&gt;In this talk, we will recount how we experimentally extended Cython to bridge that gap with GIL-free reference-counted types and a type system for thread-safe concurrency. We call this extension: Cython+.&lt;/p&gt;
&lt;p&gt;By hacking a bit the Cython compiler, one can create new language features which translate under-the-hood to low-level GIL-agnostic C or C++. In this way we extended Cython with a new class system that looks familiar to a Python programmer, but can be used in Cython while the GIL is released because it does not depend on the Python/C API. By adapting the way Cython generates reference counting instructions for Python objects, we equipped our types with a thread-safe reference count. Thanks to Cython's expertise with the Python/C API, we wrapped our types into extension types, thus gaining interoperability with Python. And using Cython's static type checking, we are currently introducing an ownership type system for thread-safe concurrency inspired by Pony and Rust.&lt;/p&gt;
&lt;p&gt;License: This video is licensed under the CC BY-NC-SA 4.0 license: &lt;a class="reference external" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"&gt;https://creativecommons.org/licenses/by-nc-sa/4.0/&lt;/a&gt;
Please see our speaker release agreement for details: &lt;a class="reference external" href="https://ep2021.europython.eu/events/speaker-release-agreement/"&gt;https://ep2021.europython.eu/events/speaker-release-agreement/&lt;/a&gt;&lt;/p&gt;
</content><category term="EuroPython 2021"></category></entry><entry><title>How to Build a Python-to-C++ Compiler out of Spare Parts - and Why</title><link href="https://pyvideo.org/europython-2024/how-to-build-a-python-to-c-compiler-out-of-spare-parts-and-why.html" rel="alternate"></link><published>2024-07-08T00:00:00+00:00</published><updated>2024-07-08T00:00:00+00:00</updated><author><name>Xavier Thompson</name></author><id>tag:pyvideo.org,2024-07-08:/europython-2024/how-to-build-a-python-to-c-compiler-out-of-spare-parts-and-why.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;[EuroPython 2024 — Forum Hall on 2024-07-11&lt;/p&gt;
&lt;p&gt;How to Build a Python-to-C++ Compiler out of Spare Parts - and Why by Xavier Thompson&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://ep2024.europython.eu/session/how-to-build-a-python-to-c-compiler-out-of-spare-parts-and-why"&gt;https://ep2024.europython.eu/session/how-to-build-a-python-to-c-compiler-out-of-spare-parts-and-why&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A frequent topic about Python is performance: its interpreted nature inhibits optimisations, and the famous GIL limits parallelism (for now!).&lt;/p&gt;
&lt;p&gt;Existing Python …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;[EuroPython 2024 — Forum Hall on 2024-07-11&lt;/p&gt;
&lt;p&gt;How to Build a Python-to-C++ Compiler out of Spare Parts - and Why by Xavier Thompson&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://ep2024.europython.eu/session/how-to-build-a-python-to-c-compiler-out-of-spare-parts-and-why"&gt;https://ep2024.europython.eu/session/how-to-build-a-python-to-c-compiler-out-of-spare-parts-and-why&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A frequent topic about Python is performance: its interpreted nature inhibits optimisations, and the famous GIL limits parallelism (for now!).&lt;/p&gt;
&lt;p&gt;Existing Python Compilers - Cython, Numba, Codon - focus mainly on compiling small, critical bits of code to achieve linear execution speedups. As for parallelism: parallel for-loops powered by OpenMP.&lt;/p&gt;
&lt;p&gt;To parallelize highly concurrent programs with concurrent I/O and concurrent tasks, we need more. A key difference is it requires compiling everything: as soon as the Python interpreter comes into play, the GIL will make parallelism collapse.&lt;/p&gt;
&lt;p&gt;We introduce Typon, a Python-to-C++ compiler with powerful concurrency primitives powered by a crazy homemade task scheduler. It can take untyped, idiomatic Python code and output C++ code fully independent of the Python interpreter. It also provides seamless to-and-from Python interoperability, for those cases where you really just need to import numpy.&lt;/p&gt;
&lt;p&gt;In this talk we'll recount our journey so far: why we think it's important, how we're making something new out of existing bits, what we've achieved. Along the way we might delve into fun details like type inference, concurrency primitives, and C++ pretending-to-be-Python.&lt;/p&gt;
&lt;p&gt;You'll come out of this talk with some cool insights into compiler design, concurrency, and the design of Python.&lt;/p&gt;
&lt;p&gt;Knowledge of C++ not required. Knowledge of Python language inner workings helpful.&lt;/p&gt;
&lt;p&gt;---&lt;/p&gt;
&lt;p&gt;This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License: &lt;a class="reference external" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"&gt;https://creativecommons.org/licenses/by-nc-sa/4.0/&lt;/a&gt;&lt;/p&gt;
</content><category term="EuroPython 2024"></category></entry></feed>