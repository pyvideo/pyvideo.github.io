<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org - Eliana Rosselli</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_eliana-rosselli.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2023-10-17T00:00:00+00:00</updated><subtitle></subtitle><entry><title>An approach to lightweight tenancy management using Django Rest Framework</title><link href="https://pyvideo.org/djangocon-us-2023/an-approach-to-lightweight-tenancy-management-using-django-rest-framework.html" rel="alternate"></link><published>2023-10-17T00:00:00+00:00</published><updated>2023-10-17T00:00:00+00:00</updated><author><name>Eliana Rosselli</name></author><id>tag:pyvideo.org,2023-10-17:/djangocon-us-2023/an-approach-to-lightweight-tenancy-management-using-django-rest-framework.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Over the last few years, I have run into the same multitenancy use case across different projects. This scenario is a “lightweight” multitenancy use case, where we have a tenant model and tenants are instances of this model; all tenants share the same database, schema, and application instance. Resources …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Over the last few years, I have run into the same multitenancy use case across different projects. This scenario is a “lightweight” multitenancy use case, where we have a tenant model and tenants are instances of this model; all tenants share the same database, schema, and application instance. Resources belong to a single tenant, but users can belong to multiple tenants. Almost all API routes need to be nested under the tenant id, with urls of the form &lt;cite&gt;api/tenants/tenant-id/some-resource&lt;/cite&gt;. The challenges we faced were how to effectively nest our API urls and how to consistently restrict access to resources, so that users could only access those resources that belong to tenants that the user has permission to access.&lt;/p&gt;
&lt;p&gt;We’ll cover:
- A brief description of the use case and multitenancy
- How we implemented nested routes in our API using [drf-nested-routers](&lt;a class="reference external" href="https://github.com/alanjds/drf-nested-routers"&gt;https://github.com/alanjds/drf-nested-routers&lt;/a&gt;)
- How we wrote a custom viewset to centralize all logic related to checking that the user has permission to access resources under a specific tenant
- Custom model manager to avoid accidentally leaking information from other tenants
- Uses and limitations of our approach
- A different approach using an existing library ([drf-access-policy](&lt;a class="reference external" href="https://github.com/rsinger86/drf-access-policy"&gt;https://github.com/rsinger86/drf-access-policy&lt;/a&gt;))&lt;/p&gt;
&lt;p&gt;Anyone with experience in Django is welcome!&lt;/p&gt;
</content><category term="DjangoCon US 2023"></category></entry></feed>