<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_anthony-scopatz.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2019-11-04T00:00:00+00:00</updated><entry><title>Conda-press, or Reinventing the Wheel</title><link href="https://pyvideo.org/pydata-new-york-city-2019/conda-press-or-reinventing-the-wheel.html" rel="alternate"></link><published>2019-11-04T00:00:00+00:00</published><updated>2019-11-04T00:00:00+00:00</updated><author><name>Anthony Scopatz</name></author><id>tag:pyvideo.org,2019-11-04:pydata-new-york-city-2019/conda-press-or-reinventing-the-wheel.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Conda-press (&lt;a class="reference external" href="https://github.com/regro/conda-press"&gt;https://github.com/regro/conda-press&lt;/a&gt;) is a new tool that lets you transform conda packages into Python wheels. This talk will: discuss why in the world you would want to do such a terrible thing, demonstrate that you can do such a terrible thing (live!), dive-in to how such as terrible thing is done, and define some safety precautions when doing such a terrible things&lt;/p&gt;
</summary></entry><entry><title>Inequality of Underrepresented Groups in Core Project Leadership</title><link href="https://pyvideo.org/scipy-2019/inequality-of-underrepresented-groups-in-core-project-leadership.html" rel="alternate"></link><published>2019-07-13T00:00:00+00:00</published><updated>2019-07-13T00:00:00+00:00</updated><author><name>Anthony Scopatz</name></author><id>tag:pyvideo.org,2019-07-13:scipy-2019/inequality-of-underrepresented-groups-in-core-project-leadership.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Different core projects in our ecosystem have a dramatically different make up among the leadership of the their developer teams. This talk explores those differences in representation, and how to measure them quantitatively. It will then present some of the qualitative lessons we can learn from this data.&lt;/p&gt;
</summary></entry><entry><title>Xonsh: Bringing Python Data Science to your Shell</title><link href="https://pyvideo.org/scipy-2019/xonsh-bringing-python-data-science-to-your-shell.html" rel="alternate"></link><published>2019-07-11T00:00:00+00:00</published><updated>2019-07-11T00:00:00+00:00</updated><author><name>Gilbert Forsyth</name></author><id>tag:pyvideo.org,2019-07-11:scipy-2019/xonsh-bringing-python-data-science-to-your-shell.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Xonsh is an interactive, cross-platform Python/Unix Shell hybrid language that makes it easy to switch between Python operations and command line interfaces. While Python has a wealth of data science libraries and tools, there are still plenty of utilities that live outside of the scientific Python ecosystem. Xonsh provides a way of gluing ALL of your tools together. Additionally, as a shell, xonsh comes with batteries-included features that are important in a scientific context. If you are new to shells, want to use Python for &lt;em&gt;everything&lt;/em&gt;, or just plain fed up with sh-lang syntax, this tutorial is for you!&lt;/p&gt;
</summary><category term="tutorial"></category></entry><entry><title>RAPIDS: Open GPU Data Science</title><link href="https://pyvideo.org/scipy-2019/rapids-open-gpu-data-science.html" rel="alternate"></link><published>2019-07-10T00:00:00+00:00</published><updated>2019-07-10T00:00:00+00:00</updated><author><name>Anthony Scopatz</name></author><id>tag:pyvideo.org,2019-07-10:scipy-2019/rapids-open-gpu-data-science.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The RAPIDS suite of open source software libraries gives you the freedom to execute end-to-end data science pipelines entirely on GPUs. RAPIDS is incubated by NVIDIA® based on years of accelerated data science experience. RAPIDS relies on NVIDIA CUDA® primitives for low-level compute optimization, GPU parallelism, and high-bandwidth memory speed through user-friendly Python interfaces. This tutorial will teach you how to use the RAPIDS software stack from Python, including cuDF (a DataFrame library interoperable with Pandas), dask-cudf (for distributing DataFrame work over many GPUs), and cuML (a machine learning library that provides GPU-accelerated versions of the algorithms in scikit-learn).&lt;/p&gt;
</summary><category term="tutorial"></category></entry><entry><title>xonsh</title><link href="https://pyvideo.org/pycon-us-2016/anthony-scopatz-xonsh-pycon-2016.html" rel="alternate"></link><published>2016-05-31T00:00:00+00:00</published><updated>2016-05-31T00:00:00+00:00</updated><author><name>Anthony Scopatz</name></author><id>tag:pyvideo.org,2016-05-31:pycon-us-2016/anthony-scopatz-xonsh-pycon-2016.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Speaker: Anthony Scopatz&lt;/p&gt;
&lt;p&gt;Xonsh is general purpose shell that combines Python and the best features of Bash, zsh, and fish. Relying only the standard library and PLY, the xonsh language is a strict superset of Python that compiles to a Python AST.  The shell provides exciting features such as a rich history, tab completion from bash and man pages, syntax highlighting, auto-suggestion, foreign-function aliases and more!&lt;/p&gt;
&lt;p&gt;Slides can be found at: &lt;a class="reference external" href="https://speakerdeck.com/pycon2016"&gt;https://speakerdeck.com/pycon2016&lt;/a&gt; and &lt;a class="reference external" href="https://github.com/PyCon/2016-slides"&gt;https://github.com/PyCon/2016-slides&lt;/a&gt;&lt;/p&gt;
</summary></entry><entry><title>Total Recall: flmake and the Quest for Reproducibility</title><link href="https://pyvideo.org/scipy-2012/total-recall-flmake-and-the-quest-for-reproducib.html" rel="alternate"></link><published>2012-07-19T00:00:00+00:00</published><updated>2012-07-19T00:00:00+00:00</updated><author><name>Anthony Scopatz</name></author><id>tag:pyvideo.org,2012-07-19:scipy-2012/total-recall-flmake-and-the-quest-for-reproducib.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;&lt;a class="reference external" href="http://flash.uchicago.edu/site/"&gt;FLASH&lt;/a&gt; is a high-performance
computing (HPC) multi-physics code which is used to perform
astrophysical and high-energy density physics simulations. It runs on
the full range of systems from laptops to workstations to 100,000
processor super computers - such as the Blue Gene/P at Argonne National
Laboratory.&lt;/p&gt;
&lt;p&gt;Historically, FLASH was born from a collection of unconnected legacy
codes written primarily in Fortran and merged into a single project.
Over the past 13 years major sections have been rewritten in other
languages. For instance, I/O is now implemented in C. However building,
testing, and documentation are all performed in Python.&lt;/p&gt;
&lt;p&gt;FLASH has a unique architecture which compiles &lt;em&gt;simulation specific&lt;/em&gt;
executables for each new type of run. This is aided by an
object-oriented- esque inheritance model that is implemented by
inspecting the file system's directory hierarchy. This allows FLASH to
compile to faster machine code than a compile-once strategy. However it
also places a greater importance on the Python build system.&lt;/p&gt;
&lt;p&gt;To run a FLASH simulation, the user must go through three basic steps:
setup, build, and execution. Canonically, each of these tasks are
independently handled by the user. However, with the recent advent of
&lt;a class="reference external" href="http://flash.%20uchicago.edu/site/flashcode/user_support/tools4b/usersguide/flmake/index.htm"&gt;flmake&lt;/a&gt;
- a Python workflow management utility for FLASH - such tasks may now be
performed in a repeatable way.&lt;/p&gt;
&lt;p&gt;Previous workflow management tools have been written for FLASH. (For
example, the &amp;quot;Milad system&amp;quot; was implemented entirely in Makefiles.)
However, none of the priorattempts have placed reproducibility as their
primary concern. This is in part becausefully capturing the setup
metadata requires alterations to the build system.&lt;/p&gt;
&lt;p&gt;The development of flmake started by rewriting the existing build
systemto allow FLASH to be run outside of the main line subversion
repository. It separates outproject and simulation directories
independent of the FLASH source directory. Thesedirectories are
typically under their own version control.&lt;/p&gt;
&lt;p&gt;Moreover for each of the important tasks (setup, build, run, etc), a
sidecar metadata &lt;em&gt;description&lt;/em&gt; file is either written or appended to.
This is a simple dictionary-of-dictionaries JSON file which stores the
environment of the system and the state of the code when each flmake
command is run. This metadata includes the version information of both
the FLASH main line and project repositories. However, it also may
include &lt;em&gt;all&lt;/em&gt; local modifications since the last commit. A patch is
automatically generated using the Python standard library &lt;tt class="docutils literal"&gt;difflib&lt;/tt&gt;
module and stored directly in the description.&lt;/p&gt;
&lt;p&gt;Along with universally unique identifiers, logging, and Python run
control files, the flmake utility may use the description files to fully
reproduce a simulation by re-executing each command in its original
environment and state. While &lt;tt class="docutils literal"&gt;flmake reproduce&lt;/tt&gt; makes a useful
debugging tool, it fundamentally increases the scientific merit of FLASH
simulations.&lt;/p&gt;
&lt;p&gt;The methods described above may be used whenever source code itself is
distributed. While this is true for FLASH (uncommon amongst
compiledcodes), most Python packages also distribute their source.
Therefore the same reproducibility strategy is applicable and highly
recommended for Python simulation codes. Thus flmake shows that
reproducibility - which is notably absent from most computational
science projects - is easily attainable using only version control and
standard library modules.&lt;/p&gt;
</summary><category term="General"></category></entry><entry><title>HDF5 is for lovers</title><link href="https://pyvideo.org/scipy-2012/hdf5-is-for-lovers.html" rel="alternate"></link><published>2012-07-16T00:00:00+00:00</published><updated>2012-07-16T00:00:00+00:00</updated><author><name>Anthony Scopatz</name></author><id>tag:pyvideo.org,2012-07-16:scipy-2012/hdf5-is-for-lovers.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;HDF5 is a hierarchical, binary database format that has become a &lt;em&gt;de
facto&lt;/em&gt; standard for scientific computing. While the specification may be
used in a relatively simple way (persistence of static arrays) it also
supports several high-level features that prove invaluable. These
include chunking, ragged data, extensible data, parallel I/O,
compression, complex selection, and in- core calculations. Moreover,
HDF5 bindings exist for almost every language - including two Python
libraries (PyTables and h5py).&lt;/p&gt;
&lt;p&gt;This tutorial will discuss tools, strategies, and hacks for really
squeezing every ounce of performance out of HDF5 in new or existing
projects. It will also go over fundamental limitations in the
specification and provide creative and subtle strategies for getting
around them. Overall, this tutorial will show how HDF5 plays nicely with
all parts of an application making the code and data both faster and
smaller. With such powerful features at the developer's disposal, what
is not to love?!&lt;/p&gt;
&lt;p&gt;This tutorial is targeted at a more advanced audience which has a prior
knowledge of Python and NumPy. Knowledge of C or C++ and basic HDF5 is
recommended but not required.&lt;/p&gt;
</summary></entry><entry><title>HDF5 is for Lovers part 2</title><link href="https://pyvideo.org/scipy-2014/hdf5-is-for-lovers-part-2.html" rel="alternate"></link><published>2014-07-09T00:00:00+00:00</published><updated>2014-07-09T00:00:00+00:00</updated><author><name>Anthony Scopatz</name></author><id>tag:pyvideo.org,2014-07-09:scipy-2014/hdf5-is-for-lovers-part-2.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;HDF5 is a hierarchical, binary database format that has become the de
facto standard for scientific computing. While the spec may be used in a
relatively simple way it also supports several high-level features that
prove invaluable. HDF5 bindings exist for almost every language -
including two Python libraries (PyTables and h5py). This tutorial will
cover HDF5 through the lens of PyTables.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;div class="section" id="description"&gt;
&lt;h4&gt;Description&lt;/h4&gt;
&lt;p&gt;HDF5 is a hierarchical, binary database format that has become the de
facto standard for scientific computing. While the specification may be
used in a relatively simple way (persistence of static arrays) it also
supports several high-level features that prove invaluable. These
include chunking, ragged data, extensible data, parallel I/O,
compression, complex selection, and in-core calculations. Moreover, HDF5
bindings exist for almost every language - including two Python
libraries (PyTables and h5py). This tutorial will cover HDF5 itself
through the lens of PyTables.&lt;/p&gt;
&lt;p&gt;This tutorial will discuss tools, strategies, and hacks for really
squeezing every ounce of performance out of HDF5 in new or existing
projects. It will also go over fundamental limitations in the
specification and provide creative and subtle strategies for getting
around them. Overall, this tutorial will show how HDF5 plays nicely with
all parts of an application making the code and data both faster and
smaller. With such powerful features at the developer's disposal, what
is not to love?!&lt;/p&gt;
&lt;p&gt;Knowledge of Python, NumPy, C or C++, and basic HDF5 is recommended but
not required.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="outline"&gt;
&lt;h4&gt;Outline&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Meaning in layout (20 min)&lt;ul&gt;
&lt;li&gt;Tips for choosing your hierarchy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Advanced datatypes (20 min)&lt;ul&gt;
&lt;li&gt;Tables&lt;/li&gt;
&lt;li&gt;Nested types&lt;/li&gt;
&lt;li&gt;Tricks with malloc() and byte-counting&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exercise on above topics&lt;/strong&gt; (20 min)&lt;/li&gt;
&lt;li&gt;Chunking (20 min)&lt;ul&gt;
&lt;li&gt;How it works&lt;/li&gt;
&lt;li&gt;How to properly select your chunksize&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Queries and Selections (20 min)&lt;ul&gt;
&lt;li&gt;In-core vs Out-of-core calculations&lt;/li&gt;
&lt;li&gt;PyTables.where()&lt;/li&gt;
&lt;li&gt;Datasets vs Dataspaces&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exercise on above topics&lt;/strong&gt; (20 min)&lt;/li&gt;
&lt;li&gt;The Starving CPU Problem (1 hr)&lt;ul&gt;
&lt;li&gt;Why you should always use compression&lt;/li&gt;
&lt;li&gt;Compression algorithms available&lt;/li&gt;
&lt;li&gt;Choosing the correct one&lt;/li&gt;
&lt;li&gt;Exercise&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Integration with other databases (1 hr)&lt;ul&gt;
&lt;li&gt;Migrating to/from SQL&lt;/li&gt;
&lt;li&gt;HDF5 in other databases (JSON example)&lt;/li&gt;
&lt;li&gt;Other Databases in HDF5 (JSON example)&lt;/li&gt;
&lt;li&gt;Exercise&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="HDF5"></category><category term="PyTables"></category><category term="tutorial"></category></entry><entry><title>HDF5 is for Lovers, Tutorial part 1</title><link href="https://pyvideo.org/scipy-2014/hdf5-is-for-lovers-tutorial-part-1.html" rel="alternate"></link><published>2014-07-09T00:00:00+00:00</published><updated>2014-07-09T00:00:00+00:00</updated><author><name>Anthony Scopatz</name></author><id>tag:pyvideo.org,2014-07-09:scipy-2014/hdf5-is-for-lovers-tutorial-part-1.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;HDF5 is a hierarchical, binary database format that has become the de
facto standard for scientific computing. While the spec may be used in a
relatively simple way it also supports several high-level features that
prove invaluable. HDF5 bindings exist for almost every language -
including two Python libraries (PyTables and h5py). This tutorial will
cover HDF5 through the lens of PyTables.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;div class="section" id="description"&gt;
&lt;h4&gt;Description&lt;/h4&gt;
&lt;p&gt;HDF5 is a hierarchical, binary database format that has become the de
facto standard for scientific computing. While the specification may be
used in a relatively simple way (persistence of static arrays) it also
supports several high-level features that prove invaluable. These
include chunking, ragged data, extensible data, parallel I/O,
compression, complex selection, and in-core calculations. Moreover, HDF5
bindings exist for almost every language - including two Python
libraries (PyTables and h5py). This tutorial will cover HDF5 itself
through the lens of PyTables.&lt;/p&gt;
&lt;p&gt;This tutorial will discuss tools, strategies, and hacks for really
squeezing every ounce of performance out of HDF5 in new or existing
projects. It will also go over fundamental limitations in the
specification and provide creative and subtle strategies for getting
around them. Overall, this tutorial will show how HDF5 plays nicely with
all parts of an application making the code and data both faster and
smaller. With such powerful features at the developer's disposal, what
is not to love?!&lt;/p&gt;
&lt;p&gt;Knowledge of Python, NumPy, C or C++, and basic HDF5 is recommended but
not required.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="outline"&gt;
&lt;h4&gt;Outline&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Meaning in layout (20 min)&lt;ul&gt;
&lt;li&gt;Tips for choosing your hierarchy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Advanced datatypes (20 min)&lt;ul&gt;
&lt;li&gt;Tables&lt;/li&gt;
&lt;li&gt;Nested types&lt;/li&gt;
&lt;li&gt;Tricks with malloc() and byte-counting&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exercise on above topics&lt;/strong&gt; (20 min)&lt;/li&gt;
&lt;li&gt;Chunking (20 min)&lt;ul&gt;
&lt;li&gt;How it works&lt;/li&gt;
&lt;li&gt;How to properly select your chunksize&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Queries and Selections (20 min)&lt;ul&gt;
&lt;li&gt;In-core vs Out-of-core calculations&lt;/li&gt;
&lt;li&gt;PyTables.where()&lt;/li&gt;
&lt;li&gt;Datasets vs Dataspaces&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exercise on above topics&lt;/strong&gt; (20 min)&lt;/li&gt;
&lt;li&gt;The Starving CPU Problem (1 hr)&lt;ul&gt;
&lt;li&gt;Why you should always use compression&lt;/li&gt;
&lt;li&gt;Compression algorithms available&lt;/li&gt;
&lt;li&gt;Choosing the correct one&lt;/li&gt;
&lt;li&gt;Exercise&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Integration with other databases (1 hr)&lt;ul&gt;
&lt;li&gt;Migrating to/from SQL&lt;/li&gt;
&lt;li&gt;HDF5 in other databases (JSON example)&lt;/li&gt;
&lt;li&gt;Other Databases in HDF5 (JSON example)&lt;/li&gt;
&lt;li&gt;Exercise&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="HDF5"></category><category term="PyTables"></category><category term="tutorial"></category></entry><entry><title>You Win or You SciPy</title><link href="https://pyvideo.org/scipy-2014/you-win-or-you-scipy.html" rel="alternate"></link><published>2014-07-09T00:00:00+00:00</published><updated>2014-07-09T00:00:00+00:00</updated><author><name>Andy Terrel</name></author><id>tag:pyvideo.org,2014-07-09:scipy-2014/you-win-or-you-scipy.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Reflections on the State of Scientific Python&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python is currently one of the most popular programming languages and it
seems that that Scientific Python has truly hit its stride in recent
years. With fame comes a deluge of users, but not necessarily any more
developers. Scientific Python is often held up as one of the core
strengths of the Python language. Why is this so? And how much does it
actually help us? This talk intends to be a frank discussion on the
great parts of the SciPy community and the parts that need work.&lt;/p&gt;
&lt;p&gt;As a confederation of packages and projects, there are several issues
that affect everyone. Sometimes these issues fall through the cracks and
other times they are vigorously tackled head on. In either case, I posit
that greater communication about these global topics is necessary to
support and scale to the next wave of SciPy users and developers.&lt;/p&gt;
&lt;p&gt;Points of discussion in this talk may include:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Packaging,&lt;/li&gt;
&lt;li&gt;Education,&lt;/li&gt;
&lt;li&gt;Matplotlib - aged or awesome,&lt;/li&gt;
&lt;li&gt;Competition from other languages,&lt;/li&gt;
&lt;li&gt;Diversity,&lt;/li&gt;
&lt;li&gt;Employing our own,&lt;/li&gt;
&lt;li&gt;Interfacing with the broader Python community,&lt;/li&gt;
&lt;li&gt;The legal status of projects, and&lt;/li&gt;
&lt;li&gt;Maintaining critical packages in the ecosystem (when devs have moved
on).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Historically, the SciPy conference has not had many overview talks,
talks about the community itself, what we are doing right, and what we
are doing wrong.&lt;/p&gt;
&lt;p&gt;They were often relegated to keynotes if they were present at all. This
talk is a boots-on-the-ground attempt to rectify that.&lt;/p&gt;
</summary></entry><entry><title>Lightning Talks - Friday evening</title><link href="https://pyvideo.org/pycon-us-2013/friday-evening-lightning-talks.html" rel="alternate"></link><published>2013-03-15T00:00:00+00:00</published><updated>2013-03-15T00:00:00+00:00</updated><author><name>MC Larry Hasting</name></author><id>tag:pyvideo.org,2013-03-15:pycon-us-2013/friday-evening-lightning-talks.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Lightning talks from Friday evening.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.youtube.com/watch?v=1vui-LupKJI#t=0m"&gt;00:00&lt;/a&gt; - Intro to Lightning Talks - MC Larry Hasting&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.youtube.com/watch?v=1vui-LupKJI#t=1m56s"&gt;01:56&lt;/a&gt; - Instrumental - Matthew J Desmarais&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.youtube.com/watch?v=1vui-LupKJI#t=7m14s"&gt;07:14&lt;/a&gt; - Statvent - Christian Wyglendowski&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.youtube.com/watch?v=1vui-LupKJI#t=12m4s"&gt;12:04&lt;/a&gt; - Switchboard - Kyle Adams&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.youtube.com/watch?v=1vui-LupKJI#t=16m14s"&gt;16:14&lt;/a&gt; - hy: a lisp variant - Paul Tag&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.youtube.com/watch?v=1vui-LupKJI#t=20m40s"&gt;20:40&lt;/a&gt; - 5 packages you need to know - Łukasz Langa&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.youtube.com/watch?v=1vui-LupKJI#t=26m24s"&gt;26:24&lt;/a&gt; - The future of Linux containers - Solomon
Hykes&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.youtube.com/watch?v=1vui-LupKJI#t=32m8s"&gt;32:08&lt;/a&gt; - SciPy 2013 - Andy Terrel, Anthony Scopatz&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.youtube.com/watch?v=1vui-LupKJI#t=35m39s"&gt;35:39&lt;/a&gt; - BirdFish - Preston Holmes&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.youtube.com/watch?v=1vui-LupKJI#t=41m20s"&gt;41:20&lt;/a&gt; - Julython - Robert Myers&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.youtube.com/watch?v=1vui-LupKJI#t=44m20s"&gt;44:20&lt;/a&gt; - CLDR: Common locale data repository - Martin
von Löwis&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.youtube.com/watch?v=1vui-LupKJI#t=48m49s"&gt;48:49&lt;/a&gt; - Spine demo and Python port of runtime - Terry
Simons&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="lightning talks"></category></entry></feed>