<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_michael-sarahan.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2018-07-10T00:00:00+00:00</updated><entry><title>The Sheer Joy of Packaging</title><link href="https://pyvideo.org/scipy-2018/the-sheer-joy-of-packaging.html" rel="alternate"></link><published>2018-07-10T00:00:00+00:00</published><updated>2018-07-10T00:00:00+00:00</updated><author><name>Michael Sarahan</name></author><id>tag:pyvideo.org,2018-07-10:scipy-2018/the-sheer-joy-of-packaging.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Building packages in Python used to be hard, especially the ones
including compiled extensions. Fortunately, it is getting easier thanks
to efforts in the scientific Python community. However, there are still
a lot of challenges and complexities facing the package builder.There
are at least two major packaging systems (pip/wheel and conda), and lots
of different ways to do work with these systems. This tutorial will
cover packaging from start to finish for both PyPI and conda, including
setup.py, flit, wheels, twine, conda-build, scikit-build, anaconda
cloud, and conda-forge. Particular attention will be paid to critical
details, such as binary compatibility and platform
differences.Presenter(s): Speaker: Michael Sarahan, Anaconda, Inc.
Speaker: Matthew McCormick, Kitware, Inc. Speaker: Jean-Christophe
Fillion-Robin, Kitware, Inc. Speaker: Filipe Fernandes, SECOORA Speaker:
Chris Barker, NOAA Speaker: Matt Craig, Minnesota State University
Moorhead Speaker: Jonathan Helmus, Anaconda, Inc. Speaker: Ray Donnelly,
Anaconda, Inc.&lt;/p&gt;
</summary><category term="tutorial"></category></entry><entry><title>Making packages and packaging "just work"</title><link href="https://pyvideo.org/pydata-seattle-2017/making-packages-and-packaging-just-work.html" rel="alternate"></link><published>2017-07-06T00:00:00+00:00</published><updated>2017-07-06T00:00:00+00:00</updated><author><name>Michael Sarahan</name></author><id>tag:pyvideo.org,2017-07-06:pydata-seattle-2017/making-packages-and-packaging-just-work.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python is a wonderful language, capable of gluing just about any number of other languages together, allowing us to reap the strengths of each language. The cost of this is myriad opportunities for library and binary incompatibility. This talk will cover some of the common ways that incompatibility arises, as well as several approaches that Continuum uses or is developing to reduce headache.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Abstract&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Each language and each package has some things that it does better than others. One of Python's major strengths is its ability to readily interface with many other languages and harness their strengths. When it comes to speed, compiled, statically-typed languages are hard to beat. Because of this, data science libraries often harness compiled shared libraries for their compute-intensive operations. In a small environment with few of these dependencies, this often works quite well. However, as the number of binary dependencies grows, the risk of incompatibility increases.&lt;/p&gt;
&lt;p&gt;The Anaconda distribution and its package manager, Conda, have been very successful as platforms in part because the wide array of packages built for Anaconda by Continuum are built to be binary compatible. Unfortunately, as more people and more communities build their own Conda packages that are not binary compatible with Anaconda or each other, more users have expressed confusion and consternation when things don't just work in all cases.&lt;/p&gt;
&lt;p&gt;To address this issue, we have needed to develop tooling at both package build time, to better track and establish the actual limits of binary compatibility, and also at package install time, to allow conda to make better use of this information to inform users of what they can expect to work. We’ll talk about new features in our build tool, conda-build, that helps us choose our desired binary compatibility. We’ll also talk about our new automated build system that helps us flesh out a much larger range of compatibility by building more combinations of packages with limited binary compatibility. Finally, we’ll also talk about the extra data that you’ll soon be able to provide to Conda, so that you will have more power to say exactly what you want.&lt;/p&gt;
</summary></entry></feed>