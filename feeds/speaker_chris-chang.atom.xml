<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_chris-chang.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2015-10-09T00:00:00+00:00</updated><entry><title>Managing Technical Debt in (Django) Projects</title><link href="https://pyvideo.org/pytexas-2015/managing-technical-debt-in-django-projects.html" rel="alternate"></link><published>2015-10-09T00:00:00+00:00</published><updated>2015-10-09T00:00:00+00:00</updated><author><name>Chris Chang</name></author><id>tag:pyvideo.org,2015-10-09:pytexas-2015/managing-technical-debt-in-django-projects.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;How did it come to this? How did we end up with an outdated Django
project that no one wants to touch? If starting new projects is fun and
maintaining them is a chore, then getting dropped into an existing
project is hell. For all our sanity, we should get better at recognizing
when we’re creating too much debt, and develop the skills for paying it
off. We talk about testing, code quality, and coverage. But why? Because
we want to spend less time dealing with technical debt and more time
creating new technical debt (aka new features). Many times, we think we
made the obvious smart decision only to regret it later; you discovered
you’re damned if you do, damned if you don’t. Should you write a
monolithic app or tangle of microservices? They’re all terrible worlds
we’ve made for ourselves. Having maintained, inherited, and created
several large Django projects, I hope to share my experience so you
don’t have to go through the same pains I did.&lt;/p&gt;
&lt;p&gt;We’ll start off with a few minutes covering basics like testing,
coverage and how they relate to the long term health of a project. Now,
everyone knowing the same terminology, we move on to learning to
recognize the many early warning signs and smells of excessive technical
debt. The most important thing, and most of the material is about
setting up the organizational structure for dealing with technical debt:
code review, continuous integration, rotating developers (no silos),
tradeoffs, making sure you have processes for onboarding new developers,
and strategies for documentation. It’s changes like these that end up
keeping things moving, not writing “better” code.&lt;/p&gt;
&lt;p&gt;Finally, we’ll wrap up with a few minutes talking about Django specific
tips: don’t customize the admin, tricks for naming things, signals,
organizing tests, and more. Much of this comes from things I wish I knew
at my time at The Texas Tribune, where we needed Django projects
launched the next day, all while maintaining a 6 year old Django
project, and my current time at TabbedOut where I was dropped into
maintaining several long lived software projects.&lt;/p&gt;
</summary></entry><entry><title>Managing technical debt in (Django) Projects</title><link href="https://pyvideo.org/djangocon-us-2015/managing-technical-debt-in-django-projects-by.html" rel="alternate"></link><published>2015-09-22T00:00:00+00:00</published><updated>2015-09-22T00:00:00+00:00</updated><author><name>Chris Chang</name></author><id>tag:pyvideo.org,2015-09-22:djangocon-us-2015/managing-technical-debt-in-django-projects-by.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Managing technical debt in (Django) Projects by Chris Chang&lt;/p&gt;
&lt;p&gt;We talk about testing, code quality, and coverage. But why? Because we
want to spend less time dealing with technical debt and more time
creating new technical debt (aka new features). Many times, we think we
made the obvious smart decision only to regret it later; you discovered
you’re damned if you do, damned if you don’t. Should you write a
monolithic app or tangle of microservices? They’re all terrible worlds
we’ve made for ourselves. Having maintained, inherited, and created
several large Django projects, I hope to share my experience so you
don’t have to go through the same pains I did.&lt;/p&gt;
&lt;p&gt;We’ll start off with a few minutes covering basics like testing,
coverage and how they relate to the long term health of a project. Now,
everyone knowing the same terminology, we move on to learning to
recognize the many early warning signs and smells of excessive technical
debt. The most important thing, and most of the material is about
setting up the organizational structure for dealing with technical debt:
code review, continuous integration, rotating developers (no silos),
tradeoffs, making sure you have processes for onboarding new developers,
and strategies for documentation. It’s changes like these that end up
keeping things moving, not writing “better” code.&lt;/p&gt;
&lt;p&gt;Finally, we’ll wrap up with a few minutes talking about Django specific
tips: don’t customize the admin, tricks for naming things, signals,
organizing tests, and more. Much of this comes from my time at The Texas
Tribune, where we needed Django projects launched the next day, all
while maintaining a 6 year old Django project.&lt;/p&gt;
&lt;p&gt;Help us caption &amp;amp; translate this video!&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://amara.org/v/HHp4/"&gt;http://amara.org/v/HHp4/&lt;/a&gt;&lt;/p&gt;
</summary></entry></feed>