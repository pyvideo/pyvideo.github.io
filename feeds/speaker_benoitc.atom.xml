<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_benoitc.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2013-09-14T00:00:00+00:00</updated><entry><title>Experimentation in porting the Go concurrency model to Python 3 by @benoitc</title><link href="https://pyvideo.org/pycon-apac-2013-in-japan/experimentation-in-porting-the-go-concurrency-model-to-python-3-by-benoitc.html" rel="alternate"></link><published>2013-09-14T00:00:00+00:00</published><updated>2013-09-14T00:00:00+00:00</updated><author><name>@benoitc</name></author><id>tag:pyvideo.org,2013-09-14:pycon-apac-2013-in-japan/experimentation-in-porting-the-go-concurrency-model-to-python-3-by-benoitc.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Lot of people are trying to port the actor pattern to Python, but this pattern isn't really designed for such languages. On the contrary the Go concurrency model has some attractive points that can be easily ported to Python. This talk will describe the go concurrency model and my own experimentation actually named flower to port it in Python. In this talk you will see how I am using greenlets or generators to handle corountines and optionally use pyuv to manage a non blocking IO poll server.&lt;/p&gt;
</summary></entry></feed>