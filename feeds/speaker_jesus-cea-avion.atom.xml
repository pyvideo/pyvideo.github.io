<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_jesus-cea-avion.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2018-10-07T00:00:00+00:00</updated><entry><title>GIL:Todo lo que quisite saber y no te atreviste a preguntar</title><link href="https://pyvideo.org/pycon-es-2018/giltodo-lo-que-quisite-saber-y-no-te-atreviste-a-preguntar.html" rel="alternate"></link><published>2018-10-07T00:00:00+00:00</published><updated>2018-10-07T00:00:00+00:00</updated><author><name>Jesús Cea Avión</name></author><id>tag:pyvideo.org,2018-10-07:pycon-es-2018/giltodo-lo-que-quisite-saber-y-no-te-atreviste-a-preguntar.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Se analiza el funcionamiento del GIL (Global Interpreter Lock), su utilidad, bajo qué condiciones se pasa la ejecución a otro hilo, el coste que supone operar con él, tanto cuando hay un cambio de contexto como cuando no, y las valoraciones que debe hacer el desarrollador de una extensión C a la hora de decidir si una operación debe retener el GIL o no. También se verá el caso en que tu intérprete Python esté embebido en una aplicación más grande. Se analizarán varios casos, se bajará a ensamblador (o casi) y más vale que tengas ciertos conocimientos de sistemas operativos.&lt;/p&gt;
&lt;p&gt;Se estudiará también cómo ha ido evolucionando el GIL en las diferentes versiones Python hasta llegar a donde estamos ahora.&lt;/p&gt;
</summary><category term="gil"></category></entry><entry><title>Python and DTrace</title><link href="https://pyvideo.org/pycon-sk-2016/python-and-dtrace.html" rel="alternate"></link><published>2016-03-12T00:00:00+00:00</published><updated>2016-03-12T00:00:00+00:00</updated><author><name>Jesús Cea Avión</name></author><id>tag:pyvideo.org,2016-03-12:pycon-sk-2016/python-and-dtrace.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;DTrace is a dynamic tracing framework able to comprehensively monitor a
complete live system, safely and with little performance impact. In this
talk we will talk about (unofficial) DTrace probes in Python and how can
you use them to integrate Python processes in the DTrace tracing
framework as first class citizens without any modification at all. Live
monitor your python programs for free! No code changes, no performance
impact. Get insights into the behavior of your system.&lt;/p&gt;
</summary></entry></feed>