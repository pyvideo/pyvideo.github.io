<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_gregory-saunders.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2017-08-05T00:00:00+00:00</updated><entry><title>A Really Gentle Introduction to Asyncio</title><link href="https://pyvideo.org/pycon-au-2017/a-really-gentle-introduction-to-asyncio.html" rel="alternate"></link><published>2017-08-05T00:00:00+00:00</published><updated>2017-08-05T00:00:00+00:00</updated><author><name>Gregory Saunders</name></author><id>tag:pyvideo.org,2017-08-05:pycon-au-2017/a-really-gentle-introduction-to-asyncio.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;I/O is slow (so very very slow) and waiting for it takes forever
(metaphorically speaking). In this session you'll learn how to use
all that waiting time productively with Python's asyncio module.&lt;/p&gt;
&lt;p&gt;First you'll find out how to make two things happen at the same time
without those pesky, error-prone, threads and you'll find out what's
going on under the hood with the event loop.&lt;/p&gt;
&lt;p&gt;Next you'll get a handle on the future with Futures (no, not the financial
kind!). Then learn how to move all your data around with transports and
how to communicate with protocols.&lt;/p&gt;
&lt;p&gt;Finally, put it all together and learn how to fire up a networked application
and system test it from all sides!&lt;/p&gt;
</summary></entry><entry><title>Pyrobuf and the Tyranny of Speed</title><link href="https://pyvideo.org/pycon-au-2016/pyrobuf-and-the-tyranny-of-speed.html" rel="alternate"></link><published>2016-08-15T00:00:00+00:00</published><updated>2016-08-15T00:00:00+00:00</updated><author><name>Gregory Saunders</name></author><id>tag:pyvideo.org,2016-08-15:pycon-au-2016/pyrobuf-and-the-tyranny-of-speed.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Gregory Saunders
&lt;a class="reference external" href="https://2016.pycon-au.org/schedule/171/view_talk"&gt;https://2016.pycon-au.org/schedule/171/view_talk&lt;/a&gt;
The data structures used to represent information and program state in memory are rarely conducive to the storage and transmission of that information and state. The process of translating those data structures into a format better suited to storage is known as serialisation or marshalling.&lt;/p&gt;
&lt;p&gt;Google’s Protobuf is a mechanism for serialising and deserialising structured data. Pyrobuf is a alternative, lightning-fast, implementation of Protobuf written in Cython that is 2-4 times faster than Protobuf when using its C++ backend and 20-40 times faster than its pure Python implementation.&lt;/p&gt;
&lt;p&gt;In this talk we’ll briefly review Protobuf and compare it to other well known serialisation mechanisms such as XML and JSON. We’ll then take a look at Pyrobuf and the basic strategies it uses to achieve significantly better performance.&lt;/p&gt;
&lt;p&gt;Pyrobuf’s main claim to fame is its speed. This makes fixing bugs and adding new features a real challenge as any degradation in performance will not be well-received by users who’ve come to expect and rely on its speed. Therefore, for the remainder of the talk we’ll discuss tricks and tips, some more legitimate than others, for maintaining speed as new features are added.&lt;/p&gt;
</summary><category term="pyrobuf"></category></entry><entry><title>Adventures in scikit-learn's Random Forest</title><link href="https://pyvideo.org/pycon-au-2015/adventures-in-scikit-learns-random-forest.html" rel="alternate"></link><published>2015-08-04T00:00:00+00:00</published><updated>2015-08-04T00:00:00+00:00</updated><author><name>Gregory Saunders</name></author><id>tag:pyvideo.org,2015-08-04:pycon-au-2015/adventures-in-scikit-learns-random-forest.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Scikit-learn's Random Forests are a great first choice for tackling a
machine-learning problem. They are easy to use with only a handful of
tuning parameters but nevertheless produce good results. Additionally, a
separate cross-validation step can be avoided using the out-of-bag
sample predictions generated during the construction of the forest, and
finally they make it relatively easy to identify and extract the most
important features of the sample data.&lt;/p&gt;
&lt;p&gt;In this talk we’ll go through the process of using scikit-learn’s random
forests using a financial data-set (of ASX equities) as an example.
We’ll begin with a basic overview of the random forest algorithm and of
the tuning parameters available and their impact on the effectiveness of
the forest. Secondly we’ll go over the basic usage of scikit-learn’s
random forests and in the process trouble-shoot some common problems
such as dealing with missing sample data. Next we’ll discuss the use of
out-of-bag sample predictions as a method for quickly performing
cross-validation and optimising the tuning parameters. Finally we’ll
look at how to extract information from the model that scikit-learn has
generated, most notably the relative importances of the features in the
sample data.&lt;/p&gt;
</summary></entry></feed>