<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Fri, 07 Apr 2017 00:00:00 +0000</lastBuildDate><item><title>Getting started with requests HTTP library</title><link>https://pyvideo.org/pycon-italia-2017/getting-started-with-requests-http-library.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;requests is one of the most advanced and simple to use HTTP libraries.&lt;/p&gt;
&lt;p&gt;The presentations is going to show how to get started with it, how to
consume REST APIs and last but not least how to properly mock and test
our code.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Andrea Grandi</dc:creator><pubDate>Fri, 07 Apr 2017 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2017-04-07:pycon-italia-2017/getting-started-with-requests-http-library.html</guid><category>requests</category><category>api</category><category>networking</category><category>REST</category></item><item><title>Monkeying Around with Python at New Relic</title><link>https://pyvideo.org/djangocon-us-2011/djangocon-2011--monkeying-around-with-python-at-n.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Monkeying around with Python at New Relic&lt;/p&gt;
&lt;p&gt;Presented by Graham Dumpleton&lt;/p&gt;
&lt;p&gt;This session will cover the challenges of creating a production
application performance monitoring system for Python. It includes an
overview of the architecture of the system, as well as how it hooks into
Django and captures details about web transactions, database
transactions, memcache requests, exceptions and much more.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Graham Dumpleton</dc:creator><pubDate>Mon, 05 Sep 2011 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2011-09-05:djangocon-us-2011/djangocon-2011--monkeying-around-with-python-at-n.html</guid><category>djangocon</category><category>djangocon2011</category><category>exceptions</category><category>memcache</category><category>monitoring</category><category>performance</category><category>requests</category><category>transactions</category></item><item><title>Spotify: Horizontal scalability for great success</title><link>https://pyvideo.org/europython-2011/spotify-horizontal-scalability-for-great-success.html</link><description>&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Nick Barkas - 22 June 2011 in &amp;quot;Track Spaghetti&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;If you run on CPython, it's not possible to get a single-process,
multithreaded Python program to use more than one CPU core at a time
because of the Global Interpreter Lock (GIL). A common way of dealing
with this is to run one instance of a Python program for each core a
machine has and spread the load amongst those processes. This forces
developers to write simple, stateless programs that naturally scale out
to many many servers when needed, while also not having to think about
things like locking and thread scheduling.&lt;/p&gt;
&lt;p&gt;I'll discuss some tools and methods Spotify's backend uses for managing
multiple identical server processes as well as load balancing with DNS,
proxy servers, and using hashing to send repeated requests to the same
process. I will also talk about the difficulties that arise when you
really need to share data or state between processes, and how they can
be dealt with.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Nick Barkas</dc:creator><pubDate>Wed, 13 Jul 2011 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2011-07-13:europython-2011/spotify-horizontal-scalability-for-great-success.html</guid><category>requests</category><category>scalability</category></item></channel></rss>