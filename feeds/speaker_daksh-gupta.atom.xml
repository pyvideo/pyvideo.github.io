<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org - Daksh Gupta</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_daksh-gupta.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2024-05-15T00:00:00+00:00</updated><subtitle></subtitle><entry><title>The world of High Performance Distributed &amp; Async Task Queue(s) with Celery</title><link href="https://pyvideo.org/pycon-us-2024/the-world-of-high-performance-distributed-async-task-queues-with-celery.html" rel="alternate"></link><published>2024-05-15T00:00:00+00:00</published><updated>2024-05-15T00:00:00+00:00</updated><author><name>Daksh Gupta</name></author><id>tag:pyvideo.org,2024-05-15:/pycon-us-2024/the-world-of-high-performance-distributed-async-task-queues-with-celery.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;All modern systems use &lt;strong&gt;distributed&lt;/strong&gt; and &lt;strong&gt;asynchronous&lt;/strong&gt; tasks to
make proper use of the available hardware and software resources in a
safe and reliable manner. The ability to create and distribute
asynchronous tasks drastically impact the performance as well as the
capability of a system.&lt;/p&gt;
&lt;p&gt;The most popular way …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;All modern systems use &lt;strong&gt;distributed&lt;/strong&gt; and &lt;strong&gt;asynchronous&lt;/strong&gt; tasks to
make proper use of the available hardware and software resources in a
safe and reliable manner. The ability to create and distribute
asynchronous tasks drastically impact the performance as well as the
capability of a system.&lt;/p&gt;
&lt;p&gt;The most popular way of creating asynchronous task queues involves using
streams or pub/sub infrastructures like &lt;strong&gt;Apache Kafka&lt;/strong&gt;, &lt;strong&gt;RabbitMQ&lt;/strong&gt;,
&lt;strong&gt;Kinesis&lt;/strong&gt; etc, more or less, are equally suitable for a variety of
scenarios.&lt;/p&gt;
&lt;p&gt;Then, the question is why we’re talking something else i.e. &lt;strong&gt;“Celery”&lt;/strong&gt;
over here? The answer is &lt;strong&gt;“Python Programming Language”&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;If you're creating a system (especially microservices based and/or
distributed systems) in &lt;strong&gt;python__ and want to create an asynchronous
(and distributed) task queues which is pure python, simple, super fast,
and diminishes the boundary between distributed systems_, then you
should consider using&lt;/strong&gt; “Celery”___.&lt;/p&gt;
&lt;p&gt;Using something like &lt;strong&gt;“Celery”&lt;/strong&gt; is not about being better than other
solutions out there, it’s all about the ability to make use of the
python ecosystem and create things faster without leaving the python
programming language for something else.&lt;/p&gt;
&lt;p&gt;Welcome to this tutorial on Celery, the open source distributed task
queues. In this tutorial, we'll learn how to use &lt;strong&gt;“Celery”&lt;/strong&gt; and create
an end to end system. We’ll also learn about how we can also visualize
the distributed task queues at runtime using &lt;strong&gt;“Flower”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This tutorial will have classroom exercises, post class homeworks as
well as complimentary readings. All the presentation, code, exercises
will be shared in advance (~ 2 - 3 days) and the solutions of the
exercise will be shared after the tutorial is completed.&lt;/p&gt;
</content><category term="PyCon US 2024"></category></entry></feed>