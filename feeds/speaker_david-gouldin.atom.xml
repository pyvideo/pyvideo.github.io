<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_david-gouldin.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2018-05-11T00:00:00+00:00</updated><entry><title>import time_travel: A Primer on Timezones in Python</title><link href="https://pyvideo.org/pycon-us-2018/import-time_travel-a-primer-on-timezones-in-python.html" rel="alternate"></link><published>2018-05-11T00:00:00+00:00</published><updated>2018-05-11T00:00:00+00:00</updated><author><name>David Gouldin</name></author><id>tag:pyvideo.org,2018-05-11:pycon-us-2018/import-time_travel-a-primer-on-timezones-in-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Timezones are one of those things every programmer loves to hate. Most of us, at
least in the US, just try to ignore them and hope nobody notices. Then twice a
year, we fear with impending doom those 3 small words: Daylight Saving Time.&lt;/p&gt;
&lt;p&gt;It doesn't have to be this way. Armed with some best practices and a little help
from supporting libraries, timezone-related bugs can be a thing of the past.&lt;/p&gt;
&lt;p&gt;This talk explores standard library and 3rd party library timezone support, as
well as persistence and serialization techniques for timezone-aware datetimes.
By the end of the talk, the listener should feel confident in their ability to
correctly store, send, receive, and manipulate datetime objects in any timezone.&lt;/p&gt;
</summary></entry><entry><title>Django's role in the polyglot web</title><link href="https://pyvideo.org/djangocon-europe-2015/david-gouldin-djangos-role-in-the-polyglot-web-at.html" rel="alternate"></link><published>2015-07-10T00:00:00+00:00</published><updated>2015-07-10T00:00:00+00:00</updated><author><name>David Gouldin</name></author><id>tag:pyvideo.org,2015-07-10:djangocon-europe-2015/david-gouldin-djangos-role-in-the-polyglot-web-at.html</id><summary type="html"></summary></entry><entry><title>Painting on a Distributed Canvas: An Advanced Guide to Celery Workflows</title><link href="https://pyvideo.org/pyohio-2014/painting-on-a-distributed-canvas-an-advanced-gui.html" rel="alternate"></link><published>2014-07-27T00:00:00+00:00</published><updated>2014-07-27T00:00:00+00:00</updated><author><name>David Gouldin</name></author><id>tag:pyvideo.org,2014-07-27:pyohio-2014/painting-on-a-distributed-canvas-an-advanced-gui.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Celery is great for asynchronously sending emails from your web app. But
what happens when you grow beyond simple &amp;quot;set it and forget it&amp;quot; tasks?
This talk explores Celery's workflow primitives and how to create
complex distributed applications. It assumes knowledge of Python and
Celery. By the end, you will better understand how to structure
distributed work that robustly scales.&lt;/p&gt;
</summary><category term="talk"></category></entry><entry><title>Lightning Talks - Day 1</title><link href="https://pyvideo.org/djangocon-us-2010/djangocon-2010--lightning-talks---day-1.html" rel="alternate"></link><published>2010-09-07T00:00:00+00:00</published><updated>2010-09-07T00:00:00+00:00</updated><author><name>David Gouldin</name></author><id>tag:pyvideo.org,2010-09-07:djangocon-us-2010/djangocon-2010--lightning-talks---day-1.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;ul class="simple"&gt;
&lt;li&gt;00:00 - David Gouldin: Hash Signaling Made Easy
(&lt;a class="reference external" href="http://github.com/dgouldin/django-hashsignal"&gt;http://github.com/dgouldin/django-hashsignal&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;05:20 - Tareque Mossain: Django ORM Tips&lt;/li&gt;
&lt;li&gt;11:20 - Nathan?: OpenID in Django&lt;/li&gt;
&lt;li&gt;18:00 - Ben? and Jeremy?: Django efficacy project--call for case
studies&lt;/li&gt;
&lt;li&gt;19:40 - Tobias McNulty: django.contrib.messages and contributing to
Django core&lt;/li&gt;
&lt;li&gt;25:00 - Jason ?: Django Config Store
(&lt;a class="reference external" href="http://github.com/zbyte64/django-configstore"&gt;http://github.com/zbyte64/django-configstore&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;28:25 - Niall Kelly: Giving Django a new front door&lt;/li&gt;
&lt;li&gt;32:00 - Justin Lilly: Meetup Meeter&lt;/li&gt;
&lt;li&gt;33:50 - Jesse Noller: WTF: PSF and DSF&lt;/li&gt;
&lt;li&gt;40:00 - dmoisset ?: How request routing should be&lt;/li&gt;
&lt;li&gt;45:30 - Gabriel Falcao: Feeding your ponies with lettuce
(&lt;a class="reference external" href="http://lettuce.it/"&gt;http://lettuce.it/&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;50:40 - Nate Aune: djangozoom: Effortless cloud deployment
(&lt;a class="reference external" href="http://djangozoom.com/ponyexpress"&gt;http://djangozoom.com/ponyexpress&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[NOTE: If you know the people whose names have a ?, please add a comment
so we can fix it in the description. Thanks!]&lt;/p&gt;
</summary><category term="lightning talks"></category><category term="django-configstore"></category><category term="django.contrib.messages"></category><category term="django-hashsignal"></category><category term="djangozoom"></category><category term="dsf"></category><category term="hash-signaling"></category><category term="lettuce"></category><category term="openid"></category><category term="orm"></category><category term="psf"></category><category term="routing"></category></entry><entry><title>Using Celery with Social Networks</title><link href="https://pyvideo.org/djangocon-us-2012/using-celery-with-social-networks.html" rel="alternate"></link><published>2012-09-05T00:00:00+00:00</published><updated>2012-09-05T00:00:00+00:00</updated><author><name>David Gouldin</name></author><id>tag:pyvideo.org,2012-09-05:djangocon-us-2012/using-celery-with-social-networks.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Many web applications need to interface with social networks, and
celery, a Python distributed task queue library, is a great tool for the
job. However, achieving speed and stability can be difficult. This talk
will cover task organization/distribution, rate limiting, failover, and
other practices to aid in working with social networks at scale.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Twitter conditionally rate limits based on IP address rather than access
token even when one is provided for some of its API calls. Facebook has
at least 10 unique error messages to indicate a bad or expired access
token (that I've found so far). LinkedIn's pagination has an occasional
off-by-one bug resulting in an endless list of 1-user pages. Let's face
it: interfacing with social networks is tricky. Celery helps, but to
provide stable, reliable, and fast social features for your website,
you'll need an arsenal of strategies and tools to get you the rest of
the way there.&lt;/p&gt;
&lt;p&gt;By the end of this talk, you'll understand how to set up tasks to
quickly serve users with massive networks by employing intelligent
distribution. You'll be able to design robust processes to handle
inconsistencies or instabilities in 3rd party APIs. And you'll know how
to have confidence that the work you intend to do gets done, regardless
of external rate limits, pagination design, or API call dependency
chains.&lt;/p&gt;
&lt;p&gt;This talk is intended for people who have basic familiarity with celery
and would like to learn more about how to take advantage of it for
large, distributed task loads.&lt;/p&gt;
&lt;div class="section" id="outline"&gt;
&lt;h4&gt;Outline&lt;/h4&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Intro&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;3rd party interfaces are hard&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Speed&lt;ul&gt;
&lt;li&gt;Much slower than local data&lt;/li&gt;
&lt;li&gt;Users may still expect near-immediate results&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Rate limits&lt;ul&gt;
&lt;li&gt;Different rules for every service&lt;/li&gt;
&lt;li&gt;Need to handle reactive &amp;amp; proactive as some don't publish
rates&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Instability&lt;ul&gt;
&lt;li&gt;Outages (yes, Facebook does go down)&lt;/li&gt;
&lt;li&gt;Random failures&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Why Celery?&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Asynchronous&lt;/li&gt;
&lt;li&gt;Distributed&lt;/li&gt;
&lt;li&gt;Fault tolerant&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Task Organization&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Small, atomic tasks (1 API call per task) B. Minimal message state&lt;ul&gt;
&lt;li&gt;Primitive types only (no model instances!)&lt;/li&gt;
&lt;li&gt;Defer as much data access to the task itself as possible&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Create Task subclasses for common patterns D. Whenever possible,make tasks idempotent&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Task Distribution&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Managing pagination&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;For a known set size&lt;ul&gt;
&lt;li&gt;Where limit/offset is supported, launch all page tasks
simlutaneously&lt;/li&gt;
&lt;li&gt;Otherwise, 1 page launches the next as soon as the next
cursor is obtained&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;For an unknown set size&lt;ul&gt;
&lt;li&gt;Set max simultaneous pages&lt;/li&gt;
&lt;li&gt;Task is terminal if blank, otherwise launches page w/
offset + max pages&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Setting page size is an art, not a science&lt;ul&gt;
&lt;li&gt;Minimize the number of api calls when possible&lt;/li&gt;
&lt;li&gt;Avoid long-running tasks by setting a timeout ceiling&lt;/li&gt;
&lt;li&gt;Avoid the temptation to pass API data to dependent tasks&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Tracking task dependencies (&amp;quot;Done?&amp;quot; is difficult for distributed systems)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Use an external backend to store a dependency tree&lt;/li&gt;
&lt;li&gt;Subclass ResultSet to evaluate the task state of the tree&lt;/li&gt;
&lt;li&gt;Requires ignore_result=False&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Rate Limiting&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Problems&lt;ul&gt;
&lt;li&gt;Celery's rate limiting doesn't do what you think it does&lt;/li&gt;
&lt;li&gt;3rd party rate limits depend on many factors&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Solution&lt;ul&gt;
&lt;li&gt;For services with known rate limits:&lt;ul&gt;
&lt;li&gt;Use an external backend to store rate limit counters&lt;/li&gt;
&lt;li&gt;Increment counters based on rate limit factors per api call&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;For services with unknown rate limits:&lt;ul&gt;
&lt;li&gt;Use an external backend to store rate limit backoff counters&lt;/li&gt;
&lt;li&gt;Ramp up / ratchet down call rate by power law as api callsfail/succeed&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Failover&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Problems&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Celery's countdown doesn't do what you think it does&lt;/li&gt;
&lt;li&gt;3rd parties can fail in lots of &amp;quot;interesting&amp;quot; ways&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Solution&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Implement native RabbitMQ alternative to countdown&lt;/li&gt;
&lt;li&gt;Create task base classes per social network to handle error
conditions&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Multiple queues&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Better control over task priority management &amp;amp; resource distribution&lt;/li&gt;
&lt;li&gt;Not all social accounts are created equal (handling whales &amp;amp; spikes)&lt;/li&gt;
&lt;li&gt;When you can't stream updates, use a trickle queue&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Celerybeat considered harmful&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Periodic task persistence gets out of sync with code&lt;/li&gt;
&lt;li&gt;Just 1 more process to manage&lt;/li&gt;
&lt;li&gt;Cron: it's just. not. that. hard.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Debugging&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Don't use &amp;quot;always eager&amp;quot;&lt;/li&gt;
&lt;li&gt;Logging, logging, logging&lt;/li&gt;
&lt;li&gt;Unit tests are good, but integration tests save lives&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Gotchas&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Open socket prevents Celery soft timeout&lt;/li&gt;
&lt;li&gt;Celery soft timeout doesn't retry the task&lt;/li&gt;
&lt;li&gt;If result state is not known, Celery reports &amp;quot;PENDING&amp;quot;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</summary><category term="celery"></category><category term="django"></category></entry></feed>