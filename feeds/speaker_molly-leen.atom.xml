<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_molly-leen.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2018-10-05T00:00:00+00:00</updated><entry><title>How to Trick SQL into Doing All the Work for You</title><link href="https://pyvideo.org/pygotham-2018/how-to-trick-sql-into-doing-all-the-work-for-you.html" rel="alternate"></link><published>2018-10-05T00:00:00+00:00</published><updated>2018-10-05T00:00:00+00:00</updated><author><name>Molly Leen</name></author><id>tag:pyvideo.org,2018-10-05:pygotham-2018/how-to-trick-sql-into-doing-all-the-work-for-you.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Consider the process of importing data into a SQL database with a SQL COPY within your Python app. As data grows, it becomes more and more important that your preprocessing steps are as efficient as possible.&lt;/p&gt;
&lt;p&gt;You must validate and reformat before importing the data. If SQL has control over the import step, most would think that at least one additional iteration is needed to validate and format before sending to COPY. But what if you tricked the copy step into doing the validating and formatting for you?&lt;/p&gt;
&lt;p&gt;In this talk, I will demonstrate how to create a file-like object that COPY will use to validate and reformat the data as it is read. This will remove inefficiencies when processing large data sets and prevent execution time from growing. While this talk explores sending a file-like object to a copy command, the technique can be extended to any method that reads from an object.&lt;/p&gt;
</summary></entry></feed>