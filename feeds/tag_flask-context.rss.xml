<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org - flask context</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Sun, 05 Jul 2020 00:00:00 +0000</lastBuildDate><item><title>Automatically generate test-cases – Schema-based API testing</title><link>https://pyvideo.org/flaskcon-2020/automatically-generate-test-cases-schema-based-api-testing.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The goal with this talk is to introduce the audience to property-based testing for API’s using schemas to automatically generate test scenarios, enabling them to write more powerful tests faster. The talk will focus on a subset of the field of property-based testing where we focus on testing by automatically generating properties and test strategies from the API Schemas that we often already have. These tests ensure that our APIs conform to their specified schema and enables us to write a much larger amount of tests in less time. I will focus on the schemathesis library which leverages the strong hypothesis library as well as the hypothesis-JSONSchema extension strategies, and will in the future also support GraphQL via the hypothesis-graphql strategies. I’m a contributor to schemathesis and currently working on the future GraphQL support with schemathesis creator, Dmitry Dygalo. I will also compare it with its predecessor “swagger-conformance”, pure property-based testing through hypothesis, schema strategies with hypothesis-graphql and hypothesis-jsonschema, and discuss their advantages and disadvantages. I will also briefly talk about “QuickREST: Property-based Test Generation of OpenAPI-Described RESTful APIs” (&lt;a class="reference external" href="https://arxiv.org/abs/1912.09686"&gt;https://arxiv.org/abs/1912.09686&lt;/a&gt;), the research paper that’s part of the inspiration for these tools. By focusing on property-based test generation using schemas we already have, I will show that a field like property-based testing, which can seem quite daunting at first, actually can have a low barrier to entry while yielding large amounts of value in return and is useful for most common web projects today. The talk will show how formal schemas for APIs can and will continue to provide additional value outside the scope of documentation.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alexander Hultnér</dc:creator><pubDate>Sun, 05 Jul 2020 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2020-07-05:/flaskcon-2020/automatically-generate-test-cases-schema-based-api-testing.html</guid><category>FlaskCon 2020</category><category>flask context</category><category>Flask</category><category>FlaskCon</category></item><item><title>Flask's flexibility for the win (when building applications that don't follow the normal patterns)</title><link>https://pyvideo.org/flaskcon-2020/flasks-flexibility-for-the-win-when-building-applications-that-dont-follow-the-normal-patterns.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Flask's flexibility made it the ideal choice of web framework to develop a semantic graph-based application. Specifically, being able to &amp;quot;hook up&amp;quot; a custom data back-end without breaking a sweat clinched the deal. The application in question that I would like to talk about is Contextualise (&lt;a class="reference external" href="https://www.contextualise.dev/"&gt;https://www.contextualise.dev/&lt;/a&gt;), a (personal) knowledge management application. Contextualise is an open source project: &lt;a class="reference external" href="https://github.com/brettkromkamp/contextualise"&gt;https://github.com/brettkromkamp/contextualise&lt;/a&gt;&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Brett Kromkamp</dc:creator><pubDate>Sun, 05 Jul 2020 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2020-07-05:/flaskcon-2020/flasks-flexibility-for-the-win-when-building-applications-that-dont-follow-the-normal-patterns.html</guid><category>FlaskCon 2020</category><category>flask context</category><category>Flask</category><category>FlaskCon</category></item><item><title>Demystifying Flask's Application and Request Contexts with pytest</title><link>https://pyvideo.org/flaskcon-2020/demystifying-flasks-application-and-request-contexts-with-pytest.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The application and request contexts are key parts of any Flask application, as they control which variables are and are not globally accessible. Understanding how each context works is important when developing Flask applications, and yet they are often misunderstood. This talk dives into how the application and request contexts work when handling a request. The concept of proxies is discussed for providing thread-local access to the application and request contexts. To really illustrate how the application context works, pytest will be utilized to show how the application context works outside of a request. This example shows a common error ('Working outside of application context') during testing and how it should be solved by pushing to the application context stack.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Patrick Kennedy</dc:creator><pubDate>Sat, 04 Jul 2020 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2020-07-04:/flaskcon-2020/demystifying-flasks-application-and-request-contexts-with-pytest.html</guid><category>FlaskCon 2020</category><category>flask context</category><category>Flask</category><category>FlaskCon</category></item></channel></rss>