<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Fri, 12 Jul 2019 00:00:00 +0000</lastBuildDate><item><title>Python Standard Library, The Hidden Gems</title><link>https://pyvideo.org/europython-2019/python-standard-library-the-hidden-gems.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The Python Standard Library is a very rich toolset, which is the reason
why Python is stated to come with &amp;quot;batteries included&amp;quot;. In such an
amount of features and tools it's easy to get lost and miss some of the
less unknown modules or gems hidden within the whole load of functions
and classes.&lt;/p&gt;
&lt;p&gt;This talk aims at showcasing some recipes, snippets and usages of
standard library modules and functions that are less known or that are
not covered in the most common books and tutorials available for Python.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;The talk will try to showcase a bunch of short examples in the hope to
foster the &amp;quot;oh, wow! I didn't think about that&amp;quot; reaction at least once
in the audience.&lt;/div&gt;
&lt;div class="line"&gt;We will see how frequently for tasks where you used third party
libraries or frameworks a solution bultin into the standard library is
already available, and such solution is guaranteed to be maintained
and well working for the years to come thanks to the standard library
reliability and stability.&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;The showcased examples are took from the “Modern Python Standard Library
Cookbook” book that I authored.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alessandro Molina</dc:creator><pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-07-12:europython-2019/python-standard-library-the-hidden-gems.html</guid><category>CPython</category><category>Debugging</category><category>Development</category><category>General</category><category>python</category></item><item><title>The Agile comedy: from hell to paradise</title><link>https://pyvideo.org/europython-2019/the-agile-comedy-from-hell-to-paradise.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Nowadays everyone wants to bring Agile Best Practices into all the
teams, but it's a hard task to implement it and adapt based on
different teams. Setting up all necessary Agile meetings and using
buzz words is not enough for the team to be happy and successful while
working in Agile environment.&lt;/div&gt;
&lt;div class="line"&gt;Inspired by the &amp;quot;Divine Comedy&amp;quot; by Dante Alighieri, I decided to
create a short guide into Agile best practices. It will guide through
Failures, Challenges to the Success in building a happy dream team!&lt;/div&gt;
&lt;div class="line"&gt;This talk is divided into three parts:&lt;/div&gt;
&lt;div class="line"&gt;1. Failures in setting up Agile processes for a team.&lt;/div&gt;
&lt;div class="line"&gt;2. Challenges on the way to happy and successful team.&lt;/div&gt;
&lt;div class="line"&gt;3. Successful examples how to have happy and productive Agile team and
constantly deliver a great product.&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Anastasiia Tymoshchuk</dc:creator><pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-07-12:europython-2019/the-agile-comedy-from-hell-to-paradise.html</guid><category>Agile</category><category>Development</category><category>General</category></item><item><title>Exceptional Exceptions</title><link>https://pyvideo.org/europython-2019/exceptional-exceptions.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Did you know there are multiple ways to raise and capture exceptions?
Have you ever wondered if you should raise a built-in exception or
create your own hierarchy? Did you ever find it hard to understand
what an exception meant?&lt;/div&gt;
&lt;div class="line"&gt;This talk will go through the decisions needed to raise and capture
exceptions when creating a library. We will look at how to translate
and handle errors, create your own exceptions, and make exceptions
clear and easy to troubleshoot, while also understanding how they
actually work, common pitfalls.&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This talk will enable intermediate developers to leave the room with a
solid understanding of how to work effectively with exceptions. As the
exception flow usually goes untested, this will help prevent frustrating
situations when errors occur that are not easy to understand or when an
unexpected result is produced. The talk will delve into the different
ways of working with exceptions. We will illustrate this with a
real-world example to which many developers will be able to relate.&lt;/p&gt;
&lt;p&gt;Following the talk, intermediate developers will leave the room more
informed and better prepared to create and handle exceptions, having
learned about many utilities that were already available to them, but
were never used or were used improperly.&lt;/p&gt;
&lt;p&gt;The not-so-advanced Pythonistas will get an in-depth dive into
exceptions. Even if they might not be able to grasp all of the content,
they will get a sense of the features that most programmers are unaware
of and learn to use them when the proper situation arrives.&lt;/p&gt;
&lt;p&gt;Advanced programmers will find this to be a humorous talk that will
certainly teach them at least one new thing, as I will dive into parts
of the grammar of Python that even many advanced programmers are not
used to.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;The talk is also full of niche information like why the variable that
catches exceptions doesn’t like outside of the &lt;tt class="docutils literal"&gt;except&lt;/tt&gt; scope.&lt;/div&gt;
&lt;div class="line"&gt;The talk is comprised of four main sections preceded by an
introduction to the problem and a conclusion with time for questions
at the end. We will look at how to raise, capture, create and design
exceptions, offering tips and pitfalls in each section.&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Mario Corchero</dc:creator><pubDate>Thu, 11 Jul 2019 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2019-07-11:europython-2019/exceptional-exceptions.html</guid><category>Best Practice</category><category>Development</category><category>General</category><category>Python 3</category><category>Python Skills</category></item><item><title>IPython: tools for the entire lifecycle of research computing</title><link>https://pyvideo.org/scipy-2012/ipython-tools-for-the-entire-lifecycle-of-resear.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;IPython started as a better interactive Python interpreter in 2001, but
over the last decade it has grown into a rich and powerful set of
interlocking tools aimed at enabling an efficient, fluid and productive
workflow in the typical use cases encountered by scientists in everyday
research.&lt;/p&gt;
&lt;p&gt;Today, IPython consists of a kernel executing user code and capable of
communicating with a variety of clients, using ZeroMQ for networking via
a well-documented protocol. This enables IPython to support, from a
single codebase, a rich variety of usage scenarios through user-facing
applications and an API for embedding:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;An interactive, terminal-based shell with many capabilities far
beyond the default Python interactive interpreter (this is the
default application opened by the &lt;tt class="docutils literal"&gt;ipython&lt;/tt&gt; command that most users
are familiar with).&lt;/li&gt;
&lt;li&gt;A Qt console that provides the look and feel of a terminal, but adds
support for inline figures, graphical calltips, a persistent session
that can survive crashes of the kernel process, and more.&lt;/li&gt;
&lt;li&gt;A web-based notebook that can execute code and also contain rich text
and figures, mathematical equations and arbitrary HTML. This notebook
presents a document-like view with cells where code is executed but
that can be edited in-place, reordered, mixed with explanatory text
and figures, etc.&lt;/li&gt;
&lt;li&gt;A high-performance, low-latency system for parallel computing that
supports the control of a cluster of IPython engines communicating
over ZeroMQ, with optimizations that minimize unnecessary copying of
large objects (especially numpy arrays).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this talk we will show how IPython supports all stages in the
lifecycle of a scientific idea: individual exploration, collaborative
development, large- scale production using parallel resources,
publication and education. In particular, the IPython Notebook supports
multiuser collaboration and allows scientists to share their work in an
open document format that is a true &amp;quot;executable paper&amp;quot;: notebooks can be
version controlled, exported to HTML or PDF for publication, and used
for teaching. We will demonstrate the key features of the system,&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Brian Granger</dc:creator><pubDate>Thu, 19 Jul 2012 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2012-07-19:scipy-2012/ipython-tools-for-the-entire-lifecycle-of-resear.html</guid><category>General</category></item><item><title>nD image segmentation using learned region agglomeration with the Ray Python library</title><link>https://pyvideo.org/scipy-2012/nd-image-segmentation-using-learned-region-agglom.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;One of the principal goals of the Janelia Farm Research Campus is the
reconstruction of complete neuronal circuits. This involves 3D electron-
microscopy (EM) volumes many microns across with better than 10nm
resolution, resulting in gigavoxel scale images. From these, individual
neurons must be segmented out. Although image segmentation is a
well-studied problem, these data present unique challenges in addition
to scale: neurons have an elongated, irregular branching structure, with
processes up to 50nm thin but hundreds of micrometers long); one neuron
looks much like the next, with only a thin cellular boundary separating
densely packed neurons; and internal neuronal structures can look
similar to the cellular boundary. The first problem in particular means
that small errors in segment boundary predictions can lead to large
errors in neuron shape and neuronal network connectivity.&lt;/p&gt;
&lt;p&gt;Our segmentation workflow has three main steps: a voxelwise edge
classification, a fine-grained segmentation into supervoxels (which can
reasonably be assumed to be atomic groups of voxels), and hierarchical
region agglomeration.&lt;/p&gt;
&lt;p&gt;For the first step, we use Ilastik, a pixel-level interactive learning
program. Ilastik uses the output of various image filters as features to
classify voxels as labeled by the user. We then use the watershed
algorithm on the resulting edge probability map to obtain supervoxels.
For the last step, we developed a new machine learning algorithm
(Nunez-Iglesias et al, in preparation).&lt;/p&gt;
&lt;p&gt;Prior work has used the mean voxel-level edge-probability along the
boundaries between regions to agglomerate them. This strategy works
extremely well because boundaries get longer as agglomeration proceeds,
resulting in ever- improving estimates of the mean probability. We
hypothesized that we could improve agglomeration accuracy by using a
classifier (which can use many more features than the mean). However, a
classifier can perform poorly because throughout agglomeration we may
visit a part of the feature space that has not yet been sampled. In our
approach, we use active learning to ensure that we have examples from
all parts of the space we are likely to encounter.&lt;/p&gt;
&lt;p&gt;We implemented our algorithm in arbitrary dimensions in an open-source,
MIT- licensed Python library, Ray (&lt;a class="reference external" href="https://github.com/jni/ray"&gt;https://github.com/jni/ray&lt;/a&gt;). Ray
combines leading scientific computing Python libraries, including NumPy,
SciPy, NetworkX, and scikits-learn to deliver state of the art
segmentation accuracy in Python.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Juan Nunez-Iglesias</dc:creator><pubDate>Thu, 19 Jul 2012 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2012-07-19:scipy-2012/nd-image-segmentation-using-learned-region-agglom.html</guid><category>General</category></item><item><title>Object Oriented Finite Elements at NIST</title><link>https://pyvideo.org/scipy-2012/object-oriented-finite-elements-at-nist.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The Object Oriented Finite-Element project at NIST
&amp;lt;&lt;a class="reference external" href="http://www.ctcms.nist.gov/oof"&gt;http://www.ctcms.nist.gov/oof&lt;/a&gt;&amp;gt; is a Python and C++ tool designed to
bring sophisticated numerical modeling capabilities to users in the
field of Materials Science. The software provides numerous tools for
constructing finite-element meshes from microstructural images, and for
implementing material properties from a very broad class which includes
elasticity, chemical and thermal diffusion, and electrostatics. The
current series of releases has a robust interface for defining new
nonlinear properties, and provides both first and second order
time-dependence in the equations of motion. The development team is
currently working on a fully-3D version of the code, as well as
expanding the scope of available properties to include surface
interactions, such as surface tension and chemical reactions, and
inequality constraints, such as arise in mechanical surface contact and
plasticity. The software is a hybrid of Python and C++ code, with the
high level user interface and control code in Python, and the heavy
numeric work being done in C++. The software can be operated either as
an interactive, GUI- driven application, as a scripted command-line
tool, or as a supporting library, providing useful access to users of
varying levels of expertise. At every level, the user-interface objects
are intended to be familiar to the materials-science user. This
presentation will focus on an interesting example of a nonlinear
property, called Ramberg-Osgood elasticity, and the process for
incorporating this feature into the OOF architecture.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Andrew Reid</dc:creator><pubDate>Thu, 19 Jul 2012 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2012-07-19:scipy-2012/object-oriented-finite-elements-at-nist.html</guid><category>General</category></item><item><title>Param: Declarative programming using Parameters</title><link>https://pyvideo.org/scipy-2012/param-declarative-programming-using-parameters.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;As a scientific Python application grows, it can be increasingly
difficult to use and maintain, because of implicit assumptions made when
writing each component. Users can pass any possible data type for any
argument, so code either fills up with assertions and tests to see what
type of data has been supplied, or else has undefined behavior for some
datatypes or values. Once software is exchanged with other users,
obscure error messages or even incorrect results are the likely outcome.
Programming languages that require types to be declared alleviate some
of these issues, but are inflexible and difficult to use, both in
general and when specifying details of types (such as ranges of allowed
values). Luckily, Python metaobjects make it possible to extend the
Python language to offer flexible declarative typing, offering the best
of both worlds.&lt;/p&gt;
&lt;p&gt;The Param module provides a clean, low-dependency, pure-Python
implementation of declarative parameters for Python objects and
functions, allowing library and program developers to specify precisely
what types of arguments or values are allowed. A Parameter is a special
type of class attribute that supports type declarations (based on
subtypes of a specified class, support for specified methods (duck
typing), or any other criterion that can be tested), ranges, bounds,
units, constant values, and enumerations. A Parameter has a docstring
(visible at the command line or in generated documentation), inherits
its default value, documentation, etc. along the class hierarchy, and
can be set to dynamic values that generate a stream of numbers for use
in controlling scientific code. In essence, a Parameter is a Python
attribute extended to support clean, simple, robust, maintainable, and
declarative scientific programming.&lt;/p&gt;
&lt;p&gt;Param has been under continuous development and use since 2002 as part
of the Topographica simulator (topographica.org), but is now being
released as a separate package due to demand from users who want similar
functionality in their own code. Param is very similar in spirit to the
Enthought Traits library, despite having been developed independently,
and offers much of the same functionality. Param is particularly useful
for people who find that Traits is difficult to integrate into their
work flow, since it consists of only two pure Python files with no
dependencies outside the standard library. Param is also useful for
people building Tk applications, and provides an optional Tk
property-sheet interface that can automatically generate a GUI window
for viewing and editing an object's Parameters.&lt;/p&gt;
&lt;p&gt;Param is freely available under a BSD license from:
&lt;a class="reference external" href="http://ioam.github.com/param/"&gt;http://ioam.github.com/param/&lt;/a&gt;&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Christopher E. Ball</dc:creator><pubDate>Thu, 19 Jul 2012 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2012-07-19:scipy-2012/param-declarative-programming-using-parameters.html</guid><category>General</category></item><item><title>PythonTeX: Fast Access to Python from within LaTeX</title><link>https://pyvideo.org/scipy-2012/pythontex-fast-access-to-python-from-within-late.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The LaTeX document preparation system is frequently used to create
scientific documents and presentations. This process is often
inefficient. The user must switch back and forth between the document
and external scientific software that is used for performing
calculations and creating figures.
&lt;a class="reference external" href="https://github.com/gpoore/pythontex"&gt;PythonTeX&lt;/a&gt; is a LaTeX package
that allows Python code to be entered directly within a LaTeX document.
The code is automatically executed and its output is included within the
original document. The code may also be typeset within the document with
syntax highlighting provided by Pygments.&lt;/p&gt;
&lt;p&gt;PythonTeX is fast and user-friendly. Python code is separated into user-
defined sessions, and each session is only executed when its code is
modified. When code is executed, sessions run in parallel. The contents
of stdout and stderr are synchronized with the LaTeX document, so that
printed content is easily accessible and error messages have meaningful
line numbering.&lt;/p&gt;
&lt;p&gt;PythonTeX greatly simplifies scientific document creation with LaTeX.
For example, SymPy can be used to automatically solve and typeset
step-by-step mathematical derivations. It can also be used to automate
the creation of mathematical tables. Plots can be created with
matplotlib and then easily customized in place. Python code and its
output can be typeset side by side. The full power of Python is
conveniently available for programming LaTeX macros and customizing and
automating LaTeX documents.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Geoffrey M. Poore</dc:creator><pubDate>Thu, 19 Jul 2012 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2012-07-19:scipy-2012/pythontex-fast-access-to-python-from-within-late.html</guid><category>General</category></item><item><title>Total Recall: flmake and the Quest for Reproducibility</title><link>https://pyvideo.org/scipy-2012/total-recall-flmake-and-the-quest-for-reproducib.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;&lt;a class="reference external" href="http://flash.uchicago.edu/site/"&gt;FLASH&lt;/a&gt; is a high-performance
computing (HPC) multi-physics code which is used to perform
astrophysical and high-energy density physics simulations. It runs on
the full range of systems from laptops to workstations to 100,000
processor super computers - such as the Blue Gene/P at Argonne National
Laboratory.&lt;/p&gt;
&lt;p&gt;Historically, FLASH was born from a collection of unconnected legacy
codes written primarily in Fortran and merged into a single project.
Over the past 13 years major sections have been rewritten in other
languages. For instance, I/O is now implemented in C. However building,
testing, and documentation are all performed in Python.&lt;/p&gt;
&lt;p&gt;FLASH has a unique architecture which compiles &lt;em&gt;simulation specific&lt;/em&gt;
executables for each new type of run. This is aided by an
object-oriented- esque inheritance model that is implemented by
inspecting the file system's directory hierarchy. This allows FLASH to
compile to faster machine code than a compile-once strategy. However it
also places a greater importance on the Python build system.&lt;/p&gt;
&lt;p&gt;To run a FLASH simulation, the user must go through three basic steps:
setup, build, and execution. Canonically, each of these tasks are
independently handled by the user. However, with the recent advent of
&lt;a class="reference external" href="http://flash.%20uchicago.edu/site/flashcode/user_support/tools4b/usersguide/flmake/index.htm"&gt;flmake&lt;/a&gt;
- a Python workflow management utility for FLASH - such tasks may now be
performed in a repeatable way.&lt;/p&gt;
&lt;p&gt;Previous workflow management tools have been written for FLASH. (For
example, the &amp;quot;Milad system&amp;quot; was implemented entirely in Makefiles.)
However, none of the priorattempts have placed reproducibility as their
primary concern. This is in part becausefully capturing the setup
metadata requires alterations to the build system.&lt;/p&gt;
&lt;p&gt;The development of flmake started by rewriting the existing build
systemto allow FLASH to be run outside of the main line subversion
repository. It separates outproject and simulation directories
independent of the FLASH source directory. Thesedirectories are
typically under their own version control.&lt;/p&gt;
&lt;p&gt;Moreover for each of the important tasks (setup, build, run, etc), a
sidecar metadata &lt;em&gt;description&lt;/em&gt; file is either written or appended to.
This is a simple dictionary-of-dictionaries JSON file which stores the
environment of the system and the state of the code when each flmake
command is run. This metadata includes the version information of both
the FLASH main line and project repositories. However, it also may
include &lt;em&gt;all&lt;/em&gt; local modifications since the last commit. A patch is
automatically generated using the Python standard library &lt;tt class="docutils literal"&gt;difflib&lt;/tt&gt;
module and stored directly in the description.&lt;/p&gt;
&lt;p&gt;Along with universally unique identifiers, logging, and Python run
control files, the flmake utility may use the description files to fully
reproduce a simulation by re-executing each command in its original
environment and state. While &lt;tt class="docutils literal"&gt;flmake reproduce&lt;/tt&gt; makes a useful
debugging tool, it fundamentally increases the scientific merit of FLASH
simulations.&lt;/p&gt;
&lt;p&gt;The methods described above may be used whenever source code itself is
distributed. While this is true for FLASH (uncommon amongst
compiledcodes), most Python packages also distribute their source.
Therefore the same reproducibility strategy is applicable and highly
recommended for Python simulation codes. Thus flmake shows that
reproducibility - which is notably absent from most computational
science projects - is easily attainable using only version control and
standard library modules.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Anthony Scopatz</dc:creator><pubDate>Thu, 19 Jul 2012 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2012-07-19:scipy-2012/total-recall-flmake-and-the-quest-for-reproducib.html</guid><category>General</category></item><item><title>TuLiP: a toolbox for hybrid and reactive systems research</title><link>https://pyvideo.org/scipy-2012/tulip-a-toolbox-for-hybrid-and-reactive-systems.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;We present a toolbox for the creation and study of controllers for
hybrid systems. It contains modules for&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;working with n-dimensional polytopes,&lt;/li&gt;
&lt;li&gt;refining continuous state space partitions to satisfy
reachability properties,&lt;/li&gt;
&lt;li&gt;synthesizing, manipulating, and visualizing finite automata as
winning strategies for a class of temporal logic-based games,&lt;/li&gt;
&lt;li&gt;simulating hybrid executions, and&lt;/li&gt;
&lt;li&gt;reading and writing problem solutions to an XML format.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;The toolbox is named TuLiP (for &amp;quot;Temporal Logic Planning&amp;quot;) and written
almost entirely in Python, making critical use of NumPy, SciPy, CVXOPT,
and matplotlib. While software for hybrid systems research is commonly
written in Matlab scripts or otherwise requires the end-user to build
from source for her particular platform, TuLiP requires neither. For a
standard scientific Python environment, the only additional library may
be CVXOPT. Code (re)use and experimentation are easy, and because of
this, TuLiP has provided a natural basis for further research and
development.&lt;/p&gt;
&lt;p&gt;Source code and documentation are currently available at &lt;a class="reference external" href="http://tulip-control.sourceforge.net"&gt;http://tulip-
control.sourceforge.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In this talk we will describe the problem domain addressed by TuLiP,
various use cases, and lessons learning in the Python implementation. We
shall include a full example making use of all components and show ways
that individual modules are useful more broadly. Major items of the talk
will be&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;related work, and the paucity of Python use in hybrid control
research, which we argue is a matter of inheritance rather than
best practices;&lt;/li&gt;
&lt;li&gt;overview of the type of hybrid systems represented in TuLiP and
relevance to other fields;&lt;/li&gt;
&lt;li&gt;summary of the major steps going from problem statement to
solution;&lt;/li&gt;
&lt;li&gt;using only the &amp;quot;polytope computations&amp;quot; module;&lt;/li&gt;
&lt;li&gt;using only &amp;quot;discrete reactive synthesis&amp;quot; related modules, with a
brief description about temporal logic synthesis to provide
background for those not working on computer aided verification;&lt;/li&gt;
&lt;li&gt;snippets about recent research using and building on TuLiP; and&lt;/li&gt;
&lt;li&gt;discussion about the Python-based implementation and lessons
learned.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;For the last item, we will describe challenges faced while developing
TuLiP, given its role of &amp;quot;stitching together&amp;quot; several external tools,
e.g., Gephi &amp;lt;&lt;a class="reference external" href="http://gephi.org/"&gt;http://gephi.org/&lt;/a&gt;&amp;gt; for large graph visualization and gr1c
&amp;lt;&lt;a class="reference external" href="http://scottman.net/2012/gr1c"&gt;http://scottman.net/2012/gr1c&lt;/a&gt;&amp;gt; for game solving. We will also touch
on liberation from a Matlab-only tool (Mult- Parametric Toolbox; see
&lt;a class="reference external" href="http://control.ee.ethz.ch/~mpt/"&gt;http://control.ee.ethz.ch/~mpt/&lt;/a&gt;), achieved by creating our own Python
module for working with polytopes, using NumPy and CVXOPT for
computations and matplotlib for visualization.&lt;/p&gt;
&lt;p&gt;A tool paper describing an earlier version of TuLiP was presented at the
conference Hybrid Systems: Computation and Control (HSCC) in April 2011.
There have since been substantial additions and improvements.
Furthermore, a broader audience can be reached at SciPy 2012, with new
opportunity to address designs issues likely shared by other scientific
Python developers.&lt;/p&gt;
&lt;p&gt;Development of TuLiP has been supported in part by the AFOSR through the
MURI program, the Multiscale Systems Center (MuSyC) and the Boeing
Company.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Richard M. Murray</dc:creator><pubDate>Thu, 19 Jul 2012 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2012-07-19:scipy-2012/tulip-a-toolbox-for-hybrid-and-reactive-systems.html</guid><category>General</category></item><item><title>A tale of four libraries</title><link>https://pyvideo.org/scipy-2012/a-tale-of-four-libraries.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In addition to bringing efficient array computing and standard
mathematical tools to Python, the NumPy/SciPy libraries provide an
ecosystem where multiple libraries can coexist and interact. This talk
describes a success story where we integrate several libraries,
developed by different groups, to solve our research problems. A brief
description of our research and how we use these components follows.&lt;/p&gt;
&lt;p&gt;Our research focuses on using Reinforcement Learning (RL) to gather
information in domains described by an underlying linked dataset. For
instance, we are interested in problems such as the following: given a
Wikipedia article as a seed, finding other articles that are interesting
relative to the starting point. Of particular interest is to find
articles that are more than one-click away from the seed, since these
articles are in general harder to find by a human.&lt;/p&gt;
&lt;p&gt;In addition to the staples of scientific Python computing NumPy, SciPy,
Matplotlib, and IPython, we use the libraries RL-Glue/RL-Library,
NetworkX, Gensim, and scikit-learn.&lt;/p&gt;
&lt;p&gt;Reinforcement Learning considers the interaction between a given
environment and an agent. The objective is to design an agent able to
learn a policy that allows it to maximize its total expected reward. We
use the RL-Glue/RL-Library libraries for our RL experiments. This
libraries provide the infrastructure to connect an environment and an
agent, each one described by an independent Python program.&lt;/p&gt;
&lt;p&gt;We represent the linked datasets we work with as graphs. For this we use
NetworkX, which provides data structures to efficiently represent graphs
together with implementations of many classic graph algorithms. We use
NetworkX graphs to describe the environments implemented in RL-Glue/RL-
Library. We also use these graphs to create, analyze and visualize
graphs built from unstructured data.&lt;/p&gt;
&lt;p&gt;One of the contributions of our research is the idea of representing the
items in the datasets as vectors belonging to a linear space. To this
end, we build a Latent Semantic Analysis (LSA) model to project
documents onto a vector space. This allows us, in addition to being able
to compute similarities between documents, to leverage a variety of RL
techniques that require a vector representation. We use the Gensim
library to build the LSA model. This library provides all the machinery
to build, among other options, the LSA model. One place where Gensim
shines is in its capability to handle big data sets, like the entire
Wikipedia, that do not fit in memory. We also combine the vector
representation of the items as property of the NetworkX nodes.&lt;/p&gt;
&lt;p&gt;Finally, we also use the manifold learning capabilities of sckit-learn,
like the ISOMAP algorithm, to perform some exploratory data analysis. By
reducing the dimensionality of the LSA vectors obtained using Gensim
from 400 to 3, we are able to visualize the relative position of the
vectors together with their connections.&lt;/p&gt;
&lt;p&gt;In summary, this talk shows, by combining a variety of libraries to
solve our research problems, that the NumPy/SciPy ecosystem has become
the lingua-franca of scientific Python computing.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Alejandro Weinstein</dc:creator><pubDate>Wed, 18 Jul 2012 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2012-07-18:scipy-2012/a-tale-of-four-libraries.html</guid><category>General</category></item><item><title>Julia: A Fast Dynamic Language for Technical Computing</title><link>https://pyvideo.org/scipy-2012/julia-a-fast-dynamic-language-for-technical-comp.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Julia is a dynamic language designed for technical applications and high
performance. Its design is based on a sophisticated but unobtrusive type
system, type inference, multiple dispatch instead of class-based OO, and
a code generator based on LLVM. These features work together to run
high-level code efficiently even without type declarations. At the same
time, the type system provides useful expressiveness for designing
libraries, enables forms of metaprogramming not traditionally found in
dynamic languages, and creates the possibility of statically compiling
whole programs and libraries. This combination of high performance and
expressiveness makes it possible for most of Julia's standard library to
be written in Julia itself, with an interface to call existing C and
Fortran libraries.&lt;/p&gt;
&lt;p&gt;We will discuss some ways that Python and Julia can interoperate, and
compare Julia's current capabilities to Python and NumPy.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jeff Bezanson</dc:creator><pubDate>Wed, 18 Jul 2012 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2012-07-18:scipy-2012/julia-a-fast-dynamic-language-for-technical-comp.html</guid><category>General</category></item><item><title>QNDArray: A Numpy Clone for C++/Qt</title><link>https://pyvideo.org/scipy-2012/qndarray-a-numpy-clone-for-cqt.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;While Numpy/Scipy is an attractive implementation platform for many
algorithms, in some cases C++ is mandated by a customer. However, a
foundation of numpy's behavior is the notion of reference-counted
instances, and implementing an efficient, cross-platform mechanism for
reference counting is no trivial prerequisite.&lt;/p&gt;
&lt;p&gt;The reference counting mechanisms already implemented in the Qt C++
toolkit provide a cross-platform foundation upon which a numpy-like
array class can be built. In this talk one such implementation is
discussed, QNDArray. In fact, by mimicking the numpy behaviors, the job
of implementing QNDArray became much easier, as the task of &amp;quot;defining
the behavior&amp;quot; became &amp;quot;adopting the behavior,&amp;quot; to include function names.&lt;/p&gt;
&lt;p&gt;In particular, the following aspects of the implementation were found to
be tricky and deserve discussion in this presentation:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;slicing multidimensional arrays given the limitations of operator[]
in C++,&lt;/li&gt;
&lt;li&gt;const&lt;/li&gt;
&lt;li&gt;partial specialization&lt;/li&gt;
&lt;li&gt;implicit vs. explicit data sharing in Qt QNDArray has been deployed
in scientific research applications and currently has the following
features:&lt;/li&gt;
&lt;li&gt;bit-packed boolean arrays&lt;/li&gt;
&lt;li&gt;nascent masked array support&lt;/li&gt;
&lt;li&gt;unit test suite that validates QNDArray behavior against numpy
behavior&lt;/li&gt;
&lt;li&gt;bounds checking with Q_ASSERT() (becomes a no-op in release mode)&lt;/li&gt;
&lt;li&gt;memmap()ed arrays via QFile::map()&lt;/li&gt;
&lt;li&gt;easily integrated as a QVariant value, leading to a natural mapping
from QVariantMap to Python dict.&lt;/li&gt;
&lt;li&gt;float16 implementation including in-place compare&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The author has approval from his management to submit the source code
for QNDArray to the Qt Project and plans to have it freely available for
download via &lt;a class="reference external" href="http://qt.gitorious.org/"&gt;http://qt.gitorious.org/&lt;/a&gt; before the SciPy conference
begins.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Glen W. Mabey</dc:creator><pubDate>Wed, 18 Jul 2012 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2012-07-18:scipy-2012/qndarray-a-numpy-clone-for-cqt.html</guid><category>General</category></item><item><title>Self-driving Lego Mindstorms Robot</title><link>https://pyvideo.org/scipy-2012/self-driving-lego-mindstorms-robot.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In this talk, I'll describe the workings of my personal hobby project -
a self-driving lego mindstorms robot! The body of the robot is built
with Lego Mindstorms. An Android smartphone is used to capture the view
in front of the robot. A user first teaches the robot how to drive; this
is done by making the robot go around the track a small number of times.
The image data, along with the user action is used to train a Neural
Network. At run-time, images of what is in front of the robot are fed
into the neural network and the appropriate driving action is selected.
This project showcases the power of python's libraries, as they enabled
me to put together a sophisticated working system in a very short amount
of time. Specifically, I made use of the Python Image Library to
downsample images, as well as the PyBrain neural network library. The
robot was controlled using the nxt-python library. A high-level
description + videos are available here: &lt;a class="reference external" href="http://slowping.com/2012/self-driving-lego-%20mindstorms-robot/"&gt;http://slowping.com/2012/self-
driving-lego-mindstorms-robot/&lt;/a&gt;&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Iqbal Mohomed</dc:creator><pubDate>Wed, 18 Jul 2012 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2012-07-18:scipy-2012/self-driving-lego-mindstorms-robot.html</guid><category>General</category></item><item><title>SymPy Stats - Uncertainty Modeling</title><link>https://pyvideo.org/scipy-2012/sympy-stats-uncertainty-modeling.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;SymPy is a symbolic algebra package for Python. In SymPy.Stats we add a
stochastic variable type to this package to form a language for
uncertainty modeling. This allows engineers and scientists to
symbolically declare the uncertainty in their mathematical models and to
make probabilistic queries. We provide transformations from
probabilistic statements like &lt;span class="formula"&gt;&lt;i&gt;P&lt;/i&gt;(&lt;i&gt;X&lt;/i&gt;*&lt;i&gt;Y&lt;/i&gt; &amp;gt; 3)&lt;/span&gt; or &lt;span class="formula"&gt;&lt;i&gt;E&lt;/i&gt;(&lt;i&gt;X&lt;/i&gt;**2)&lt;/span&gt; into
deterministic integrals. These integrals are then solved using SymPy's
integration routines or through numeric sampling.&lt;/p&gt;
&lt;p&gt;This talk touches on a few rising themes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The rise in interest in uncertainty quantification and&lt;/li&gt;
&lt;li&gt;The use of symbolics in scientific computing&lt;/li&gt;
&lt;li&gt;Intermediate representation layers and multi-stage compilation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Historically solutions to uncertainty quantification problems have been
expressed by writing Monte Carlo codes around individual problems. By
creating a symbolic uncertainty language we allow the expression of the
problem-to-be- solved to be written separately from the numerical
technique. SymPy.stats serves as an interface layer. The statistical
programmer doesn't need to think about the details of numerical
techniques and the computational methods programmer doesn't need to
think about the particular domain-specific questions to be solved.&lt;/p&gt;
&lt;p&gt;We have implemented multiple comptuational backends including purely
symbolic (using SymPy's integration engine), sampling, and code
generation.&lt;/p&gt;
&lt;p&gt;In the talk we discuss these ideas with a few illustrative examples
taken from basic probability and engineering. The following is one such
example&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://sympystats.wordpress.com/2011/07/02/a-lesson-in-data-%20assimilation-using-sympy/"&gt;http://sympystats.wordpress.com/2011/07/02/a-lesson-in-data-assimilation-
using-sympy/&lt;/a&gt;&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Matthew Rocklin</dc:creator><pubDate>Wed, 18 Jul 2012 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2012-07-18:scipy-2012/sympy-stats-uncertainty-modeling.html</guid><category>General</category></item><item><title>Time Series Manipulation with pandas</title><link>https://pyvideo.org/scipy-2012/time-series-manipulation-with-pandas.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In this talk I'll discuss major developments in pandas over the last
year related to time series handling and processing. This includes the
integration of the new NumPy datetime64, implementation of rich and high
performance resampling methods, better visualization, and a generally
cleaner, more intuitive and productive API. I will also discuss how
functionality from the defunct scikits.timeseries project has been
integrated into pandas, thus providing a unified, cohesive set of time
series tools for many different problem domains. Lastly, I'll give some
details about the pandas development roadmap and opportunities for more
people to get involved.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Wes McKinney</dc:creator><pubDate>Wed, 18 Jul 2012 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2012-07-18:scipy-2012/time-series-manipulation-with-pandas.html</guid><category>General</category></item><item><title>Unlock: A Python-based framework for rapid development of practical brain-computer interface applications</title><link>https://pyvideo.org/scipy-2012/unlock-a-python-based-framework-for-rapid-develo.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The Unlock Project aims to provide brain-computer interface (BCI)
technologies to individuals suffering from locked-in syndrome, the
complete or near- complete loss of voluntary motor function. While
several BCI techniques have been demonstrated as feasible in a
laboratory setting, limited effort has been devoted to translating that
research into a system for viable home use. This is in large part due to
the complexity of existing BCI software packages which are geared toward
clinical use by domain experts. With Unlock, we have developed a
Python-based modular framework that greatly simplifies the time and
programming expertise needed to develop BCI applications and
experiments. Furthermore, the entire Unlock system, including data
acquisition, brain signal decoding, user interface display, and device
actuation, can run on a single laptop, offering exceptional portability
for this class of BCI.&lt;/p&gt;
&lt;p&gt;In this talk, I will present the Unlock framework, starting with a
high-level overview of the system then touching on the acquisition,
communication, decoding, and visualization components. Emphasis will be
placed on the app developer API with several examples from our current
work with steady-state visually evoked potentials (SSVEP).&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Byron V. Galbraith</dc:creator><pubDate>Wed, 18 Jul 2012 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2012-07-18:scipy-2012/unlock-a-python-based-framework-for-rapid-develo.html</guid><category>General</category></item></channel></rss>