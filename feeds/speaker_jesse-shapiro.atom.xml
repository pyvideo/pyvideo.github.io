<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_jesse-shapiro.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2017-11-18T00:00:00+00:00</updated><entry><title>Descriptors, magic methods, and inheritance: oh my!</title><link href="https://pyvideo.org/pycon-ca-2017/descriptors-magic-methods-and-inheritance-oh-my.html" rel="alternate"></link><published>2017-11-18T00:00:00+00:00</published><updated>2017-11-18T00:00:00+00:00</updated><author><name>Jesse Shapiro</name></author><id>tag:pyvideo.org,2017-11-18:pycon-ca-2017/descriptors-magic-methods-and-inheritance-oh-my.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;It's very simple to write straightforward imperative code with Python. You can easily define classes and functions, and write behavior inside them. However, pure imperative design means that you'll likely end up writing the same patterns of code over and over - whether it's &lt;cite&gt;requests.get()&lt;/cite&gt; or &lt;cite&gt;LOGGER = getLogger(__name__)&lt;/cite&gt;. By taking advantage of some of the more advanced features of the Python language, like descriptors, overridden magic methods, and creative uses of inheritance, we can make our code smaller and more expressive. Proper abstractions will also make it easier to test your code thoroughly and effectively - because you're not reimplementing behavior unnecessarily, you can properly test the one place you do implement it, and rely on it from then on. And, it becomes much easier to add features later on that rely on existing behavior - you just need to describe them in terms of the things you've already implemented.&lt;/p&gt;
</summary></entry></feed>