<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_david-weil.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2016-09-22T00:00:00+00:00</updated><entry><title>Sleepy: How to suspend and resume your cpython process from inside</title><link href="https://pyvideo.org/pycon-japan-2016/sleepy-how-to-suspend-and-resume-your-cpython-process-from-inside.html" rel="alternate"></link><published>2016-09-22T00:00:00+00:00</published><updated>2016-09-22T00:00:00+00:00</updated><author><name>David Weil</name></author><id>tag:pyvideo.org,2016-09-22:pycon-japan-2016/sleepy-how-to-suspend-and-resume-your-cpython-process-from-inside.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In this talk we'll propose and explain how it is possible suspend &amp;amp; resume a python process execution from within python using no external-help. Pure-python-ffi-free code. This kind of tool is useful with the proliferation of cloud serv since they offer restricted execution env in terms of time/mem and process relocation/prio is required. Besides we’ll get unexpected debugger improvements.&lt;/p&gt;
&lt;div class="section" id="detailed-abstract"&gt;
&lt;h4&gt;Detailed Abstract&lt;/h4&gt;
&lt;p&gt;People will be introduced to a simple case of what continuations are, i.e.: suspending a whole python process and resuming it from where it was saved.&lt;/p&gt;
&lt;p&gt;We'll present some scenarios where it would be useful:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;restricted time execution environments&lt;/li&gt;
&lt;li&gt;distributed computing farms&lt;/li&gt;
&lt;li&gt;tasks would become dynamic, meaning they could be switched from one host to another at the user's will -run- time code problems evaluation by code re-execution, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A comparison to different alternatives will be shown:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;other languages features&lt;/li&gt;
&lt;li&gt;operating system provided features&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We'll present a method to persist execution state and then explain how to restore it. To do that, we use python's debugger in order to restore the state.&lt;/p&gt;
&lt;p&gt;Some problems arise in that process such as:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;how to persist and restore objects created in C&lt;/li&gt;
&lt;li&gt;how to restore process execution using debugger's functions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To persist and restore objects created in C, I created python wrappers which would replicate C-created objects and expose their own methods and instance variables.&lt;/p&gt;
&lt;p&gt;To restore a process execution in a given point, we use the python debugger. With it, is possible to start the code in a programmatic way instrumenting to jump directly into the function call belonging to frames present in saved call-stack.&lt;/p&gt;
&lt;p&gt;The main problem here lies in the fact that the debugger is not powerful enough to jump from any function entrypoint into arbitrary points inside the funcion, i.e.: you can’t jump inside a block of code!&lt;/p&gt;
&lt;p&gt;For that, I present 3 different approaches to workaround that:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;block-unrolling : ie: pasting and compiling block’s code in the same place it is located and also, after function end, in an unrolled way (check added block1 after return) :&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;pre class="code python literal-block"&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;some_iterator&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;block1&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="n"&gt;block1&lt;/span&gt;
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;the alternative is to replace the expressions which control loops with assisted functions, like:&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;pre class="code python literal-block"&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;my_library_controlled_iterator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;original_iterator&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;block1&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt;
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;letting us control the debugger and execute the loop instructions (returning controlled value from the assisted function iterator), and then jump again to call the function for the next frame in the call-stack.&lt;/li&gt;
&lt;li&gt;it is possible to rewrite python’s byte-code to have no block byte-codes. This is the method I chose for my implementation, and I will explain how the bytecode will be rewritten for each control structure found.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After that, major problems are solved and we have a working prototype.&lt;/p&gt;
&lt;/div&gt;
</summary></entry></feed>