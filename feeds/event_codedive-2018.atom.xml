<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org - code::dive 2018</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/event_codedive-2018.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2018-11-07T00:00:00+00:00</updated><subtitle></subtitle><entry><title>Python as C++’s limiting case</title><link href="https://pyvideo.org/codedive-2018/python-as-cs-limiting-case.html" rel="alternate"></link><published>2018-11-07T00:00:00+00:00</published><updated>2018-11-07T00:00:00+00:00</updated><author><name>Brandon Rhodes</name></author><id>tag:pyvideo.org,2018-11-07:/codedive-2018/python-as-cs-limiting-case.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The Python language’s memory model can be deduced from first principles: simply take modern C++ conventions and drive their safety and generality to infinity. But this limiting case generates its own compromises and opens its own categories of possible runtime errors. We will explore the position Python has …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The Python language’s memory model can be deduced from first principles: simply take modern C++ conventions and drive their safety and generality to infinity. But this limiting case generates its own compromises and opens its own categories of possible runtime errors. We will explore the position Python has staked out in the language design space of correctness versus performance, the choices Python programmers make when they need to move closer to C++, and the ways that the C++ community keeps adopting conventions that look suspiciously like Python.&lt;/p&gt;
</content><category term="code::dive 2018"></category></entry></feed>