<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_wilson-tjhi.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2018-06-01T00:00:00+00:00</updated><entry><title>Writing robust, readable, and maintainable concurrent programs in Python</title><link href="https://pyvideo.org/pycon-apac-2018/writing-robust-readable-and-maintainable-concurrent-programs-in-python.html" rel="alternate"></link><published>2018-06-01T00:00:00+00:00</published><updated>2018-06-01T00:00:00+00:00</updated><author><name>Wilson Tjhi</name></author><id>tag:pyvideo.org,2018-06-01:pycon-apac-2018/writing-robust-readable-and-maintainable-concurrent-programs-in-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Threading, futures, coroutines, asyncio, celery, and gevent. What are
the differences among these concurrency techniques? This presentation
tries to make clear different concurrency models supported by Python and
which libraries are best suited for the different problems that each
model solves.&lt;/p&gt;
</summary></entry></feed>