<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_wes-chow.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2015-08-15T00:00:00+00:00</updated><entry><title>Sharding Data for Fun &amp; Profit</title><link href="https://pyvideo.org/pygotham-2015/sharding-data-for-fun-profit.html" rel="alternate"></link><published>2015-08-15T00:00:00+00:00</published><updated>2015-08-15T00:00:00+00:00</updated><author><name>Wes Chow</name></author><id>tag:pyvideo.org,2015-08-15:pygotham-2015/sharding-data-for-fun-profit.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The hash function is the veritable hammer for pounding a large array of
engineering problems into submission. Want to shard your database? Draw
a key from your data, hash it, and voila, instant deterministic load
balancing! That’s simple enough, until you look more carefully at
distributional effects, failure, and redundancy management. We’ll review
well known (consistent hashing), not so well known (rendezvous hashing),
and recent (shuffle sharding, copysets) work that goes a long way
towards engineering more favorable failure scenarios.&lt;/p&gt;
</summary></entry></feed>