<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_julian-berman.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2019-10-04T00:00:00+00:00</updated><entry><title>The Ministry of Silly Talks</title><link href="https://pyvideo.org/pygotham-2019/the-ministry-of-silly-talks.html" rel="alternate"></link><published>2019-10-04T00:00:00+00:00</published><updated>2019-10-04T00:00:00+00:00</updated><author><name>Aditya Sirish</name></author><id>tag:pyvideo.org,2019-10-04:pygotham-2019/the-ministry-of-silly-talks.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;PyGotham 2019's Lightning Talks&lt;/p&gt;
</summary></entry><entry><title>Introduction to JSON Schema</title><link href="https://pyvideo.org/pycon-se-2016/introduction-to-json-schema.html" rel="alternate"></link><published>2016-05-10T00:00:00+00:00</published><updated>2016-05-10T00:00:00+00:00</updated><author><name>Julian Berman</name></author><id>tag:pyvideo.org,2016-05-10:pycon-se-2016/introduction-to-json-schema.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;JSON Schema is an increasingly popular, cross-language specification for schematization of JSON documents. It represents schema constraints on a JSON document &lt;em&gt;as&lt;/em&gt; a JSON document, in a flexible validation language. We'll investigate some simple (and not so simple) examples of data validation using the &lt;cite&gt;jsonschema&lt;/cite&gt; Python package, which implements the specification.&lt;/p&gt;
</summary></entry><entry><title>PyPy &amp; Us Could Be PyPy &amp; You</title><link href="https://pyvideo.org/pygotham-2016/pypy-us-could-be-pypy-you.html" rel="alternate"></link><published>2016-07-16T00:00:00+00:00</published><updated>2016-07-16T00:00:00+00:00</updated><author><name>Julian Berman</name></author><id>tag:pyvideo.org,2016-07-16:pygotham-2016/pypy-us-could-be-pypy-you.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;You've probably heard of PyPy. It's an interpreter that can make your Python fast. Really fast. We'll talk about some fundamentals &amp;amp; lessons learned from running PyPy in large scale production deployments for the last ~3 years.&lt;/p&gt;
</summary><category term="pypy"></category></entry><entry><title>Introduction to JSON schema</title><link href="https://pyvideo.org/pycon-italia-2016/introduction-to-json-schema.html" rel="alternate"></link><published>2016-06-20T00:00:00+00:00</published><updated>2016-06-20T00:00:00+00:00</updated><author><name>Julian Berman</name></author><id>tag:pyvideo.org,2016-06-20:pycon-italia-2016/introduction-to-json-schema.html</id><summary type="html"></summary></entry><entry><title>Introduction to JSON Schema</title><link href="https://pyvideo.org/pycon-israel-2016/introduction-to-json-schema.html" rel="alternate"></link><published>2016-09-07T00:00:00+00:00</published><updated>2016-09-07T00:00:00+00:00</updated><author><name>Julian Berman</name></author><id>tag:pyvideo.org,2016-09-07:pycon-israel-2016/introduction-to-json-schema.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;JSON Schema (&lt;a class="reference external" href="http://json-schema.org/"&gt;http://json-schema.org/&lt;/a&gt;) is an increasingly popular, cross-language specification for schematization of JSON documents. It represents schema constraints on a JSON document as a JSON document, in a flexible validation language. Weâ€™ll investigate some simple (and not so simple) examples of data validation using the jsonschema Python package (&lt;a class="reference external" href="https://pypi.python.org/pypi/jsonschema"&gt;https://pypi.python.org/pypi/jsonschema&lt;/a&gt;), which implements the specification.&lt;/p&gt;
&lt;p&gt;Slides available here: &lt;a class="reference external" href="http://il.pycon.org/2016/static/sessions/julian-berman.pdf"&gt;http://il.pycon.org/2016/static/sessions/julian-berman.pdf&lt;/a&gt;&lt;/p&gt;
</summary></entry><entry><title>Just Because You Can, Doesn't Mean You Should</title><link href="https://pyvideo.org/europython-2015/just-because-you-can-doesnt-mean-you-should.html" rel="alternate"></link><published>2015-08-08T00:00:00+00:00</published><updated>2015-08-08T00:00:00+00:00</updated><author><name>Julian Berman</name></author><id>tag:pyvideo.org,2015-08-08:europython-2015/just-because-you-can-doesnt-mean-you-should.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Julian Berman - Just Because You Can, Doesn't Mean You Should
[EuroPython 2015]
[24 July 2015]
[Bilbao, Euskadi, Spain]&lt;/p&gt;
&lt;p&gt;Python is a powerful language that provides many tools for creating
highly dynamic programs. It offers tools all across the complexity
spectrum that library authors can use to make their libraries seem
convenient to use for users.&lt;/p&gt;
&lt;p&gt;While it's true that there are a wealth of techniques with huge
positive benefits, there are a number of common antipatterns which can
deceptively cause a net-loss in flexibility, readability, and
predictability for users.&lt;/p&gt;
&lt;p&gt;We'll explore a few specific commonalities in this area of library and
object API design, and talk about the ramifications they have on each
of these programmer concerns.&lt;/p&gt;
</summary></entry><entry><title>Design Your Tests</title><link href="https://pyvideo.org/europython-2014/design-your-tests.html" rel="alternate"></link><published>2014-07-23T00:00:00+00:00</published><updated>2014-07-23T00:00:00+00:00</updated><author><name>Julian Berman</name></author><id>tag:pyvideo.org,2014-07-23:europython-2014/design-your-tests.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;While getting started testing often provides noticeable immediate
improvement for any developer, it's often not until the realization that
tests are things that need &lt;em&gt;design&lt;/em&gt; to provide maximal benefit that
developers begin to appreciate or even &lt;em&gt;enjoy&lt;/em&gt; them.&lt;/p&gt;
&lt;p&gt;We'll investigate how building shallow, transparent layers for your
tests makes for better failures, clearer tests, and quicker diagnoses.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;ul class="simple"&gt;
&lt;li&gt;Life span of a test&lt;ul&gt;
&lt;li&gt;5 minute - why does this fail?&lt;/li&gt;
&lt;li&gt;5 day - what is this missing?&lt;/li&gt;
&lt;li&gt;5 week - do I have coverage for this?&lt;/li&gt;
&lt;li&gt;5 month - what's &lt;em&gt;not&lt;/em&gt; causing this bug?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Transparent simplicity&lt;ul&gt;
&lt;li&gt;one or two &amp;quot;iceberg&amp;quot; layers for meaning&lt;ul&gt;
&lt;li&gt;Higher-order assertions - build collections of state that have
meaning for the domain in the tests&lt;/li&gt;
&lt;li&gt;bulk of the details are in the code itself&lt;/li&gt;
&lt;li&gt;show an example&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;grouping for organization&lt;ul&gt;
&lt;li&gt;Mixins&lt;/li&gt;
&lt;li&gt;show an example&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;unittest issues&lt;ul&gt;
&lt;li&gt;assertion/mixin clutter&lt;/li&gt;
&lt;li&gt;setUp/tearDown tie grouping to the class layer or to inheritance
via super&lt;ul&gt;
&lt;li&gt;addCleanup&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;weak association / lookup-ability between code and its tests&lt;ul&gt;
&lt;li&gt;package layout&lt;/li&gt;
&lt;li&gt;other conventions&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Alternative approaches&lt;ul&gt;
&lt;li&gt;testtools' matchers&lt;/li&gt;
&lt;li&gt;py.test &lt;tt class="docutils literal"&gt;assert&lt;/tt&gt; magic&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary></entry><entry><title>Bulding an interpreter in RPython</title><link href="https://pyvideo.org/pycon-se-2015/bulding-an-interpreter-in-rpython.html" rel="alternate"></link><published>2015-05-25T00:00:00+00:00</published><updated>2015-05-25T00:00:00+00:00</updated><author><name>Julian Berman</name></author><id>tag:pyvideo.org,2015-05-25:pycon-se-2015/bulding-an-interpreter-in-rpython.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;RPython is a language and toolchain for building interpreters, most
prominently PyPy, a Python interpreter. But RPython is a powerful tool
for writing interpreters for many dynamic languages. We'll learn how to
write a simple interpreter in RPython by implementing a parser, bytecode
compiler and VM for a small language.&lt;/p&gt;
</summary></entry></feed>