<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_elizaveta-shashkova.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2019-07-10T00:00:00+00:00</updated><entry><title>Visual debugger for Jupyter Notebooks: Myth or Reality?</title><link href="https://pyvideo.org/europython-2019/visual-debugger-for-jupyter-notebooks-myth-or-reality.html" rel="alternate"></link><published>2019-07-10T00:00:00+00:00</published><updated>2019-07-10T00:00:00+00:00</updated><author><name>Elizaveta Shashkova</name></author><id>tag:pyvideo.org,2019-07-10:europython-2019/visual-debugger-for-jupyter-notebooks-myth-or-reality.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Many Python developers like Jupyter Notebooks for their flexibility:
they are very useful for interactive prototyping, scientific
experiments, visualizations and many other tasks. There are different
development tools which make working with Jupyter Notebooks easier and
smoother, but all of them lack very important feature: visual debugger.
Since Jupyter Kernel is a usual Python process, it looks reasonably to
use one of existing Python debuggers with it. But is it really possible?&lt;/p&gt;
&lt;p&gt;In this talk we’ll try to understand how Python debugger should be
changed to work with Jupyter cells and how these changes are already
implemented in the PyCharm IDE. After that we’ll look into the whole
Jupyter architecture and try to understand which bottlenecks in it
prevent creation of universal Jupyter debugger at the moment.&lt;/p&gt;
&lt;p&gt;This talk requires a basic knowledge of Jupyter Notebooks and
understanding of Python functions and objects. It will be interesting
for people who want to learn internals of the tools they use every day.
Also it might be an inspiration for people who want to implement a
visual debugger in their favourite IDE.&lt;/p&gt;
</summary><category term="Debugging"></category><category term="Jupyter"></category><category term="Python general"></category><category term="Tooling"></category></entry><entry><title>Debugging in Python 3.6: Better, Faster, Stronger</title><link href="https://pyvideo.org/europython-2017/debugging-in-python-36-better-faster-stronger.html" rel="alternate"></link><published>2017-07-10T00:00:00+00:00</published><updated>2017-07-10T00:00:00+00:00</updated><author><name>Elizaveta Shashkova</name></author><id>tag:pyvideo.org,2017-07-10:europython-2017/debugging-in-python-36-better-faster-stronger.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python 3.6 was released in December of 2016 and it has a lot of new
cool features. Some of them are quite easy for using: a developer can
read, for example, about f-strings and they can start using them in
their programs as soon as possible. But sometimes features are not so
evident, and a new frame evaluation API is one of them.&lt;/p&gt;
&lt;p&gt;The new frame evaluation API was introduced to CPython in PEP 523 and
it allows to specify a per-interpreter function pointer to handle the
evaluation of frames. It might not be evident how to use this new
feature in everyday life, but it’s quite easy to understand how to
build a fast debugger based on it.&lt;/p&gt;
&lt;p&gt;In this talk we are going to explain how standard way of debugging in
Python works and how a new frame evaluation API may be useful for
creating the fast debugger. Also we will consider why such fast
debugging was not possible in the previous versions of Python. If
someone hasn’t made a final decision to move to Python 3.6 this talk
will provide some new reasons to do it.&lt;/p&gt;
</summary></entry><entry><title>Debugging in Python 3.6: Better, Faster, Stronger</title><link href="https://pyvideo.org/pycon-us-2017/debugging-in-python-36-better-faster-stronger.html" rel="alternate"></link><published>2017-05-20T00:00:00+00:00</published><updated>2017-05-20T00:00:00+00:00</updated><author><name>Elizaveta Shashkova</name></author><id>tag:pyvideo.org,2017-05-20:pycon-us-2017/debugging-in-python-36-better-faster-stronger.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Python 3.6 was released in December of 2016 and it has a lot of new
cool features. Some of them are quite easy for using: a developer can
read, for example, about f-strings and they can start using them in
their programs as soon as possible. But sometimes features are not so
evident, and a new frame evaluation API is one of them.&lt;/div&gt;
&lt;div class="line"&gt;The new frame evaluation API was introduced to CPython in PEP 523 and
it allows to specify a per-interpreter function pointer to handle the
evaluation of frames. It might not be evident how to use this new
feature in everyday life, but it’s quite easy to understand how to
build a fast debugger based on it.&lt;/div&gt;
&lt;div class="line"&gt;In this talk we are going to explain how standard way of debugging in
Python works and how a new frame evaluation API may be useful for
creating the fast debugger. Also we will consider why such fast
debugging was not possible in the previous versions of Python. If
someone hasn’t made a final decision to move to Python 3.6 this talk
will provide some new reasons to do it.&lt;/div&gt;
&lt;/div&gt;
</summary></entry><entry><title>Monkey-patching: a magic trick or a powerful tool?</title><link href="https://pyvideo.org/europython-2016/monkey-patching-a-magic-trick-or-a-powerful-tool.html" rel="alternate"></link><published>2016-08-05T00:00:00+00:00</published><updated>2016-08-05T00:00:00+00:00</updated><author><name>Elizaveta Shashkova</name></author><id>tag:pyvideo.org,2016-08-05:europython-2016/monkey-patching-a-magic-trick-or-a-powerful-tool.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Elizaveta Shashkova - Monkey-patching: a magic trick or a powerful tool?
[EuroPython 2016]
[22 July 2016]
[Bilbao, Euskadi, Spain]
(&lt;a class="reference external" href="https://ep2016.europython.eu//conference/talks/monkey-patching-a-magic-trick-or-a-powerful-tool"&gt;https://ep2016.europython.eu//conference/talks/monkey-patching-a-magic-trick-or-a-powerful-tool&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Monkey-patching is a dynamic modification of a class or a module at runtime.&lt;/p&gt;
&lt;p&gt;The Python gives developers a great opportunity to use monkey-patching
almost everywhere. But should developers do it? Is it a magic trick or
a powerful tool? In this talk we will try to give the answers to these
questions and try to figure out pros and cons of using monkey-
patching.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;First of all we will learn what is monkey-patching in Python and
consider some basic examples of using it.&lt;/p&gt;
&lt;p&gt;Of course, monkey-patching may cause some problems in the code. We
will consider bad ways to use it and try to learn different types of
problems monkey-patching may lead to.&lt;/p&gt;
&lt;p&gt;Despite of some bugs that may appear in a patched program, monkey-
patching is used in a real life rather often. There are some reasons
and motives to do it. We will consider the examples of using monkey-
patching in real projects like &lt;cite&gt;gevent&lt;/cite&gt;, in some other libraries and
in testing. Also we will learn some monkey-patch tricks that helps to
solve real-life problems in the Python debugger which is a part of the
PyCharm and the PyDev.&lt;/p&gt;
&lt;p&gt;After that we will compare using of monkey-patching in Python to using
it in an another dynamic language Ruby. Are there any differences
between them? Is our reasoning correct for Ruby?&lt;/p&gt;
&lt;p&gt;Finally we will conclude all our thoughts and examples and try to give
the answer to the question from title.&lt;/p&gt;
</summary></entry></feed>