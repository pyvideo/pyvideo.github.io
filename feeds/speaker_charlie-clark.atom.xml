<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_charlie-clark.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2015-10-18T00:00:00+00:00</updated><entry><title>When generated code makes sense</title><link href="https://pyvideo.org/pycon-fr-2015/when-generated-code-makes-sense.html" rel="alternate"></link><published>2015-10-18T00:00:00+00:00</published><updated>2015-10-18T00:00:00+00:00</updated><author><name>Charlie Clark</name></author><id>tag:pyvideo.org,2015-10-18:pycon-fr-2015/when-generated-code-makes-sense.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;openpyxl started largely as the reverse-engineering of existing files.
While this allowed the project to get up and running quickly, it also
turned out to be a dead-end when it came to supporting more advanced
features. This talk will explain how we've shifted to using descriptors,
code generation and possibly the world's worst parser for more reliable
code and faster development.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Only after a great deal of public pressure did Microsoft agree to make
the specification of Microsoft Office 2007 public and even this was
after the fact. The result was many thousands of pages of narrative
description and an extensive XML schema. Whatever one may think of the
company or the format, the fact remains that for many offices Microsoft
Excel is a standard format and we want to make it as easy as possible to
work with the files with Python.&lt;/p&gt;
&lt;p&gt;openpyxl started largely as the reverse-engineering of existing files.
While this allowed the project to get up and running quickly, it also
turned out to be a dead-end when it came to supporting more advanced
features.&lt;/p&gt;
&lt;p&gt;The Office Open XML Schema is, in effect, the domain-specific language
for Microsoft Office. With tools like lxml it's even possible to work
with this directly from Python but this requires extensive and detailed
knowledge of something that is rarely intuitive and often downright
confusing. Furthermore, manipulating XML in memory can be a problem on
very large workbooks.&lt;/p&gt;
&lt;p&gt;In openpyxl we introduced descriptors to deal with common types in the
schema, and added class methods so that we could simplify parsing but
keep the Python API as simple as possible. This started out as a fairly
laborious transcription of schema to class definitions that has since
been replaced by code generated by what might possibly be the world's
worst parser – every library has to have some horrible code in it
somewhere!&lt;/p&gt;
&lt;p&gt;The result was that over 200 classes and their naive tests could be
generated automatically to provide near complete support for the chart
API. The process isn't perfect: code rarely runs straight out of the box
but it has made it possible to support features that otherwise could
only ever be partially supported at best.&lt;/p&gt;
&lt;p&gt;The talk will cover what tools Python provides to make this kind of
adventure succeed and where things could be improved.&lt;/p&gt;
</summary></entry><entry><title>The Art of Doing Nothing – Using profiling to speed up your code</title><link href="https://pyvideo.org/pycon-fr-2015/the-art-of-doing-nothing-using-profiling-to-speed-up-your-code.html" rel="alternate"></link><published>2015-10-17T00:00:00+00:00</published><updated>2015-10-17T00:00:00+00:00</updated><author><name>Charlie Clark</name></author><id>tag:pyvideo.org,2015-10-17:pycon-fr-2015/the-art-of-doing-nothing-using-profiling-to-speed-up-your-code.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;We're lucky with Python that we can concentrate on getting the job done
and often don't have to worry about how fast our code runs. After all
code than runs today will finish before faster code that runs tomorrow.
But what do you do when you need to make your code run faster? This talk
will give you an introduction into how to improve performance where you
need it most.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;We're lucky with Python that we can concentrate on getting the job done
and often don't have to worry about how fast our code runs. Those of us
without computer science degrees &lt;strong&gt;really&lt;/strong&gt; know how to appreciate this.
And 9 times out of 10 you probably don't need to worry at all about the
speed: if the program takes 10 minutes to run but saves you hours of
work then it's a job well done. But then there is that 10th time…&lt;/p&gt;
&lt;p&gt;Based on work done over the last couple of years with openpyxl I will
show some tips and tricks as to how you can approach improving
performance without having to become a mathematical genius or computer
whizz. There is lots of good advice about performance around but it has
to make sense within the context of your application: does it matter
that Python loops are considered slow?&lt;/p&gt;
&lt;p&gt;The talk will cover using tests and profiling to identify the areas that
you need to work on, stop you breaking stuff irreparably, and what
things you might want to research or ask about. I do promise you: the
art of performance really is the art of doing nothing!&lt;/p&gt;
&lt;p&gt;La présentation sera en anglais mais je parle le français assez bien et
peu répondre aux questions en français ou peut-être le franglais!&lt;/p&gt;
</summary></entry></feed>