<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org - James Ray</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_james-ray.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2022-10-18T00:00:00+00:00</updated><subtitle></subtitle><entry><title>A Management Layer for Scalable, Multitenant Django</title><link href="https://pyvideo.org/djangocon-us-2022/a-management-layer-for-scalable-multitenant-django.html" rel="alternate"></link><published>2022-10-18T00:00:00+00:00</published><updated>2022-10-18T00:00:00+00:00</updated><author><name>Addison Hardy</name></author><id>tag:pyvideo.org,2022-10-18:/djangocon-us-2022/a-management-layer-for-scalable-multitenant-django.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;## Networking&lt;/p&gt;
&lt;p&gt;To handle networking within the containers, the management layer integrates with Nginx and uWSGI.  During container startup, and when network configuration changes, the management layer generates Nginx site files and uWSGI config files on the fly based on current platform state.&lt;/p&gt;
&lt;p&gt;We are running uWSGI in “emperor” mode …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;## Networking&lt;/p&gt;
&lt;p&gt;To handle networking within the containers, the management layer integrates with Nginx and uWSGI.  During container startup, and when network configuration changes, the management layer generates Nginx site files and uWSGI config files on the fly based on current platform state.&lt;/p&gt;
&lt;p&gt;We are running uWSGI in “emperor” mode, which allows us to create (and configure) separate uWSGI workers for each site.  Within the uWSGI config files, we are setting an environment variable based on each site’s unique identifier.  As uWSGI initializes each worker, it also initializes Django.  We use that environment variable in our Django settings files to configure the database, cache key prefix, AWS S3 bucket (for file storage) and other site-specific settings.  This allows all platform sites to share a single codebase, but keeps each site’s data completely separate.&lt;/p&gt;
&lt;p&gt;## Cluster Configuration&lt;/p&gt;
&lt;p&gt;All cluster configuration data is stored in a Postgres database, which serves as the source of truth for platform state.  The management layer exposes an API and web dashboard for querying the current platform state and making configuration changes.  Administrators can perform actions like creating new sites, associating hostnames with sites, managing user permissions and monitoring platform health.&lt;/p&gt;
&lt;p&gt;## State Synchronization&lt;/p&gt;
&lt;p&gt;Within each container, the management layer listens for state change events on a Postgres notification channel.  The change events are sent as JSON, and include the event type, timestamp and any associated metadata.  When a configuration change is made via the API, the container that handled the API request will broadcasts that change event to the entire cluster.  The management layer also performs regular integrity checks to ensure the state of each container matches the state of the platform.&lt;/p&gt;
&lt;p&gt;## Health Monitoring&lt;/p&gt;
&lt;p&gt;The management layer performs automated healthchecks within each container by sending an internal request to each hostname associated with a site on the platform.  The response codes and latency for those requests are then stored and used to power monitoring tools and alerts via the API and web dashboard.&lt;/p&gt;
&lt;p&gt;If an issue is detected, the management layer will attempt to resolve the issue by querying the latest platform state, and regenerating configuration files.  If the issue persists, the container will be automatically replaced within the cluster.&lt;/p&gt;
</content><category term="DjangoCon US 2022"></category></entry></feed>