<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/tag_concurrency.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2019-09-16T00:00:00+00:00</updated><entry><title>Concurrent asyncio and sanity</title><link href="https://pyvideo.org/pycon-uk-2019/concurrent-asyncio-and-sanity.html" rel="alternate"></link><published>2019-09-16T00:00:00+00:00</published><updated>2019-09-16T00:00:00+00:00</updated><author><name>Martijn Pieters</name></author><id>tag:pyvideo.org,2019-09-16:pycon-uk-2019/concurrent-asyncio-and-sanity.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Do you find programming with asyncio daunting? Are you wondering how you'd build a real-world network-connected service with this and not die trying? In this talk I want to share some best practices and tips to help you create reliable, maintainable applications using concurrency.&lt;/p&gt;
</summary><category term="asyncio"></category><category term="concurrency"></category><category term="scalability"></category></entry><entry><title>Greenlet-based concurrency</title><link href="https://pyvideo.org/europython-2013/greenlet-based-concurrency.html" rel="alternate"></link><published>2013-07-03T00:00:00+00:00</published><updated>2013-07-03T00:00:00+00:00</updated><author><name>Goran Peretin</name></author><id>tag:pyvideo.org,2013-07-03:europython-2013/greenlet-based-concurrency.html</id><summary type="html"></summary><category term="parallelization"></category><category term="optimization"></category><category term="gevent"></category><category term="greenlet"></category><category term="concurrency"></category><category term="performance"></category></entry><entry><title>How DISQUS does "it" when "it" isn't Django</title><link href="https://pyvideo.org/europython-2013/how-disqus-does-it-when-it-isnt-django.html" rel="alternate"></link><published>2013-07-02T00:00:00+00:00</published><updated>2013-07-02T00:00:00+00:00</updated><author><name>Adam Hitchcock</name></author><id>tag:pyvideo.org,2013-07-02:europython-2013/how-disqus-does-it-when-it-isnt-django.html</id><summary type="html"></summary><category term="web"></category><category term="realtime"></category><category term="mongodb"></category><category term="zookeeper"></category><category term="scalability"></category><category term="django"></category><category term="celery"></category><category term="optimization"></category><category term="gevent"></category><category term="concurrency"></category><category term="performance"></category></entry><entry><title>Trio: Async concurrency for mere mortals</title><link href="https://pyvideo.org/pycon-us-2018/trio-async-concurrency-for-mere-mortals.html" rel="alternate"></link><published>2018-05-11T00:00:00+00:00</published><updated>2018-05-11T00:00:00+00:00</updated><author><name>Nathaniel J. Smith</name></author><id>tag:pyvideo.org,2018-05-11:pycon-us-2018/trio-async-concurrency-for-mere-mortals.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Concurrent programs are super useful: think of web apps juggling lots of
simultaneous downloads and websocket connections, chat bots tracking
multiple concurrent conversations, or web spiders fetching pages in
parallel. But &lt;em&gt;writing&lt;/em&gt; concurrent programs is complicated, intimidating
to newcomers, and often challenging even for experts.&lt;/p&gt;
&lt;p&gt;Does it have to be? Python is famous for being simple and
straightforward; can Python make concurrent programming simple and
straightforward too? I think so. By carefully analyzing usability
pitfalls in other libraries, and taking advantage of new Python 3
features, I’ve come up with a new set of primitives that make it
dramatically easier to write correct concurrent programs, and
implemented them in a new library called &lt;a class="reference external" href="https://trio.readthedocs.io"&gt;Trio&lt;/a&gt;. In this talk, I’ll
describe these primitives, and demonstrate how to use them to implement
a basic algorithm for speeding up TCP connections. Compared to the best
previous Python implementation, our version turns out to be easier to
understand, more correct, and dramatically shorter.&lt;/p&gt;
&lt;p&gt;This talk assumes basic familiarity with Python, but does &lt;em&gt;not&lt;/em&gt; require
any prior experience with concurrency, async/await, or networking.&lt;/p&gt;
</summary><category term="trio"></category><category term="async"></category><category term="concurrency"></category></entry><entry><title>PyGotham 2011: A Practical Guide to Non-blocking IO, Coroutines, and Concurrency</title><link href="https://pyvideo.org/pygotham-2011/pygotham-2011--a-practical-guide-to-non-blocking-.html" rel="alternate"></link><published>2011-09-16T00:00:00+00:00</published><updated>2011-09-16T00:00:00+00:00</updated><author><name>Robert Hancock</name></author><id>tag:pyvideo.org,2011-09-16:pygotham-2011/pygotham-2011--a-practical-guide-to-non-blocking-.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;From the OS on up how coroutines and threads affect the performance of
your Python programs and who to deal with them.&lt;/p&gt;
</summary><category term="concurrency"></category><category term="coroutines"></category><category term="nonblockingio"></category><category term="pygotham"></category><category term="pygotham2011"></category></entry><entry><title>PyOhio 2010: Lightning Talks</title><link href="https://pyvideo.org/pyohio-2010/pyohio-2010--lightning-talks.html" rel="alternate"></link><published>2010-07-31T00:00:00+00:00</published><updated>2010-07-31T00:00:00+00:00</updated><author><name>Eric Floehr</name></author><id>tag:pyvideo.org,2010-07-31:pyohio-2010/pyohio-2010--lightning-talks.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Lightning Talks&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;00:00 - Eric Floehr: &lt;a class="reference external" href="http://www.manning.com/sande/"&gt;Hello World, Computer Programming for Kids and
Beginners&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;06:00 - Eric Floehr: &lt;a class="reference external" href="http://codespeak.net/lxml/"&gt;lxml&lt;/a&gt;,
&lt;a class="reference external" href="https://fedorahosted.org/suds/"&gt;suds&lt;/a&gt;, and
&lt;a class="reference external" href="http://www.djangoproject.com/"&gt;Django&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;11:40 - (sending people up for swag by rows)&lt;/li&gt;
&lt;li&gt;15:10 - Greg Malcolm: Distributed revision control
(&lt;a class="reference external" href="http://mercurial.selenic.com/"&gt;mercurial&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;23:55 - John Nielsen: Talking about threads in Python, the GIL and
concurrency&lt;/li&gt;
&lt;li&gt;30:10 - Calvin Hendryx-Parker: &lt;a class="reference external" href="http://plone.org/"&gt;Plone 4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;37:00 - Gloria Jacobs: Funky Python Tools&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="lightning talks"></category><category term="concurrency"></category><category term="gil"></category><category term="lxml"></category><category term="mercurial"></category><category term="plone"></category><category term="plone4"></category><category term="pyohio"></category><category term="pyohio2010"></category><category term="suds"></category></entry><entry><title>PyConAU 2010: The future is soon!</title><link href="https://pyvideo.org/pycon-au-2010/pyconau-2010--the-future-is-soon.html" rel="alternate"></link><published>2010-06-26T00:00:00+00:00</published><updated>2010-06-26T00:00:00+00:00</updated><author><name>Brian K Quinlan</name></author><id>tag:pyvideo.org,2010-06-26:pycon-au-2010/pyconau-2010--the-future-is-soon.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The future is soon!&lt;/p&gt;
&lt;p&gt;Presented by Brian K Quinlan (Google)&lt;/p&gt;
&lt;p&gt;This talk introduces PEP 3148, a proposed library that makes it easier
to build concurrent applications or modify existing application to
exploit opportunities for parallelism.&lt;/p&gt;
</summary><category term="concurrency"></category><category term="pyconau"></category><category term="pyconau2010"></category></entry><entry><title>PyCon 2009: A Curious Course on Coroutines and Concurrency (Part 3 of 3)</title><link href="https://pyvideo.org/pycon-us-2009/pycon-2009--a-curious-course-on-coroutines-and-c0.html" rel="alternate"></link><published>2009-02-17T00:00:00+00:00</published><updated>2009-02-17T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2009-02-17:pycon-us-2009/pycon-2009--a-curious-course-on-coroutines-and-c0.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;A Curious Course on Coroutines and Concurrency (part 3 of 3)&lt;/p&gt;
&lt;p&gt;Presented at PyCon 2009 by David Beazley&lt;/p&gt;
&lt;p&gt;If you are a programmer who cares about Python and concurrency, then you
should also care about Python coroutines. Although they were first
introduced in Python 2.5, coroutines remain one of Python's most
overlooked features--- often vaguely described as a curious &amp;quot;extension&amp;quot;
of generator functions with little insight as to how they might be
applied to real-world problems. This tutorial examines coroutines in a
more practical light by showing how they are actually a very elegant way
to implement a processing &amp;quot;task.&amp;quot; Using this task abstraction, it is
possible to use coroutines to implement processing pipelines, event
handling systems, and programs based on cooperative multitasking.
Moreover, if you define tasks using coroutines, they can be easily
incorporated into more traditional concurrent programs that utilize
threads or message passing.&lt;/p&gt;
&lt;p&gt;[VIDEO HAS ISSUES: bit of clipping start to finish.]&lt;/p&gt;
</summary><category term="concurrency"></category><category term="coroutines"></category><category term="generator"></category><category term="pycon"></category><category term="pycon2009"></category><category term="python-advanced"></category></entry><entry><title>PyCon 2009: A Curious Course on Coroutines and Concurrency (Part 2 of 3)</title><link href="https://pyvideo.org/pycon-us-2009/pycon-2009--a-curious-course-on-coroutines-and-c1.html" rel="alternate"></link><published>2009-02-17T00:00:00+00:00</published><updated>2009-02-17T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2009-02-17:pycon-us-2009/pycon-2009--a-curious-course-on-coroutines-and-c1.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;A Curious Course on Coroutines and Concurrency (part 2 of 3)&lt;/p&gt;
&lt;p&gt;Presented at PyCon 2009 by David Beazley&lt;/p&gt;
&lt;p&gt;If you are a programmer who cares about Python and concurrency, then you
should also care about Python coroutines. Although they were first
introduced in Python 2.5, coroutines remain one of Python's most
overlooked features--- often vaguely described as a curious &amp;quot;extension&amp;quot;
of generator functions with little insight as to how they might be
applied to real-world problems. This tutorial examines coroutines in a
more practical light by showing how they are actually a very elegant way
to implement a processing &amp;quot;task.&amp;quot; Using this task abstraction, it is
possible to use coroutines to implement processing pipelines, event
handling systems, and programs based on cooperative multitasking.
Moreover, if you define tasks using coroutines, they can be easily
incorporated into more traditional concurrent programs that utilize
threads or message passing.&lt;/p&gt;
&lt;p&gt;[VIDEO HAS ISSUES: bit of clipping start to finish.]&lt;/p&gt;
</summary><category term="concurrency"></category><category term="coroutines"></category><category term="generator"></category><category term="pycon"></category><category term="pycon2009"></category><category term="python-advanced"></category></entry><entry><title>PyCon 2009: A Curious Course on Coroutines and Concurrency (Part 1 of 3)</title><link href="https://pyvideo.org/pycon-us-2009/pycon-2009--a-curious-course-on-coroutines-and-co.html" rel="alternate"></link><published>2009-02-17T00:00:00+00:00</published><updated>2009-02-17T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2009-02-17:pycon-us-2009/pycon-2009--a-curious-course-on-coroutines-and-co.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;A Curious Course on Coroutines and Concurrency (part 1 of 3)&lt;/p&gt;
&lt;p&gt;Presented at PyCon 2009 by David Beazley&lt;/p&gt;
&lt;p&gt;If you are a programmer who cares about Python and concurrency, then you
should also care about Python coroutines. Although they were first
introduced in Python 2.5, coroutines remain one of Python's most
overlooked features--- often vaguely described as a curious &amp;quot;extension&amp;quot;
of generator functions with little insight as to how they might be
applied to real-world problems. This tutorial examines coroutines in a
more practical light by showing how they are actually a very elegant way
to implement a processing &amp;quot;task.&amp;quot; Using this task abstraction, it is
possible to use coroutines to implement processing pipelines, event
handling systems, and programs based on cooperative multitasking.
Moreover, if you define tasks using coroutines, they can be easily
incorporated into more traditional concurrent programs that utilize
threads or message passing.&lt;/p&gt;
&lt;p&gt;[VIDEO HAS ISSUES: bit of clipping start to finish.]&lt;/p&gt;
</summary><category term="concurrency"></category><category term="coroutines"></category><category term="generator"></category><category term="pycon"></category><category term="pycon2009"></category><category term="python-advanced"></category></entry><entry><title>PyCon 2009: Easy Concurrency with Kamaelia (Part 2 of 2)</title><link href="https://pyvideo.org/pycon-us-2009/pycon-2009--easy-concurrency-with-kamaelia--part-.html" rel="alternate"></link><published>2009-02-17T00:00:00+00:00</published><updated>2009-02-17T00:00:00+00:00</updated><author><name>Unknown</name></author><id>tag:pyvideo.org,2009-02-17:pycon-us-2009/pycon-2009--easy-concurrency-with-kamaelia--part-.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;[VIDEO HAS ISSUES: ] Writing concurrent applications in Python is now
becoming not only easier, but quite elegant and simple, thanks to
Kamaelia. Kamaelia is an interesting component based framework
originating from BBC research. It accomplishes concurrent processing of
data from and to many protocols. Components easily connect and pass data
from and to each other. We are going to explore Kamaelia's strengths and
possibilities, by running simple examples, then trying nested protocol
support, and maybe some other fun examples if time permits.&lt;/p&gt;
</summary><category term="concurrency"></category><category term="kamaelia"></category><category term="pycon"></category><category term="pycon2009"></category></entry><entry><title>PyCon 2009: Easy Concurrency with Kamaelia (Part 1 of 2)</title><link href="https://pyvideo.org/pycon-us-2009/pycon-2009--easy-concurrency-with-kamaelia--part0.html" rel="alternate"></link><published>2009-02-17T00:00:00+00:00</published><updated>2009-02-17T00:00:00+00:00</updated><author><name>Unknown</name></author><id>tag:pyvideo.org,2009-02-17:pycon-us-2009/pycon-2009--easy-concurrency-with-kamaelia--part0.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;[VIDEO HAS ISSUES: ] Writing concurrent applications in Python is now
becoming not only easier, but quite elegant and simple, thanks to
Kamaelia. Kamaelia is an interesting component based framework
originating from BBC research. It accomplishes concurrent processing of
data from and to many protocols. Components easily connect and pass data
from and to each other. We are going to explore Kamaelia's strengths and
possibilities, by running simple examples, then trying nested protocol
support, and maybe some other fun examples if time permits.&lt;/p&gt;
</summary><category term="concurrency"></category><category term="kamaelia"></category><category term="pycon"></category><category term="pycon2009"></category></entry><entry><title>Actors: What, Why, and How (#161)</title><link href="https://pyvideo.org/pycon-us-2010/pycon-2010--actors--what--why--and-how---161.html" rel="alternate"></link><published>2010-02-19T00:00:00+00:00</published><updated>2010-02-19T00:00:00+00:00</updated><author><name>Donovan Preston</name></author><id>tag:pyvideo.org,2010-02-19:pycon-us-2010/pycon-2010--actors--what--why--and-how---161.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Actors: What, Why and How&lt;/p&gt;
&lt;p&gt;Presented by Donovan Preston&lt;/p&gt;
&lt;p&gt;Since the dawn of concurrency research, there have been two camps:
shared everything, and shared nothing. Most modern applications use
threads for concurrency, a shared everything architecture.&lt;/p&gt;
&lt;p&gt;Actors, however, use a shared nothing architecture where lightweight
processes communicate with each other using message passing. Actors can
change their state, create a new Actor, send a message to any Actor it
has the Address of, and wait for a specific kind of message to arrive in
it's mailbox.&lt;/p&gt;
&lt;p&gt;We will discuss the benefits of using the Actor architecture and
strategies for implementing an Actor system in Python.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://bitbucket.org/fzzzy/python-%20actors/"&gt;http://bitbucket.org/fzzzy/python-actors/&lt;/a&gt;&lt;/p&gt;
</summary><category term="concurrency"></category><category term="eventlet"></category><category term="infrastructure"></category><category term="pycon"></category><category term="pycon2010"></category><category term="rest"></category><category term="scaling"></category><category term="wsgi"></category></entry><entry><title>Python for Large Astronomical Data Reduction and Analysis Systems (#107)</title><link href="https://pyvideo.org/pycon-us-2010/pycon-2010--python-for-large-astronomical-data-re.html" rel="alternate"></link><published>2010-02-19T00:00:00+00:00</published><updated>2010-02-19T00:00:00+00:00</updated><author><name>Francesco Pierfederici</name></author><id>tag:pyvideo.org,2010-02-19:pycon-us-2010/pycon-2010--python-for-large-astronomical-data-re.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python for Large Astronomical Data Reduction and Analysis Systems&lt;/p&gt;
&lt;p&gt;Presented by Francesco Pierfederici (Harvard-Smithsonian Center for
Astrophysics)&lt;/p&gt;
&lt;p&gt;We describe how Python is used in a large astronomy project to
automatically process data from several telescopes in both the
hemispheres. We introduce the general problem and discuss challenges and
lessons learned.&lt;/p&gt;
</summary><category term="astronomy"></category><category term="casestudy"></category><category term="concurrency"></category><category term="pycon"></category><category term="pycon2010"></category></entry><entry><title>Understanding the Python GIL (#82)</title><link href="https://pyvideo.org/pycon-us-2010/pycon-2010--understanding-the-python-gil---82.html" rel="alternate"></link><published>2010-02-19T00:00:00+00:00</published><updated>2010-02-19T00:00:00+00:00</updated><author><name>David Beazley</name></author><id>tag:pyvideo.org,2010-02-19:pycon-us-2010/pycon-2010--understanding-the-python-gil---82.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Understanding the Python GIL&lt;/p&gt;
&lt;p&gt;Presented by David Beazley&lt;/p&gt;
&lt;p&gt;The Python Global Interpreter Lock (GIL) is a frequent source of debate
and concern for programmers working with threads and concurrency.
Although most Python programmers generally know that the GIL restricts
Python's ability to utilize multiple CPUs, few know the inner details of
how it actually works and how it impacts applications. This talk will
dive into the inner workings of the GIL like you've never seen before.
Topics include details about the execution of the Python interpreter,
thread implementation, the GILs surprising behavior on multicore CPUs,
and more.&lt;/p&gt;
</summary><category term="concurrency"></category><category term="gil"></category><category term="pycon"></category><category term="pycon2010"></category><category term="threads"></category></entry><entry><title>Jython Concurrency</title><link href="https://pyvideo.org/pycon-us-2011/pycon-2011--jython-concurrency.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Jim Baker</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--jython-concurrency.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Jython Concurrency&lt;/p&gt;
&lt;p&gt;Presented by Jim Baker&lt;/p&gt;
&lt;p&gt;Jython is arguably the best Python implementation to target concurrent
code. Jython has no GIL, it leverages the Java platform to provide
robust support for concurrency in its runtime, and it enables access to
a set of high-level abstractions from Java. This talk will walk through
at the extreme level pertinent Jython implementation details and a
series of examples, including Java integration.&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;Jython implements the Python language, but we leverage the underlying
Java platform to provide an opionated alternative to CPython in our
support of concurrency.&lt;/p&gt;
&lt;p&gt;Because of the GIL and related infrastructure, CPython cannot use a
model in which threads perform concurrent computation defined in Python
on shared objects in the same process. (Of course, there are
workarounds, such as multiprocessing or using C extensions.)&lt;/p&gt;
&lt;p&gt;In contrast, there's no GIL in Jython. Jython instead embraces threads,
provides extensive support for managing their execution and coordination
through standard Java platform functionality (java.util.concurrent), and
threaded code works well with Jython's implementation of standard
mutable collection types. Lastly, the underlying JVM provides extensive
instrumentation as well as the ability to set a variety of parameters,
including choice of GC. There are also the inevitable pitfalls that
might be seen in complex architectures, such as around the use of
ClassLoaders.&lt;/p&gt;
&lt;p&gt;This talk will go into a detailed discussion of some of the interesting
ramifications of these design points and how they can be effectively
applied to write concurrent code, as illustrated through a variety of
short examples.&lt;/p&gt;
</summary><category term="concurrency"></category><category term="java"></category><category term="jython"></category><category term="pycon"></category><category term="pycon2011"></category></entry></feed>