<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org - Willem Van Onsem</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Mon, 23 Sep 2024 00:00:00 +0000</lastBuildDate><item><title>path('/user/&lt;user.username:user&gt;/', view_profile)</title><link>https://pyvideo.org/djangocon-us-2024/pathuseruserusernameuser-view_profile.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Since Django-2.0, most people use path converters instead of regexes to describe the different URL patterns, and how these will trigger views. One can use the already builtin path converters, but also define new ones to parse dates, booleans, etc. more effectively. One can not only define a pattern, but also provide methods to convert between Python objects and URL fragments.&lt;/p&gt;
&lt;p&gt;That last feature can be used to automatically fetch model objects if the path contains the value for the primary key of the model object, or another unique field. We thus avoid writing queries to fetch the objects, but can also turn these into lazy objects where we postpone the roundtrip to the database, until the view needs that object, and thus save a roundtrip if the view has a codepath that does not require the object. Some databases also allow to combine multiple queries in one roundtrip, so we can combine all the objects that go to the same database, limiting the roundtrips further.&lt;/p&gt;
&lt;p&gt;A problem with path patterns in general is that often they overlap: the same path can trigger multiple patterns. In that case the first one is picked. This issue has already lead to countless hours of debugging since people expect a different view to be triggered. Since path patterns eventually compile to regexes, and one can determine if two regexes (fully) overlap, we can automatically detect if there are paths for which two or more URL patterns are triggered, and in case a pattern is fully covered by patterns above, advise to rearrange the patterns. Probably not very suprisingly we found that Django's admin pages suffer from this issue as well: if we make a model with a &lt;cite&gt;CharField&lt;/cite&gt; as primary key, then adding items with &amp;quot;remove&amp;quot; or &amp;quot;history&amp;quot; as value for the primary key, means certain views can not be used for these objects. We show some ways to mitigate this.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Willem Van Onsem</dc:creator><pubDate>Mon, 23 Sep 2024 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2024-09-23:/djangocon-us-2024/pathuseruserusernameuser-view_profile.html</guid><category>DjangoCon US 2024</category></item></channel></rss>