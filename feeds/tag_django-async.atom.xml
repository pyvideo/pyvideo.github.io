<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/tag_django-async.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2018-10-06T00:00:00+00:00</updated><entry><title>Taking Django Async</title><link href="https://pyvideo.org/pycon-es-2018/taking-django-async.html" rel="alternate"></link><published>2018-10-06T00:00:00+00:00</published><updated>2018-10-06T00:00:00+00:00</updated><author><name>Andrew Godwin</name></author><id>tag:pyvideo.org,2018-10-06:pycon-es-2018/taking-django-async.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The Django Channels project has taken a major turn with version 2.0, embracing Python's async functionality and building applications around an async event loop rather than worker processes. But why the big change? And what does it mean for Django?&lt;/p&gt;
&lt;p&gt;We'll look at the progress Channels is making in turning more of the request/response cycle into native async code - how far can we get down the stack before making APIs async becomes hard? Can we make it as far as the ORM? How do we bridge between Django's synchronous world and the async world when we do reach that boundary?&lt;/p&gt;
&lt;p&gt;We also take a look at how it's changed both Channels consumers, opening up the possibility of mixing async calls in with your synchronous code, and how it's changed what the ASGI spec looks like and what that might mean for adoption.&lt;/p&gt;
&lt;p&gt;And, finally, we'll look what's next for Django and Channels, and maybe how it will affect the Python web world as a whole.&lt;/p&gt;
</summary><category term="django async"></category></entry></feed>