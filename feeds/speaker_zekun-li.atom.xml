<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_zekun-li.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2018-05-13T00:00:00+00:00</updated><entry><title>There and Back Again: Disable and re-enable garbage collector at Instagram</title><link href="https://pyvideo.org/pycon-us-2018/there-and-back-again-disable-and-re-enable-garbage-collector-at-instagram.html" rel="alternate"></link><published>2018-05-13T00:00:00+00:00</published><updated>2018-05-13T00:00:00+00:00</updated><author><name>Zekun Li</name></author><id>tag:pyvideo.org,2018-05-13:pycon-us-2018/there-and-back-again-disable-and-re-enable-garbage-collector-at-instagram.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python's cyclic garbage collector wonderfully hides the complexity of memory management from the programmer. But we pay the price in performance. Ever wondered how that works? In this talk, you'll learn how garbage collection is designed in Python, what the tradeoffs are and how Instagram battled copy-on-write memory issues by disabling the garbage collector entirely.&lt;/p&gt;
&lt;p&gt;You'll also learn why that isn't such a great idea after all and how we ended up extending the garbage collector API which allowed us to (mostly) re-enable garbage collection. We'll discuss our upstream contributions to the garbage collector that landed in Python 3.6 and 3.7.&lt;/p&gt;
&lt;p&gt;This is an in-depth talk about memory management but no prior experience with CPython internals is necessary to follow it.&lt;/p&gt;
</summary><category term="garbage collector"></category></entry></feed>