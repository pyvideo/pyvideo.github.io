<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_reuven-lerner.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2019-07-11T00:00:00+00:00</updated><entry><title>Practical decorators</title><link href="https://pyvideo.org/europython-2019/practical-decorators.html" rel="alternate"></link><published>2019-07-11T00:00:00+00:00</published><updated>2019-07-11T00:00:00+00:00</updated><author><name>Reuven Lerner</name></author><id>tag:pyvideo.org,2019-07-11:europython-2019/practical-decorators.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Decorators are one of Python's most powerful features. But even if you
understand what they do, it's not always obvious what you can do with
them. Sure, from a practical perspective, they let you remove repeated
code from your callables. And semantically, they let you think at a
higher level of abstraction, applying the same treatment to functions
and classes.&lt;/p&gt;
&lt;p&gt;But what can you actually do with them? For many Python developers I've
encountered, decorators sometimes appear to be a solution looking for a
problem.&lt;/p&gt;
&lt;p&gt;In this talk, I'll show you some practical uses for decorators, and how
you can use them to make your code more readable and maintainable, while
also providing more semantic power. Moreover, you'll see examples of
things would be hard to do without decorators. I hope that after this
talk, you'll have a good sense of how to use decorators in your own
Python projects.&lt;/p&gt;
</summary><category term="Compiler and Interpreters"></category><category term="Data Structures"></category><category term="Programming"></category><category term="Python Skills"></category><category term="Python general"></category></entry></feed>