<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org - Alastair Stanley</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_alastair-stanley.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2024-05-18T00:00:00+00:00</updated><subtitle></subtitle><entry><title>Meta Generators: Playing Safe with Long Sequences</title><link href="https://pyvideo.org/pycon-uk-2022/meta-generators-playing-safe-with-long-sequences.html" rel="alternate"></link><published>2022-09-17T00:00:00+00:00</published><updated>2022-09-17T00:00:00+00:00</updated><author><name>Alastair Stanley</name></author><id>tag:pyvideo.org,2022-09-17:/pycon-uk-2022/meta-generators-playing-safe-with-long-sequences.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Let’s take a closer look at generators and why you may not be getting your expected improvements. Sometimes the memory benefit is negated by necessity; sometimes it's by mistake. &amp;quot;Meta generators&amp;quot; can solve this problem, allowing a much wider range of safe, fast operations on very large generators …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Let’s take a closer look at generators and why you may not be getting your expected improvements. Sometimes the memory benefit is negated by necessity; sometimes it's by mistake. &amp;quot;Meta generators&amp;quot; can solve this problem, allowing a much wider range of safe, fast operations on very large generators.&lt;/p&gt;
&lt;p&gt;Through this talk, I want to highlight the dangers of trying to write very large or theoretically infinite Python generators to lists (obvious), and the ease with which it can be done accidentally (less obvious).&lt;/p&gt;
&lt;p&gt;The talk will start with an example of when one might want to use some very large generators to solve a problem. I will discuss some common operations that we use to combine generators (chain, product, zip, etc.), and then go into detail about why some of these are &amp;quot;safe&amp;quot; to use on very large generators (chain, zip), while others are very much not (product).&lt;/p&gt;
&lt;p&gt;The second part of the talk, which will explain our solution to this problem – &amp;quot;meta-generators&amp;quot; – also doubles as a recommendation for a future language feature.&lt;/p&gt;
</content><category term="PyCon UK 2022"></category></entry><entry><title>Computational Origami</title><link href="https://pyvideo.org/pycon-us-2024/computational-origami.html" rel="alternate"></link><published>2024-05-18T00:00:00+00:00</published><updated>2024-05-18T00:00:00+00:00</updated><author><name>Alastair Stanley</name></author><id>tag:pyvideo.org,2024-05-18:/pycon-us-2024/computational-origami.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;What's the best thing you can do with a piece of paper?&lt;/p&gt;
&lt;p&gt;I'm not talking about paper planes or dragons (or even Mr. Napkin Head).
The elegant art of paper folding can be harnessed to perform
surprisingly powerful calculations. From a handful of basic folding
axioms, we will construct …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;What's the best thing you can do with a piece of paper?&lt;/p&gt;
&lt;p&gt;I'm not talking about paper planes or dragons (or even Mr. Napkin Head).
The elegant art of paper folding can be harnessed to perform
surprisingly powerful calculations. From a handful of basic folding
axioms, we will construct computational systems to solve a wide range of
problems. Starting with basic arithmetic operations, we will build up to
tackling cubic equations and even proofs of irrationality.&lt;/p&gt;
&lt;p&gt;I'll be simulating the fold sequences in a custom Python library, but
feel free to bring a sheet of paper to follow along.&lt;/p&gt;
</content><category term="PyCon US 2024"></category></entry></feed>