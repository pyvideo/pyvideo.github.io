<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/tag_cpython.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2019-07-12T00:00:00+00:00</updated><entry><title>Hack The CPython</title><link href="https://pyvideo.org/europython-2019/hack-the-cpython.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Batuhan Ta≈ükaya</name></author><id>tag:pyvideo.org,2019-07-12:europython-2019/hack-the-cpython.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Have you ever realized how dynamic CPython interpreter is? Maybe it is
the most dynamic interpreter you may see. It gives interfaces to
internal things like garbage collector or AST, allows to alter functions
code, modify built-in functions etc.&lt;/p&gt;
&lt;p&gt;This talk will go beyond that dynamism. From adding a new syntax to
hooking the evaluation loop, it will show how to hack parts of python.&lt;/p&gt;
&lt;p&gt;Before understanding these hacks, you will learn internals of CPython
step-by- step. Steps are important because in every step we have at
least one hacking option. Also it gives the audience a short brief of
how python works.&lt;/p&gt;
&lt;p&gt;After learning how cpython works, we'll cover how to hack (use things
that is not their main purpose) the interpreter and the interfaces it
gave. For an example we will disassembly the bytecode and then assemble
it again with adding our statements or adding a new syntax for python at
runtime with AST.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Talk will hack these steps:&lt;/div&gt;
&lt;div class="line"&gt;- AST&lt;/div&gt;
&lt;div class="line"&gt;- Bytecode&lt;/div&gt;
&lt;div class="line"&gt;- CTypes&lt;/div&gt;
&lt;div class="line"&gt;- CPython evaluation loop&lt;/div&gt;
&lt;/div&gt;
</summary><category term="CPython"></category></entry><entry><title>import bacon ü•ì</title><link href="https://pyvideo.org/europython-2019/import-bacon.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Ivana Kellyerova</name></author><id>tag:pyvideo.org,2019-07-12:europython-2019/import-bacon.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;It's often said that Python comes with batteries included, meaning that
the standard library can do basically anything except for maybe conjure
bacon for you (though I heard that's coming in 3.8). I don't think we
fully appreciate the sheer vastness of it, though, so I went through it
module by module looking for hidden gems (sorry, eggs). This is a by no
means exhaustive compilation of the useful, the underrated, and the
funny.&lt;/p&gt;
&lt;p&gt;When it comes to the Python standard library, chances are you use it on
a daily basis -- or more likely, a more or less stable subset of it. The
usual way we add things to the subset is by looking for a solution to a
problem and ending up getting pointed to a standard library module.
That, however, means that the odds of you finding out that there is a
whole module whose sole purpose is to tell you if a string is a Python
keyword are very slim.&lt;/p&gt;
&lt;p&gt;The aim of this talk is to showcase CPython libraries that are
interesting in some way: mostly for their usefulness, but in some cases
simply for being wonderfully weird in some way. The talk is not aimed at
any particular level of Python experience - as a beginner you'll get a
taste of just how many batteries Python ships with, and as a person
using the language often you might end up growing your own personal
subset a bit more.&lt;/p&gt;
</summary><category term="CPython"></category><category term="Python general"></category></entry><entry><title>Python Standard Library, The Hidden Gems</title><link href="https://pyvideo.org/europython-2019/python-standard-library-the-hidden-gems.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Alessandro Molina</name></author><id>tag:pyvideo.org,2019-07-12:europython-2019/python-standard-library-the-hidden-gems.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The Python Standard Library is a very rich toolset, which is the reason
why Python is stated to come with &amp;quot;batteries included&amp;quot;. In such an
amount of features and tools it's easy to get lost and miss some of the
less unknown modules or gems hidden within the whole load of functions
and classes.&lt;/p&gt;
&lt;p&gt;This talk aims at showcasing some recipes, snippets and usages of
standard library modules and functions that are less known or that are
not covered in the most common books and tutorials available for Python.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;The talk will try to showcase a bunch of short examples in the hope to
foster the &amp;quot;oh, wow! I didn't think about that&amp;quot; reaction at least once
in the audience.&lt;/div&gt;
&lt;div class="line"&gt;We will see how frequently for tasks where you used third party
libraries or frameworks a solution bultin into the standard library is
already available, and such solution is guaranteed to be maintained
and well working for the years to come thanks to the standard library
reliability and stability.&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;The showcased examples are took from the ‚ÄúModern Python Standard Library
Cookbook‚Äù book that I authored.&lt;/p&gt;
</summary><category term="CPython"></category><category term="Debugging"></category><category term="Development"></category><category term="General"></category><category term="python"></category></entry><entry><title>The soul of the beast</title><link href="https://pyvideo.org/europython-2019/the-soul-of-the-beast.html" rel="alternate"></link><published>2019-07-12T00:00:00+00:00</published><updated>2019-07-12T00:00:00+00:00</updated><author><name>Pablo Salgado</name></author><id>tag:pyvideo.org,2019-07-12:europython-2019/the-soul-of-the-beast.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;div class="section" id="why"&gt;
&lt;h4&gt;Why&lt;/h4&gt;
&lt;p&gt;The audience will discover one of the core pieces of the language that
sits at the middle of the decisions about what new rules can or cannot
be implemented in the Python programming language. They will learn how
the particularities of the grammar limit what can be achieved but also
serve to maintain the language consistent, powerful but straightforward.
Attendants will learn how core developers solved some challenging
scenarios that arise as a consequence of said limitations or how others
cannot be resolved unless Python gets a significant transformation in
the internal mechanism that parses the grammar. Finally, they will learn
how a new rule is added to the CPython grammar, serving as a perfect
example of how all the pieces come together. In summary, the audience
will gain a more technical response to why people perceive the Python
programming language as easy but powerful one and at the same time will
gain some insight on how to understand and extend the pieces that form
it. This talk will not only help members of the audience understand
better the design of the language a how grammars and parser work, but
will also help people wanting to contribute to CPython understanding the
general structure of the compiler pipeline and how to work on it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="who"&gt;
&lt;h4&gt;Who&lt;/h4&gt;
&lt;p&gt;This talk is for those that want to understand Python a bit deeper: not
only how everything works under the hood but also what are the technical
decisions in its making and what are the consequences. The talk is
targeted to all Python programmers, no matter the skill level as
everyone will find something for their particular level of expertise:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Beginner programmers will be introduced in the topic of language
grammars and will learn what a Grammar is and what are the building
blocks. Also, the audience members in this level will gain insight into
how everything is thread together in CPython.&lt;/li&gt;
&lt;li&gt;Medium and advanced programmers will learn some in-depth technical
details and how they relate to features they already know and
understand. The talk not only will try to enlight some new areas related
to grammar technicalities, parser features and design and CPython
implementation details but will also connect many pieces of information
to explain how the small technical decisions impact the bigger picture.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="outline"&gt;
&lt;h4&gt;Outline&lt;/h4&gt;
&lt;p&gt;Who am I&lt;/p&gt;
&lt;p&gt;What is the Python Grammar&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;What is grammar?&lt;/li&gt;
&lt;li&gt;How they look like.&lt;/li&gt;
&lt;li&gt;Elements: terminal symbols, nonterminal symbols, productions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The properties of Python Grammar?&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Leftmost derivation&lt;/li&gt;
&lt;li&gt;1 token lookahead&lt;/li&gt;
&lt;li&gt;No epsilon productions! (Plus what epsilon productions are)&lt;/li&gt;
&lt;li&gt;Some immediate consequences of these properties.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;How the Python parser generator works&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;General structure of the parser generator.&lt;/li&gt;
&lt;li&gt;Non Deterministic Finite Automata&lt;/li&gt;
&lt;li&gt;Deterministic Finite Automata.&lt;/li&gt;
&lt;li&gt;Some examples (with cool graphs!) generated from the
python grammar and the parser generator of the actual
finite automatas that Python uses.&lt;/li&gt;
&lt;li&gt;Concrete syntax trees.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Advantages of the grammar (or &amp;quot;why Python is so easy to understand)&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;LL(1) grammars are context-free (no state to maintain while
parsing).&lt;/li&gt;
&lt;li&gt;LL(1) grammars are simple to implement and very fast to parse.&lt;/li&gt;
&lt;li&gt;LL(1) grammars are very limited, keeping the language simple&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Disadvantages of the grammar:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Grammar ambiguity.&lt;/li&gt;
&lt;li&gt;LL(1) grammars need some hacks for very simple things.&lt;/li&gt;
&lt;li&gt;How keyword arguments were incorporated in the grammar with a hack:
The grammar rule is very strange because it is &amp;quot;fixed&amp;quot; in the Abstract
syntax tree&lt;/li&gt;
&lt;li&gt;Why parenthesized with statements cannot be implemented (with
statements
formed of multiple elements surrounded by parenthesis and separated by
commas).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Implementing a new grammar rule in CPython: the arrow operator :&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;A complete mini-tutorial on how to introduce a new operator: A -&amp;gt; B
that gets executed as A.&lt;strong&gt;rarrow&lt;/strong&gt;(B).&lt;/li&gt;
&lt;li&gt;Altering the grammar and generating the new parser.&lt;/li&gt;
&lt;li&gt;Introducing a new token.&lt;/li&gt;
&lt;li&gt;Changing the tokenizer.&lt;/li&gt;
&lt;li&gt;Changing the Abstract Syntax Tree Generator.&lt;/li&gt;
&lt;li&gt;Changing the compiler.&lt;/li&gt;
&lt;li&gt;Implementing the new opcode.&lt;/li&gt;
&lt;li&gt;Implementing the &lt;strong&gt;rarrow&lt;/strong&gt; protocol.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The future and summary of the talk:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;We have been discussing in the CPython discourse to change the
parser generator to something
more powerful.&lt;/li&gt;
&lt;li&gt;Dangers and advantages of other parser generators.&lt;/li&gt;
&lt;li&gt;What other implementations are using?&lt;/li&gt;
&lt;li&gt;Summary of the talk&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="Abstractions"></category><category term="CPython"></category><category term="Performance"></category><category term="python"></category></entry><entry><title>Introduction to low-level profiling and tracing</title><link href="https://pyvideo.org/europython-2019/introduction-to-low-level-profiling-and-tracing.html" rel="alternate"></link><published>2019-07-11T00:00:00+00:00</published><updated>2019-07-11T00:00:00+00:00</updated><author><name>Christian Heimes</name></author><id>tag:pyvideo.org,2019-07-11:europython-2019/introduction-to-low-level-profiling-and-tracing.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python has built-in tracing and profiling facilities in form of callback
hooks in the sys module. The settrace and setprofile callbacks have
several drawbacks. They slow down the Python interpreter considerable
and only allow tracing of Python code. Modern OS and CPUs come with a
variety of APIs for efficient and low-level tracing down to system
calls, Kernel space code, and hardware events. Some tools even create
code that runs in Kernel space.&lt;/p&gt;
&lt;p&gt;This talks is an introduction and comparison of various low and high
level tools for profiling and tracing as well as visualization tools
like flame graphs. It covers ptrace, perf, SystemTap, and BCC/eBPF.
Ptrace based commands like strace are easy to use but slow. Perf allows
lightweight profiling of hardware events and CPU instructions. SystemTap
is a powerful toolkit plus DSL to instrument probe points inside the
Kernel as well as static SystemTap/DTrace markers in libs and languages
like Java, PHP, and Python. CPython comes with a set of instrumentations
for SystemTap. BCC is a collection of tools that run as JIT optimized
eBPF code in Kernel space.&lt;/p&gt;
&lt;p&gt;The talk is an introduction to basic concepts of low-level tracing and
profiling on Linux. The main goal is the show the potential of the
tools.&lt;/p&gt;
</summary><category term="CPython"></category><category term="DevOps general"></category><category term="Performance"></category></entry><entry><title>Understanding Numba - the Python and Numpy compiler</title><link href="https://pyvideo.org/europython-2019/understanding-numba-the-python-and-numpy-compiler.html" rel="alternate"></link><published>2019-07-11T00:00:00+00:00</published><updated>2019-07-11T00:00:00+00:00</updated><author><name>Christoph Deil</name></author><id>tag:pyvideo.org,2019-07-11:europython-2019/understanding-numba-the-python-and-numpy-compiler.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Do you have numerical code written in Python and Numpy? Do you wish it
ran faster, using the full potential of your CPU?&lt;/p&gt;
&lt;p&gt;Then you should try Numba, a JIT compiler that translates a subset of
Python and Numpy code into fast machine code.&lt;/p&gt;
&lt;p&gt;This talk will explain how Numba works, and when and how to use it for
numerical algorithms, focusing on how to get very good performance on
the CPU.&lt;/p&gt;
&lt;p&gt;To understand this talk, only a basic knowledge of Python and Numpy is
needed.&lt;/p&gt;
&lt;p&gt;You will learn how Python compiles functions to bytecode and how Numba
compiles bytecode to machine code. Why algorithms implemented using
Numpy sometimes don't yield great performance, and how to do better
using Numba. You will learn about the &amp;#64;numba.jit and &amp;#64;numba.vectorize
decorators and how to create functions that use the CPU well by using
e.g. multi-threading (several CPU cores), vector instructions (single
instruction multiple data) and fast math (trade float accuracy for
speed).&lt;/p&gt;
&lt;p&gt;You will also learn when it does and doesn't make sense to use Numba, by
contrasting it briefly with some other options for high-performance
computing from Python: PyPy, C, C++, Cython, Numexpr, Dask, PyTorch,
Tensorflow and Google JAX&lt;/p&gt;
</summary><category term="CPython"></category><category term="Compiler and Interpreters"></category><category term="Multi-Threading"></category><category term="Performance"></category><category term="Scientific Libraries (Numpy/Pandas/SciKit/...)"></category></entry><entry><title>PyRun - Shipping the Python 3.7 runtime in just 4.8MB</title><link href="https://pyvideo.org/europython-2019/pyrun-shipping-the-python-37-runtime-in-just-48mb.html" rel="alternate"></link><published>2019-07-10T00:00:00+00:00</published><updated>2019-07-10T00:00:00+00:00</updated><author><name>Marc-Andre Lemburg</name></author><id>tag:pyvideo.org,2019-07-10:europython-2019/pyrun-shipping-the-python-37-runtime-in-just-48mb.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python has become the defacto standard tool for many people to write
tools, command scripts, smaller applications and even large
applications.&lt;/p&gt;
&lt;p&gt;On Windows, it is fairly easy to build application bundles using e.g.
py2exe, but on Unix, the situation is less obvious, unless you want to
rely on OS specific Python distributions, which often require severall
100MB with of installation on the system and are usually customized in
distribution specific ways.&lt;/p&gt;
&lt;p&gt;Instead of relying on OS installed Python distributions on Unix, our
open- source eGenix PyRun provides a more or less complete Python
runtime (interpreter and stdlib modules) in a single file, which can be
&amp;quot;installed&amp;quot; by simply copying the binary to the destination system. The
file can be as small as 4.8MB for Python 3.7, by using compressors such
as upx.&lt;/p&gt;
&lt;p&gt;Due to its size, it's also the perfect Python distribution for Docker
containers.&lt;/p&gt;
&lt;p&gt;The talk will show how PyRun works, is built, how to customize it to
include additional modules and applications.&lt;/p&gt;
</summary><category term="CPython"></category><category term="Development"></category><category term="Linux"></category><category term="Tooling"></category><category term="Use Case"></category></entry><entry><title>Unleash the power of C++ in Python</title><link href="https://pyvideo.org/europython-2019/unleash-the-power-of-c-in-python.html" rel="alternate"></link><published>2019-07-10T00:00:00+00:00</published><updated>2019-07-10T00:00:00+00:00</updated><author><name>Cristi√°n Maureira-Fredes</name></author><id>tag:pyvideo.org,2019-07-10:europython-2019/unleash-the-power-of-c-in-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;div class="line-block"&gt;
&lt;div class="line"&gt;One of the main Python aspects is to have a clear syntax and be an&lt;/div&gt;
&lt;div class="line"&gt;easy-to-understand language, which compared to others like C++&lt;/div&gt;
&lt;div class="line"&gt;(depending of the kindness of the developer) can make a huge
difference.&lt;/div&gt;
&lt;div class="line"&gt;Not only the readability is in play, having a dynamically typed&lt;/div&gt;
&lt;div class="line"&gt;and interpreted language improves the development workflow.&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;This improvement comes with a cost, performance.&lt;/div&gt;
&lt;div class="line"&gt;In most of the cases, a raw comparison of simple routines will leave&lt;/div&gt;
&lt;div class="line"&gt;Python behind, but there is a partial solution to this problem,
connecting&lt;/div&gt;
&lt;div class="line"&gt;a powerful performant C++ library with the simplicity of Python.&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;In this talk, we will go through the process of generating language
bindings&lt;/div&gt;
&lt;div class="line"&gt;to allow you to take any amazing C or C++ project and bring it to
Python&lt;/div&gt;
&lt;div class="line"&gt;land. We will briefly discuss one of the many success stories, and we
will&lt;/div&gt;
&lt;div class="line"&gt;analyze how the Qt project managed to expose its whole framework to
Python,&lt;/div&gt;
&lt;div class="line"&gt;with the help of a self-made binding generator called Shiboken.&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;After the talk, you will be able to decide which option is better for
the&lt;/div&gt;
&lt;div class="line"&gt;projects you have in mind, and with a bit of luck you will be
responsible&lt;/div&gt;
&lt;div class="line"&gt;of exposing the next popular C++ library that makes the life of us all
Pythonistas easier.&lt;/div&gt;
&lt;/div&gt;
</summary><category term="C-Languages"></category><category term="CPython"></category></entry><entry><title>What a Bug can Teach You about Python</title><link href="https://pyvideo.org/pycon-ca-2018/what-a-bug-can-teach-you-about-python.html" rel="alternate"></link><published>2018-11-11T00:00:00+00:00</published><updated>2018-11-11T00:00:00+00:00</updated><author><name>Brad Dettmer</name></author><id>tag:pyvideo.org,2018-11-11:pycon-ca-2018/what-a-bug-can-teach-you-about-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;We‚Äôll take a look at some Python code that has a strange bug in it. You‚Äôll learn why it‚Äôs a bug and why it only occurs with larger numbers. We‚Äôll cover fixes, dive into how Python works and look at some CPython source code. You‚Äôll learn about ‚Äúis‚Äù vs ‚Äú==‚Äù and how to prevent bugs.&lt;/p&gt;
&lt;p&gt;We‚Äôll take a look at some Python code that has a strange integer bug in it. You‚Äôll learn about how the bug was discovered, and by the end of the talk you‚Äôll understand why it‚Äôs a bug and why the bug only occurs with larger integers. You‚Äôll see a one character fix to the bug, and then an even better fix. We‚Äôll look at CPython's longobject.c source code to understand how smaller integers are handled differently than larger ones. We‚Äôll explore the difference between comparing values in Python versus testing for identity. Hopefully you‚Äôll gain an appreciation that bugs can be your best teachers and be able to prevent more bugs.&lt;/p&gt;
</summary><category term="cpython"></category><category term="debugging"></category></entry><entry><title>CPython loves your Pull Requests</title><link href="https://pyvideo.org/pycon-italia-2018/cpython-loves-your-pull-requests.html" rel="alternate"></link><published>2018-04-21T00:00:00+00:00</published><updated>2018-04-21T00:00:00+00:00</updated><author><name>St√©phane Wirtel</name></author><id>tag:pyvideo.org,2018-04-21:pycon-italia-2018/cpython-loves-your-pull-requests.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;div class="section" id="description"&gt;
&lt;h4&gt;Description&lt;/h4&gt;
&lt;p&gt;CPython, what‚Äôs CPython. CPython is the official implementation of
Python, written in C. And it‚Äôs not just a implementation, it is a group
of volunteers and where they daily work on the project but there is no
many active contributors.&lt;/p&gt;
&lt;p&gt;In this talk, I would like to prove to you than you can become an active
contributor of CPython.&lt;/p&gt;
&lt;p&gt;The core developers of CPython need your help, for example, with the
review of some patches, you can comment a patch or try to reproduce a
bug.&lt;/p&gt;
&lt;p&gt;In the past, when you wanted to contribute to CPython, you had to use
the bug tracker interface and send a patch, this patch was reviewed if
you were lucky and after commented etc‚Ä¶. but this process was really
long and time consuming.&lt;/p&gt;
&lt;p&gt;Now with the new process based on GitHub and Git, you can create a new
branch on your local repository and just send a Pull Request. The Pull
Request is just awesome, it will be reviewed really quickly, we will
comment your Pull Request and if the code is correct and the tests pass,
then you PR will be merged in CPython.&lt;/p&gt;
&lt;p&gt;We love and need your Pull Requests for CPython.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="audience"&gt;
&lt;h4&gt;Audience&lt;/h4&gt;
&lt;p&gt;For new comers to CPython and the future contributors and of course for
the regular contributors and core-dev of CPython.&lt;/p&gt;
&lt;p&gt;With this migration to GitHub, I will show the work done by the
migration team, the benefits of this migration and the new
tools/workflow. Few tools have been developed to help the core-dev. For
example, Miss Islington has been developed for an automatic back-port of
a branch from Python ‚Äòmaster‚Äô to Python 3.6 or 3.5, just with a ‚Äúlabel‚Äù
on the Pull Request&lt;/p&gt;
&lt;p&gt;I will show some stats about the contributors and the contributions on
the CPython project. For example, in November 2017, 4207 pull requests
from the community since the migration in Feb 2017.&lt;/p&gt;
&lt;p&gt;The talk is explained with a story ‚ÄúOnce upon a time‚Äù and with humour.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="outline"&gt;
&lt;h4&gt;Outline&lt;/h4&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Introduction&lt;ul&gt;
&lt;li&gt;small history about the beginning of Python, the status and the
challenges.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Former workflows, former tools:&lt;ul&gt;
&lt;li&gt;the CLA (PSF Contributor Agreement)&lt;/li&gt;
&lt;li&gt;the bug tracker&lt;/li&gt;
&lt;li&gt;patch review with the Rietveld tool&lt;/li&gt;
&lt;li&gt;typical workflow&lt;/li&gt;
&lt;li&gt;conclusion: We have an issue for the new comers&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;New workflow, new tools&lt;ul&gt;
&lt;li&gt;Git, why?&lt;/li&gt;
&lt;li&gt;Github, why?&lt;/li&gt;
&lt;li&gt;Web interface, Pull Requests, Dashboards&lt;/li&gt;
&lt;li&gt;REST API, GraphQL API for the statistics&lt;/li&gt;
&lt;li&gt;Automation with Travis, AppVeyor&lt;/li&gt;
&lt;li&gt;New Bots: Bedevere, Miss Islington, ‚ÄúThe Knights who say ni!‚Äù&lt;/li&gt;
&lt;li&gt;New tool: Blurb&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Comparison between the former and new workflow&lt;/li&gt;
&lt;li&gt;Statistics (between Feb 2017, and Nov 2017)&lt;ul&gt;
&lt;li&gt;Number of Pull Requests (4204)&lt;/li&gt;
&lt;li&gt;Number of Contributors (586) vs Core Dev&lt;/li&gt;
&lt;li&gt;Merge time, Top, Average, etc‚Ä¶.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Q&amp;amp;A ?&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="additional-notes"&gt;
&lt;h4&gt;Additional notes&lt;/h4&gt;
&lt;p&gt;This talk has been presented at PyCon Canada in November 2017 at
Montreal in front of two core-devs of Python, Brett Cannon and Mariatta
Wijaya. Also reviewed by Victor Stinner core-dev python&lt;/p&gt;
&lt;p&gt;My talk has been shared on the python-dev mailing list by Victor
Stinner:
&lt;a class="reference external" href="https://mail.python.org/pipermail/python-dev/2017-December/151051.html"&gt;https://mail.python.org/pipermail/python-dev/2017-December/151051.html&lt;/a&gt;
because the statistics were interesting for the core-dev.&lt;/p&gt;
&lt;p&gt;Presentation at PyCon Canada 2017: &lt;a class="reference external" href="https://2017.pycon.ca/schedule/4/"&gt;https://2017.pycon.ca/schedule/4/&lt;/a&gt;
Slides:
&lt;a class="reference external" href="https://speakerdeck.com/matrixise/cpython-loves-your-pull-requests"&gt;https://speakerdeck.com/matrixise/cpython-loves-your-pull-requests&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;My experience, speaker at PyCon Canada 2015, 2016 and 2017 Python FOSDEM
2013, 2014, 2015 and 2017 PyCon Ireland 2015, 2016, and 2017 PyCon
France 2012, 2014, 2016, 2017 PyCon UK 2015 EuroPython 2015, 2016 and
2017. Montreal Python September 2015 and November 2017.&lt;/p&gt;
&lt;p&gt;Organizer of Python FOSDEM (+- 600 people) in Belgium Co-Organizer of
EuroPython 2015, 2016 and 2017 (as member of the Web workgroup).&lt;/p&gt;
&lt;p&gt;Fellow Member of the Python Software Foundation since 2013 Member of the
Fellow Workgroup for the PSF Member of the Marketing Workgroup for the
PSF&lt;/p&gt;
&lt;p&gt;Of course, contributor of CPython, mainly on Devguide and sometimes on
the main repository with some fixes, new features.&lt;/p&gt;
&lt;p&gt;For my contribution to the migration of Python.
&lt;a class="reference external" href="https://mail.python.org/pipermail/python-committers/2017-February/004220.html"&gt;https://mail.python.org/pipermail/python-committers/2017-February/004220.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Others presentations where I explain the interpreter and the bytecode of
Python &lt;a class="reference external" href="https://speakerdeck.com/matrixise/architecture-of-cpython-part-1"&gt;https://speakerdeck.com/matrixise/architecture-of-cpython-part-1&lt;/a&gt;
&lt;a class="reference external" href="https://speakerdeck.com/matrixise/exploring-our-python-interpreter"&gt;https://speakerdeck.com/matrixise/exploring-our-python-interpreter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;in __on &lt;strong&gt;sabato 21 aprile&lt;/strong&gt; at 17:45 &lt;a class="reference external" href="/p3/schedule/pycon9/"&gt;**See
schedule**&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</summary><category term="statistics"></category><category term="core-programming"></category><category term="CPython"></category><category term="community"></category><category term="github"></category><category term="git"></category></entry><entry><title>CPython loves your Pull Requests</title><link href="https://pyvideo.org/pycon-ca-2017/cpython-loves-your-pull-requests.html" rel="alternate"></link><published>2017-11-19T00:00:00+00:00</published><updated>2017-11-19T00:00:00+00:00</updated><author><name>SteÃÅphane Wirtel</name></author><id>tag:pyvideo.org,2017-11-19:pycon-ca-2017/cpython-loves-your-pull-requests.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;CPython, what's CPython. CPython is the official implementation of Python, written in C. And it's not just a implementation, it is a group of volunteers and where they daily work on the project but there is no many active contributors.&lt;/p&gt;
&lt;p&gt;In this talk, I would like to prove to you than you can become an active contributor of CPython.&lt;/p&gt;
&lt;p&gt;The core developers of CPython need your help, for example, with the review of some patches, you can comment a patch or try to reproduce a bug.&lt;/p&gt;
&lt;p&gt;In the past, when you wanted to contribute to CPython, you had to use the bug tracker interface and send a patch, this patch was reviewed if you were lucky and after commented etc.... but this process was really long and time consuming.&lt;/p&gt;
&lt;p&gt;Now with the new process based on GitHub and Git, you can create a new branch on your local repository and just send a Pull Request. The Pull Request is just awesome, we can comment it in just a few moments.&lt;/p&gt;
&lt;p&gt;We need your Pull Requests for CPython.&lt;/p&gt;
</summary><category term="cpython"></category></entry><entry><title>ByteCode al supporto dei test per protocolli ed enforcing di best practices</title><link href="https://pyvideo.org/pycon-italia-2017/bytecode-al-supporto-dei-test-per-protocolli-ed-enforcing-di-best-practices.html" rel="alternate"></link><published>2017-04-08T00:00:00+00:00</published><updated>2017-04-08T00:00:00+00:00</updated><author><name>Alessandro Molina</name></author><id>tag:pyvideo.org,2017-04-08:pycon-italia-2017/bytecode-al-supporto-dei-test-per-protocolli-ed-enforcing-di-best-practices.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python √® un linguaggio interpretato con efficaci strumenti di
introspezione, fino a permetterci di accedere al suo bytecode e vedere
cosa la virtual machine sta per eseguire. Per quanto questa esigenza sia
solitamente molto limitata in ambito di produzione ed uso del software
pu√≤ venirci utile all‚Äôinterno delle test suite per verificare che il
codice scritto da terzi o dal noi stessi del domani rispetti ancora dei
protocolli o delle best practices che avevamo presupposto.&lt;/p&gt;
&lt;p&gt;La maggior parte di queste esigenze possono essere soddisfatte anche
tramite l‚Äôuso di metaclassi o monkeypatching, ma in alcuni casi √®
possibile saltare i check preposti involontariamente (ad esempio
ereditando dalla classe sbagliata nel caso delle metaclassi), mentre la
verifica del byte code ci consente di controllare cosa effettivamente
sar√† eseguito, non cosa ci aspettiamo sia eseguito.&lt;/p&gt;
</summary><category term="quality-assurance"></category><category term="CPython"></category><category term="testing"></category><category term="robustness"></category><category term="static-typing"></category><category term="bytecode"></category><category term="hacking"></category><category term="compiler"></category></entry><entry><title>CPython, Grumpy, PyPy - When, How, Why</title><link href="https://pyvideo.org/pycon-israel-2017/cpython-grumpy-pypy-when-how-why.html" rel="alternate"></link><published>2017-06-12T00:00:00+00:00</published><updated>2017-06-12T00:00:00+00:00</updated><author><name>Itay Weiss</name></author><id>tag:pyvideo.org,2017-06-12:pycon-israel-2017/cpython-grumpy-pypy-when-how-why.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;I will talk about the differences between the three implementations. Focusing on use cases in which each of them should be used and how each environment tackles performance issues (GIL, just-in-time and Goroutines). I will also evaluate performance impact in real life scenario.&lt;/p&gt;
</summary><category term="cpython"></category><category term="grumpy"></category><category term="pypy"></category></entry><entry><title>Analyzing code contributions to the CPython project using NetworkX and Matplotlib</title><link href="https://pyvideo.org/pydata-barcelona-2017/analyzing-code-contributions-to-the-cpython-project-using-networkx-and-matplotlib.html" rel="alternate"></link><published>2017-05-20T15:00:00+02:00</published><updated>2017-05-20T15:00:00+02:00</updated><author><name>Jordi Torrents</name></author><id>tag:pyvideo.org,2017-05-20:pydata-barcelona-2017/analyzing-code-contributions-to-the-cpython-project-using-networkx-and-matplotlib.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;It's a well established fact that only a small fraction of developers account for most code contributions to FOSS projects. The CPython project is not an exception, but analyzing code contributions through time reveals that the people that contribute the most is not always the same. I model CPython's contribution dynamics as cooperation networks and analyze them using NetworkX and Matplotlib.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Abstract&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I analyze cooperation on the CPython project by analyzing the code contributions that each participant on the project has done through time. I model these contributions as a succession of bipartite networks where the bipartite node sets are contributors and source code files; each contributor is linked to the source files to which they have contributed, weighted by the number of lines of source code added. Analyzing the structure of these networks using NetworkX and Matplotlib I found an hierarchy of nested groups of developers that corresponds to the developers that do most of the code contributions in the CPython project. This hierarchy, on the one hand, reflects the empirically well established fact that in FOSS projects only a small fraction of the developers account for most of the contributions. And, on the other hand, refutes the naive views of early academic accounts that characterized FOSS projects as a flat hierarchy of peers in which every individual does more or less the same. I argue that the structure of CPython's cooperation network can be characterized as an open elite, where the top levels of this hierarchy are filled with new individuals at a high pace. This feature is key for understanding the mechanisms and dynamics that make FOSS communities able to develop long term projects, with high individual turnover, and yet achieve high impact and coherent results as a result of large scale cooperation.&lt;/p&gt;
&lt;p&gt;You can download the slides for this talk from &lt;a class="reference external" href="https://github.com/jtorrents/thesis/blob/master/presentations/pydata_bcn/cpython_code_contributions.pdf"&gt;https://github.com/jtorrents/thesis/blob/master/presentations/pydata_bcn/cpython_code_contributions.pdf&lt;/a&gt;&lt;/p&gt;
</summary><category term="cpython"></category><category term="networkx"></category><category term="matplotlib"></category></entry><entry><title>Don't Live Patch Your CPython Interpreter</title><link href="https://pyvideo.org/pydata-chicago-2016/dont-live-patch-your-cpython-interpreter.html" rel="alternate"></link><published>2016-08-27T00:00:00+00:00</published><updated>2016-08-27T00:00:00+00:00</updated><author><name>James Powell</name></author><id>tag:pyvideo.org,2016-08-27:pydata-chicago-2016/dont-live-patch-your-cpython-interpreter.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;PyData Chicago 2016&lt;/p&gt;
</summary><category term="CPython"></category><category term="interpreter"></category></entry><entry><title>Life of a Python program</title><link href="https://pyvideo.org/pycon-es-2015/life-of-a-python-program.html" rel="alternate"></link><published>2016-02-02T00:00:00+00:00</published><updated>2016-02-02T00:00:00+00:00</updated><author><name>Francisco Fern√°ndez Casta√±o</name></author><id>tag:pyvideo.org,2016-02-02:pycon-es-2015/life-of-a-python-program.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Sometimes is good to know what's happening under the hood,
this talk will explain how CPython works internally since
we type &lt;cite&gt;python myprogram.py&lt;/cite&gt; until our code is finally executed
explaining the process that CPython does to run our programs.&lt;/p&gt;
&lt;p&gt;The goal of this talk is explain people how to explore the code
of the interpreter itself using some common tools and let regular
Python developers that aren't used to work with C lose the fear
about looking under the hood.&lt;/p&gt;
</summary><category term="Track BaÃÅsico"></category><category term="CPython"></category></entry><entry><title>Lightning Talks Day 2</title><link href="https://pyvideo.org/djangocon-us-2009/djangocon-2009--lightning-talks-day-2.html" rel="alternate"></link><published>2009-09-09T00:00:00+00:00</published><updated>2009-09-09T00:00:00+00:00</updated><author><name>Alex Gaynor</name></author><id>tag:pyvideo.org,2009-09-09:djangocon-us-2009/djangocon-2009--lightning-talks-day-2.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Lightning Talks Day 2&lt;/p&gt;
&lt;p&gt;(00:09) Dive into CPython Bytecode - Alex Gaynor&lt;/p&gt;
&lt;p&gt;(05:10) Testing with pywatch - Chris Heisel&lt;/p&gt;
&lt;p&gt;(07:08) Pluggable Django E-Commerce - Aaron Cuker and someone else&lt;/p&gt;
&lt;p&gt;(12:13) Introduction to Surlex - Cody Soyland&lt;/p&gt;
</summary><category term="bytecode"></category><category term="cpython"></category><category term="djangocon"></category><category term="djangocon2009"></category><category term="pywatch"></category><category term="surlex"></category><category term="testing"></category></entry><entry><title>Emulating Stackless and greenlet with each other</title><link href="https://pyvideo.org/europython-2011/emulating-stackless-and-greenlet-with-each-other.html" rel="alternate"></link><published>2011-07-21T00:00:00+00:00</published><updated>2011-07-21T00:00:00+00:00</updated><author><name>P√©ter Szab√≥</name></author><id>tag:pyvideo.org,2011-07-21:europython-2011/emulating-stackless-and-greenlet-with-each-other.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Peter Szabo - 20 June 2011 in &amp;quot;Track Ravioli&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Stackless Python and the greenlet package for CPython are two different
implementations of coroutine support for Python. (Coroutines are
fundamental building blocks of I/O frameworks like gevent, Eventlet,
Concurrence and Syncless to conveniently handle thousands of socket
connections at a time without creating threads.) Stackless and greenlet
implement a different interface. However, each is powerful enough so
that it can be used to emulate the other one. In this talk we explore
the differences and discuss design decisions and testing strategies of
the emulations we have implemented.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://syncless.googlecode.com/svn/trunk/doc/slides_2011-06-20/pts_em%20u_coro_2011-06-20.html"&gt;Slides&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://syncless.googlecode.com/svn/trunk/doc/s%20lides_2010-11-29/pts_coro_2010-11-29.html"&gt;Slides for the bonus
sub-talk&lt;/a&gt;&lt;/p&gt;
</summary><category term="concurrence"></category><category term="cpython"></category><category term="design"></category><category term="greenlet"></category><category term="stackless"></category><category term="testing"></category></entry><entry><title>Exploring CPython's bytecode</title><link href="https://pyvideo.org/europython-2011/exploring-cpythons-bytecode.html" rel="alternate"></link><published>2011-07-21T00:00:00+00:00</published><updated>2011-07-21T00:00:00+00:00</updated><author><name>Floris Bruynooghe</name></author><id>tag:pyvideo.org,2011-07-21:europython-2011/exploring-cpythons-bytecode.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Floris Bruynooghe - 22 June 2011 in &amp;quot;Track Lasagne&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The CPython interpreter always compiles your source code to bytecode,
usually stored in .pyc files. This bytecode is then loaded and executed
in the CPython virtual machine.&lt;/p&gt;
&lt;p&gt;This talk will explore the bytecode from the outside in. Starting with
how to read a .pyc file, following the steps the interpreter takes to
arrive and a usable python module. It then dives into the structure of
the bytecode itself and the principles of the virtual machine, detailing
how the VM executes this bytecode to do useful work.&lt;/p&gt;
&lt;p&gt;Having seen all these details you should have a good idea of the various
innards of CPython and how to manipulate these to create weird,
wonderful, dangerous and occasional useful hacks.&lt;/p&gt;
</summary><category term="bytecode"></category><category term="cpython"></category><category term="vm"></category></entry><entry><title>PyPy hands-on</title><link href="https://pyvideo.org/europython-2011/pypy-hands-on.html" rel="alternate"></link><published>2011-07-21T00:00:00+00:00</published><updated>2011-07-21T00:00:00+00:00</updated><author><name>Antonio Cuni</name></author><id>tag:pyvideo.org,2011-07-21:europython-2011/pypy-hands-on.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Antonio Cuni,Armin Rigo - 21 June 2011 in &amp;quot;Training
Pizza Margherita&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The session is divided into two parts, of roughly 2 hours each. People
who are interested only in the first part, can leave the session after
it. However, the first part is a prerequisite for the second one, thus
people are not advised to join in the middle of the session.&lt;/p&gt;
&lt;p&gt;The session is meant to be highly interactive. People are invited to
bring their own laptop and try things by themselves.&lt;/p&gt;
&lt;div class="section" id="part-1-run-your-application-under-pypy"&gt;
&lt;h4&gt;Part 1: Run your application under PyPy&lt;/h4&gt;
&lt;p&gt;This tutorial is targeted to Python users who want to run their favorite
Python application under PyPy, and exploit the most of it. The following
topics will be covered:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
- how to fix/avoid CPython implementation details (e.g., refcounting)

- general overview of how the PyPy JIT works

- how to optimize your program for the PyPy JIT

- how to view and interpret the traces produced by the JIT

- how to tweak the parameters of the JIT and the GC

- how to use existing CPython C extensions on PyPy, and fix them if necessary
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="part-2-write-your-own-interpreter-with-pypy"&gt;
&lt;h4&gt;Part 2: Write your own interpreter with PyPy&lt;/h4&gt;
&lt;p&gt;PyPy is not only a Python interpreter, but also a toolchain to implement
dynamic languages. This tutorial is targeted to people who want to
implement their own programming languages, or who simply want to know
more about how the PyPy JIT works internally.&lt;/p&gt;
&lt;p&gt;The students will be given the source code for a toy language
implemented in RPython. They will learn:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
- how to translate it to C using the PyPy translation toolchain

- what are the &amp;quot;hints&amp;quot; needed by the JIT generator, and how to place them
&lt;/pre&gt;
&lt;p&gt;Then, they will be challenged to add the proper hints to the toy
interpreter, to get the best result with the JIT.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;THINGS TO DO BEFORE THE TRAINING&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You are encouraged to bring your laptop to the training session.&lt;/p&gt;
&lt;p&gt;Make sure that the following prerequisites are met:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Install PyPy 1.5:&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="http://pypy.org/download.html"&gt;http://pypy.org/download.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://doc.pypy.org/en/latest/getting-started.html#installing-pypy"&gt;http://doc.pypy.org/en/latest/getting-started.html#installing-pypy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Make sure that &lt;tt class="docutils literal"&gt;setuptools&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;distribute&lt;/tt&gt; are installed (look
at the URL above for instructions)&lt;/li&gt;
&lt;li&gt;Clone the pypy repository, and update to the 1.5 version:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$ hg clone &lt;a class="reference external" href="http://bitbucket.org/pypy/pypy"&gt;http://bitbucket.org/pypy/pypy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;$ cd pypy&lt;/p&gt;
&lt;p&gt;$ hg up -r release-1.5&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Clone the jitviewer repository and install it on pypy:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$ hg clone &lt;a class="reference external" href="http://bitbucket.org/pypy/jitviewer"&gt;http://bitbucket.org/pypy/jitviewer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;$ cd jitviewer&lt;/p&gt;
&lt;p&gt;$ /path/to/pypy-1.5/bin/pypy setup.py develop&lt;/p&gt;
&lt;p&gt;If you intend to follow also the second part (&amp;quot;Write your own
interpreter with PyPy&amp;quot;), you need to make sure you have a working
&lt;a class="reference external" href="http://doc.pypy.org/en/latest/getting-started-python.html%20#translating-the-pypy-python-interpreter"&gt;developing
environment&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</summary><category term="cd"></category><category term="cpython"></category><category term="extensions"></category><category term="hg"></category><category term="jit"></category><category term="optimize"></category><category term="pypy"></category><category term="setup.py"></category><category term="tutorial"></category></entry><entry><title>5 Years of Bad Ideas</title><link href="https://pyvideo.org/europython-2011/5-years-of-bad-ideas.html" rel="alternate"></link><published>2011-07-20T00:00:00+00:00</published><updated>2011-07-20T00:00:00+00:00</updated><author><name>Armin Ronacher</name></author><id>tag:pyvideo.org,2011-07-20:europython-2011/5-years-of-bad-ideas.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Armin Ronacher - 20 June 2011 in &amp;quot;Track Spaghetti&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;What was my motivation for working with Python after two years of PHP?
There is so much you can do. Functions are objects you can pass around,
you can decompile functions to see how they work internally, you can
alias a bound method to a global function and it will just work. You can
change import semantics, override the method resolution order, you can
write metaclasses, you can hook into the CPython interpreter API and
much more.&lt;/p&gt;
&lt;p&gt;Five years later I came to the conclusion that this is really not what
Python is about and that a lot of what I did was interesting but not
necessarily a good idea. This talk is a 45 minute recompilation of
things I really shouldn't have done in the first place. Expect a bunch
of neat and interesting hacks that showcase the possibilities of the
language.&lt;/p&gt;
</summary><category term="api"></category><category term="cpython"></category></entry><entry><title>Debugging and profiling techniques</title><link href="https://pyvideo.org/europython-2011/debugging-and-profiling-techniques.html" rel="alternate"></link><published>2011-07-20T00:00:00+00:00</published><updated>2011-07-20T00:00:00+00:00</updated><author><name>Giovanni Bajo</name></author><id>tag:pyvideo.org,2011-07-20:europython-2011/debugging-and-profiling-techniques.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Giovanni Bajo - 22 June 2011 in &amp;quot;Track Spaghetti&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;This talk will give on overview over some common problems related to
profiling and debugging CPython applications (especially desktop-based
ones).&lt;/p&gt;
&lt;p&gt;The following subjects will be covered:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Debugging of memory/resource leaks (circular references, &lt;strong&gt;del&lt;/strong&gt;,
weakref, garbage collector, etc.). We will show in details how the
memory management of Python objects work and we will show a few
tricks to track memory leaks&lt;/li&gt;
&lt;li&gt;Python code profiling (profile/hotshots/cProfile, design of small
tests, etc.). We will show how to measure, profile, and analyse an
application to spot performance problems and solve them.&lt;/li&gt;
&lt;li&gt;Post-mortem step-by-step debugging of C/C++ extension under Windows.
We will show how to setup Visual Studio for debugging, how to see a
traceback in case of an unexpected segfault, and how to further debug
and solve the crash.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This talk is aimed at intermediate Python programmers, who have already
developed non-trivial Python applications but have never &amp;quot;jumped
through&amp;quot; the interpreter abstraction layer. If you feel a little lost
when you see a segfault from a Python program or you don't have a clear
idea how memory is collected in Python, this talk is perfect for you.&lt;/p&gt;
</summary><category term="cpython"></category><category term="debugging"></category><category term="design"></category><category term="memory"></category><category term="performance"></category><category term="profiling"></category><category term="python,"></category></entry><entry><title>Making CPython Fast Using Trace-based Optimisations</title><link href="https://pyvideo.org/europython-2011/making-cpython-fast-using-trace-based-optimisatio.html" rel="alternate"></link><published>2011-07-13T00:00:00+00:00</published><updated>2011-07-13T00:00:00+00:00</updated><author><name>Mark Shannon</name></author><id>tag:pyvideo.org,2011-07-13:europython-2011/making-cpython-fast-using-trace-based-optimisatio.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Mark Shannon - 24 June 2011 in &amp;quot;Track Lasagne&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;CPython can be made faster by implementing the sort of optimizations
used in the PyPy VM, and in my HotPy VM. All the necessary changes can
be made without modifying the language or the API.&lt;/p&gt;
&lt;p&gt;The CPython VM can be modified to support optimizations by adding an
effective garbage collector and by separating the virtual-machine state
from the real- machine state (like Stackless).&lt;/p&gt;
&lt;p&gt;Optimizations can be implemented incrementally. Since almost all of the
optimizations are implemented in the interpreter, all hardware platforms
can benefit. JIT compiler(s) can then be added for common platforms
(intel, ARM, etc.).&lt;/p&gt;
&lt;p&gt;For more information see &lt;a class="reference external" href="http://hotpy.blogspot.com/"&gt;http://hotpy.blogspot.com/&lt;/a&gt;&lt;/p&gt;
</summary><category term="cpython"></category><category term="jit"></category><category term="pypy"></category><category term="vm"></category></entry><entry><title>PyPy in production</title><link href="https://pyvideo.org/europython-2011/pypy-in-production.html" rel="alternate"></link><published>2011-07-13T00:00:00+00:00</published><updated>2011-07-13T00:00:00+00:00</updated><author><name>Antonio Cuni</name></author><id>tag:pyvideo.org,2011-07-13:europython-2011/pypy-in-production.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Antonio Cuni,Armin Rigo - 23 June 2011 in &amp;quot;Track
Lasagne&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The PyPy project has recently gathered a lot of attention for its
progress in speeding up the Python language - it is the fastest Python
interpreter, and the most compatible and most stable 'alternative¬¥ one.
No longer merely a research project, PyPy is now suitable for production
use. We are working on improvements on calling into C libraries and
generally integrating with the existing Python extensions ecosystem.&lt;/p&gt;
&lt;p&gt;We will give an overview on how the tracing Just-in-Time compiler works
in PyPy. From there, we will then focus on what the PyPy project has
achieved, particularly in the past two years:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;most Python benchmarks run much faster than with CPython or Psyco&lt;/li&gt;
&lt;li&gt;the real-world PyPy compiler toolchain itself (200 KLocs) runs twice
as fast&lt;/li&gt;
&lt;li&gt;already supports 32 and 64bit x86 and is in the process of supporting
ARM&lt;/li&gt;
&lt;li&gt;full compatibility with CPython (more than Jython/IronPython)&lt;/li&gt;
&lt;li&gt;full (and JIT-ed) ctypes support to call C libraries from Python&lt;/li&gt;
&lt;li&gt;supports Stackless Python (in-progress)&lt;/li&gt;
&lt;li&gt;new &amp;quot;cpyext&amp;quot; layer which integrates existing CPython C extensions&lt;/li&gt;
&lt;li&gt;an experimental super-fast JIT-compilation of calls to C++ libraries&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We want to reserve time for discussing potential future work like SWIG
and/or Cython compatibility and other areas brought up by the audience.
There are many interesting details that can be explored further; we will
focus on the points the audience is most interested in.&lt;/p&gt;
&lt;p&gt;For more info:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://pypy.org/"&gt;http://pypy.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Our blog: &lt;a class="reference external" href="http://morepypy.blogspot.com/"&gt;http://morepypy.blogspot.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Eureka program: &lt;a class="reference external" href="http://www.eurostars-eureka.eu/"&gt;http://www.eurostars-eureka.eu/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Eurostars Eureka is our funding source since 2009. It is a
cross-European funding collaboration that targets small firms which
produce research.&lt;/em&gt;&lt;/p&gt;
</summary><category term="cpython"></category><category term="ctypes"></category><category term="cython"></category><category term="extensions"></category><category term="pypy"></category><category term="stackless"></category></entry><entry><title>Python MapReduce Programming with Pydoop</title><link href="https://pyvideo.org/europython-2011/python-mapreduce-programming-with-pydoop.html" rel="alternate"></link><published>2011-07-13T00:00:00+00:00</published><updated>2011-07-13T00:00:00+00:00</updated><author><name>Simone Leo</name></author><id>tag:pyvideo.org,2011-07-13:europython-2011/python-mapreduce-programming-with-pydoop.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Simone Leo - 24 June 2011 in &amp;quot;Track Lasagne&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Hadoop is the leading open source implementation of MapReduce, Google's
large scale distributed computing paradigm. Hadoop's native API is in
Java, and its built-in options for Python programming - Streaming and
Jython - have several drawbacks: the former allows to access only a
small subset of Hadoop's features, while the latter carries with it all
of the limitations of Jython with respect to CPython.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://pydoop.sourceforge.net"&gt;Pydoop&lt;/a&gt; is an API for Hadoop that
makes most of its features available to Python programmers while
allowing CPython development. Its core consists of Boost.Python wrappers
for Hadoop's C/C++ interface.&lt;/p&gt;
&lt;p&gt;The talk consists of a MapReduce/Hadoop tutorial and a presentation of
the Pydoop API, with the main goal of bridging the gap between the
Hadoop and Python communities. A basic knowledge of distributed
programming is helpful but not strictly required.&lt;/p&gt;
</summary><category term="api"></category><category term="cpython"></category><category term="distributed"></category><category term="hadoop"></category><category term="jython"></category><category term="mapreduce"></category><category term="tutorial"></category></entry><entry><title>The development process of Python</title><link href="https://pyvideo.org/europython-2011/the-development-process-of-python.html" rel="alternate"></link><published>2011-07-13T00:00:00+00:00</published><updated>2011-07-13T00:00:00+00:00</updated><author><name>Ezio Melotti</name></author><id>tag:pyvideo.org,2011-07-13:europython-2011/the-development-process-of-python.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Ezio Melotti - 24 June 2011 in &amp;quot;Track Ravioli &amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python is an open source language, where everyone can contribute, and
thanks to Mercurial now it's even easier. With this talk I want to
unveil what happens &amp;quot;behind the scenes&amp;quot; of CPython and how you can get
involved and be part of the open source community that allows Python to
be one of the most popular programming languages.&lt;/p&gt;
&lt;p&gt;I will explain:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;what is the workflow of the CPython development;&lt;/li&gt;
&lt;li&gt;how to get a clone of Python;&lt;/li&gt;
&lt;li&gt;how to use Mercurial to do all the most common operations;&lt;/li&gt;
&lt;li&gt;what is the structure of the main CPython repository;&lt;/li&gt;
&lt;li&gt;what other are repositories are used;&lt;/li&gt;
&lt;li&gt;how to use the bug tracker to report and find bugs;&lt;/li&gt;
&lt;li&gt;how to use remote Mercurial repos to contribute code;&lt;/li&gt;
&lt;li&gt;what tools are used;&lt;/li&gt;
&lt;li&gt;how to get in touch with the core developers;&lt;/li&gt;
&lt;li&gt;what are the plans for the future.&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="community"></category><category term="contribute"></category><category term="cpython"></category><category term="mercurial"></category><category term="workflow"></category></entry><entry><title>How Python Evolves (and How You Can Help Make It Happen)</title><link href="https://pyvideo.org/pycon-au-2011/how-python-evolves-and-how-you-can-help-make-it.html" rel="alternate"></link><published>2011-08-22T00:00:00+00:00</published><updated>2011-08-22T00:00:00+00:00</updated><author><name>Nick Coghlan</name></author><id>tag:pyvideo.org,2011-08-22:pycon-au-2011/how-python-evolves-and-how-you-can-help-make-it.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;The CPython reference interpreter lies at the heart of a much wider
Python ecosystem. The decisions that shape the future development of
CPython ripple out and have a broad impact on the entire Python
community. This talk covers the special place CPython occupies in the
broader Python community, how the decisions that affect CPython's
development are made, and how new developers can become involved in that
process..&lt;/p&gt;
</summary><category term="cpython"></category></entry><entry><title>State of CPython and Python Ecosystem</title><link href="https://pyvideo.org/pycon-au-2011/state-of-cpython-and-python-ecosystem.html" rel="alternate"></link><published>2011-08-22T00:00:00+00:00</published><updated>2011-08-22T00:00:00+00:00</updated><author><name>Senthil Kumaran</name></author><id>tag:pyvideo.org,2011-08-22:pycon-au-2011/state-of-cpython-and-python-ecosystem.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;This a high level overview of the State of CPython interpreter and other
python interpreters. The talk will mention about the
&amp;amp;nbsp_place_holder;changes in 3.2 release and changes coming up in 3.3
release and status of Python2.7. It will also give the details of
current state of PyPy Project, IronPython project and Jython Project..&lt;/p&gt;
</summary><category term="cpython"></category><category term="ironpython"></category><category term="jython"></category><category term="pypy"></category></entry><entry><title>Keynote: State of CPython</title><link href="https://pyvideo.org/pycon-us-2010/keynote-state-of-cpython.html" rel="alternate"></link><published>2010-02-19T00:00:00+00:00</published><updated>2010-02-19T00:00:00+00:00</updated><author><name>Guido van Rossum</name></author><id>tag:pyvideo.org,2010-02-19:pycon-us-2010/keynote-state-of-cpython.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Uses the Twitter feed for PyCon and a floor mic for a Q&amp;amp;A; session
covering the state of CPython and what's in the future.&lt;/p&gt;
</summary><category term="cpython"></category><category term="pycon"></category><category term="pycon2010"></category></entry><entry><title>Optimizations And Micro-Optimizations In CPython (#38)</title><link href="https://pyvideo.org/pycon-us-2010/pycon-2010--optimizations-and-micro-optimizations.html" rel="alternate"></link><published>2010-02-19T00:00:00+00:00</published><updated>2010-02-19T00:00:00+00:00</updated><author><name>Larry Hastings</name></author><id>tag:pyvideo.org,2010-02-19:pycon-us-2010/pycon-2010--optimizations-and-micro-optimizations.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Optimizations and Micro-Optimizations in CPython&lt;/p&gt;
&lt;p&gt;Presented by Mr. Larry Hastings&lt;/p&gt;
&lt;p&gt;CPython mostly gets faster from one version to the next. And when
CPython gets faster, your programs get faster. This talk is a survey of
optimizations made to CPython, recent and historical, large and small.
Audience doesn't need to be familiar with CPython internals, but should
be familiar with Python and conversant in C.&lt;/p&gt;
&lt;p&gt;[VIDEO HAS ISSUES: Audio interference]&lt;/p&gt;
</summary><category term="cpython"></category><category term="optimization"></category><category term="pycon"></category><category term="pycon2010"></category></entry><entry><title>Plenary: Friday Evening Lightning Talks</title><link href="https://pyvideo.org/pycon-us-2010/pycon-2010--plenary--friday-evening-lightning-tal.html" rel="alternate"></link><published>2010-02-19T00:00:00+00:00</published><updated>2010-02-19T00:00:00+00:00</updated><author><name>Jacob Kaplan-Moss</name></author><id>tag:pyvideo.org,2010-02-19:pycon-us-2010/pycon-2010--plenary--friday-evening-lightning-tal.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Plenary: Friday Evening Lightning Talks&lt;/p&gt;
&lt;p&gt;(00:00) Jacob Kaplan-Moss - lightning talk about lightning talks&lt;/p&gt;
&lt;p&gt;(03:50) Van Lindberg - What an Open Source Lawyer Actually Does&lt;/p&gt;
&lt;p&gt;(09:40) Greg Wilson - The Next Big Programming Book and How You Can Make
it Happen (&lt;a class="reference external" href="http://www.third-bit.com/"&gt;http://www.third-bit.com/&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;(14:25) Moshe Zadka - Don't Write Big Applications (more info
&lt;a class="reference external" href="http://moshez.wordpress.com/2010/02/17/dont-write-big-applications-a%20-lightning-talk/"&gt;here&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;(19:35) Ned Batchelder - What's new in coverage.py
(&lt;a class="reference external" href="http://nedbatchelder.com/"&gt;http://nedbatchelder.com/&lt;/a&gt;,
&lt;a class="reference external" href="http://nedbatchelder.com/code/coverage/"&gt;coverage.py&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;(25:10) Mike Maccana - Python Docx
(&lt;a class="reference external" href="http://github.com/mikemaccana/python-docx/"&gt;http://github.com/mikemaccana/python-
docx/&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;(29:25) Trent Mick - ActiveState Code v3/Python Cookbook v3
(&lt;a class="reference external" href="http://code.activestate.com/"&gt;http://code.activestate.com/&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;(34:40) Daniel Holth - Writing a SQLAlchemy Dialect&lt;/p&gt;
&lt;p&gt;(37:30) Dave Malcolm - Better Ways of Debugging the CPython Runtime&lt;/p&gt;
&lt;p&gt;(43:00) David Huggins-Daines - Recognizing Speech With Python
(&lt;a class="reference external" href="http://cmusphinx.sourceforge.net/"&gt;http://cmusphinx.sourceforge.net/&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;(48:00) Lucio Torre - Ubuntu One and Windows&lt;/p&gt;
</summary><category term="lightning talks"></category><category term="activestate"></category><category term="bigapps"></category><category term="cmusphinx"></category><category term="coverage.py"></category><category term="cpython"></category><category term="lawyers"></category><category term="programmingbook"></category><category term="pycon"></category><category term="pycon2010"></category><category term="python-cookbook"></category><category term="sqlalchemy"></category><category term="ubuntuone"></category></entry><entry><title>The Ring of Python (#189)</title><link href="https://pyvideo.org/pycon-us-2010/the-ring-of-python-189.html" rel="alternate"></link><published>2010-02-19T00:00:00+00:00</published><updated>2010-02-19T00:00:00+00:00</updated><author><name>Holger Krekel</name></author><id>tag:pyvideo.org,2010-02-19:pycon-us-2010/the-ring-of-python-189.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The Ring of Python&lt;/p&gt;
&lt;p&gt;Presented by holger krekel (merlinux gmbh)&lt;/p&gt;
&lt;p&gt;CPython 2.5/2.6/3.1, Jython, IronPython, PyPy, StacklessPython,
UnladenSwallow, Cython ... what do we make of all these cool interpreter
projects and versions? Where does competition help and where does it
hamper?&lt;/p&gt;
&lt;p&gt;In this interactive talk I'll highlight the main strengths of each of
the Python interpreters. Furthermore, I'll discuss ways to leverage
Python interpreters in a co-operative way, discuss challenges, projects
and issues ahead and also briefly highlight 'execnet', one my own
projects for bridging (Any) Python to (Any) Python. This is also the
first time i am going to try out a new and funvisual presentation
technique after several years of having done mostly text-based ones&lt;/p&gt;
</summary><category term="cpython"></category><category term="cython"></category><category term="ironpython"></category><category term="jython"></category><category term="pycon"></category><category term="pycon2010"></category><category term="pypy"></category><category term="stackless"></category><category term="unladenswallow"></category></entry><entry><title>Panel: Python VMs</title><link href="https://pyvideo.org/pycon-us-2011/panel-python-vms.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Brett Cannon</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/panel-python-vms.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Panel: Python VMs&lt;/p&gt;
&lt;p&gt;Presented by Jacob Kaplan-Moss, Brett Cannon, Maciej Fijalkowski, Frank
Wierzbicki, Dino Viehland&lt;/p&gt;
&lt;p&gt;Python is lucky enough to have a healthy ecosystem of virtual machines
(VMs) exist. CPython, Jython, IronPython, and PyPy are all used
extensively by people in real-world situations. This panel brings
together a representative from each of the major VMs to discuss where
they are now, going in the future, and to answer questions from the
community.&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;All four major Python VMs will be represented:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://python.org/"&gt;CPython&lt;/a&gt;: Brett Cannon&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.jython.org/"&gt;Jython&lt;/a&gt;: Frank Wierzbicki&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://ironpython.net/"&gt;IronPython&lt;/a&gt;: Dino Viehland&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://pypy.org/"&gt;PyPy&lt;/a&gt;: Maciej Fijalkowski Moderation will be
handled by Jacob Kaplan-Moss of Django.&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="cpython"></category><category term="ironpython"></category><category term="jython"></category><category term="pycon"></category><category term="pycon2011"></category><category term="pypy"></category></entry><entry><title>"Dude, Where's My RAM?" - A deep dive into how Python uses memory</title><link href="https://pyvideo.org/pycon-us-2011/pycon-2011---quot-dude--where--39-s-my-ram--quot-.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Dave Malcolm</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011---quot-dude--where--39-s-my-ram--quot-.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;&amp;quot;Dude, Where's My RAM?&amp;quot; - A deep dive into how Python uses memory&lt;/p&gt;
&lt;p&gt;Presented by Dave Malcolm&lt;/p&gt;
&lt;p&gt;This talk will give a deep dive into how CPython uses memory. I'll be
demonstrating a new tool I've written that analyses CPython's memory
usage, and offer hints and tips on how you can reduce the memory
footprint of your Python programs.&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;Is your Python program using too much memory? This talk will give a deep
dive into how CPython uses memory - starting from objects in your Python
code, down through the various implementations layers, eventually
reaching actual hardware.&lt;/p&gt;
&lt;p&gt;In particular, I'll be demonstrating a new tool I've written that can
track CPython's memory usage down to the level of individual bytes, and
offer hints and tips on how you can reduce the memory footprint of your
Python programs.&lt;/p&gt;
</summary><category term="cpython"></category><category term="memory"></category><category term="pycon"></category><category term="pycon2011"></category></entry><entry><title>API Design: Lessons Learned</title><link href="https://pyvideo.org/pycon-us-2011/pycon-2011--api-design--lessons-learned.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Raymond Hettinger</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--api-design--lessons-learned.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;API lessons learned from a decade of core Python development.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Share the lessons learned from a decade of core Python development, what
worked and what didn't. Look at the development process and thinking
behind some of Python's successful APIs and ones that leave something to
be desired. Learn general principles for designing a good API for public
consumption.&lt;/p&gt;
&lt;p&gt;Hear the story and principles behind the design of Python's &amp;quot;in&amp;quot;
operator, the development of deques, and the evolution of the set API.&lt;/p&gt;
&lt;p&gt;Examine the principles and story behind the development of the named
tuple API. Learn about unforeseen use cases and a bug that made it to
production.&lt;/p&gt;
&lt;p&gt;Discuss the decimal module's API challenge -- adhering to a published
standard. Talk about the Queue module's framework style and how the API
was refactored.&lt;/p&gt;
&lt;p&gt;Discuss what we've learned about naming functions and methods. Look at
the i-naming convention in itertools, camelcase oddities, the proposed
Italian name for enumerate, and vaguely named methods like
assertItemsEqual.&lt;/p&gt;
&lt;p&gt;Learn about Guido's ideas on when to add flags to method signatures.
Recap his thoughts on the problems with the percent formatting operator.
Then hear Raymond's advice on packaging, hierarchies, and nested name
spaces.&lt;/p&gt;
&lt;p&gt;See how to use documentation to mitigate API problems using examples
from regular expressions, decimal, tokenize, sorting.&lt;/p&gt;
</summary><category term="api"></category><category term="apidesign"></category><category term="cpython"></category><category term="pycon"></category><category term="pycon2011"></category></entry><entry><title>Friday Afternoon Lightning Talks</title><link href="https://pyvideo.org/pycon-us-2011/pycon-2011--friday-afternoon-lightning-talks.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Paul Smith</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--friday-afternoon-lightning-talks.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Friday afternoon lightning talks&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Friday afternoon lightning talks&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;00:00 Paul Smith - Raising money for Japan&lt;/li&gt;
&lt;li&gt;02:24 Jeff Daily - The Global Arrays Parallel Programming Toolkit&lt;/li&gt;
&lt;li&gt;08:30 Matt Harrison - My insecurity problem&lt;/li&gt;
&lt;li&gt;13:10 Pete Fein - Hacking for Freedom&lt;/li&gt;
&lt;li&gt;18:40 Robert Brewer - logging.statistics&lt;/li&gt;
&lt;li&gt;27:30 Nathan Nichols - Lessons Learned Writing DSLs for Automated
Content Generation&lt;/li&gt;
&lt;li&gt;33:15 Giles Thomas - Why Resolver switched from IronPython to CPython
japan, qtile, pyparsing, logging.statistics, resolver, cpython,
ironpython&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="lightning talks"></category><category term="cpython"></category><category term="ironpython"></category><category term="japan"></category><category term="logging.statistics"></category><category term="pycon"></category><category term="pycon2011"></category><category term="pyparsing"></category><category term="qtile"></category></entry><entry><title>The Development of Python and You</title><link href="https://pyvideo.org/pycon-us-2011/pycon-2011--the-development-of-python-and-you.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Brian Curtin</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--the-development-of-python-and-you.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The Development of Python and You&lt;/p&gt;
&lt;p&gt;Presented by Brian Curtin&lt;/p&gt;
&lt;p&gt;Have an inside look at what it takes to work on CPython, from getting
setup with the source and navigating the bug tracker, to the best
practices for having your work accepted. We'll find, categorize, and fix
an issue in Python to get you started. This talk is ideal for those who
are new to open source projects or are interested in the Python
development process.&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;People from all backgrounds, users of all platforms, and developers of
all levels are necessary in the development of Python. From writing code
to documentation, it takes all kinds of people to make an impact. If
you've used Python, we need you, and what better place to get involved
than at PyCon?&lt;/p&gt;
&lt;p&gt;2010 saw a rise in the number of contributors to CPython, and the PSF
stepped in to support the efforts of those wanting to get involved. Are
you up for the challenge? This talk dives right into what it takes to
get involved, covering the who, what, where, when, and why of Python
development, going through the whole process live.&lt;/p&gt;
&lt;p&gt;After the conference is over, stick around with the CPython crew and
hack away!&lt;/p&gt;
</summary><category term="coredev"></category><category term="cpython"></category><category term="development"></category><category term="gettinginvolved"></category><category term="pycon"></category><category term="pycon2011"></category></entry><entry><title>The Python That Wasn't</title><link href="https://pyvideo.org/pycon-us-2011/pycon-2011--the-python-that-wasn--39-t.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Larry Hastings</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--the-python-that-wasn--39-t.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The Python That Wasn't&lt;/p&gt;
&lt;p&gt;Presented by Larry Hastings&lt;/p&gt;
&lt;p&gt;One reason for Python's success is its restraint in adding new language
features. Only the most essential changes make it--and for every change
that gets accepted, many more are rejected. Come learn about proposed
changes to the Python language that failed--what, how, and why.&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Quick overview of the process&lt;ul&gt;
&lt;li&gt;First ten years: send GvR a patch&lt;/li&gt;
&lt;li&gt;The modern approach: python-ideas, write a PEP, produce a
reference implementation&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Discuss the &amp;quot;prickly&amp;quot; Python community&lt;ul&gt;
&lt;li&gt;This is a good thing! Only the best ideas survive the python-dev
gauntlet!&lt;/li&gt;
&lt;li&gt;They do this not because they're mean, but because they care so
much.&lt;/li&gt;
&lt;li&gt;We must have eternal vigilance to prevent unnecessary changes!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A survey of some changes that didn't make it&lt;ul&gt;
&lt;li&gt;The switch/case statement (PEP 3103)&lt;/li&gt;
&lt;li&gt;The &amp;quot;freeze protocol&amp;quot; (PEP 351)&lt;/li&gt;
&lt;li&gt;The &amp;quot;dynamic attribute access&amp;quot; proposal from python-dev, 2007/02&lt;/li&gt;
&lt;li&gt;Many more possibilities await in the rejected PEPs!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;My message to the audience&lt;ul&gt;
&lt;li&gt;Start with a post to python-ideas, please!&lt;/li&gt;
&lt;li&gt;Don't be surprised if you get a negative reaction&lt;/li&gt;
&lt;li&gt;Don't let your fear of a negative reaction stop you from trying,
necessarily&lt;/li&gt;
&lt;li&gt;Do your homework, and be your own worst critic&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="coredev"></category><category term="cpython"></category><category term="makingsausage"></category><category term="pycon"></category><category term="pycon2011"></category></entry></feed>