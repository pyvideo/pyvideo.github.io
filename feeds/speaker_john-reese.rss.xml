<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Sun, 04 Nov 2018 00:00:00 +0000</lastBuildDate><item><title>Refactoring Code with the Standard Library</title><link>https://pyvideo.org/north-bay-python-2018/refactoring-code-with-the-standard-library.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;What if you could refactor your entire code base, safely and
automatically? How much old code could you fix or replace if you didn't
worry about updating every reference by hand? I'll show you how a
concrete syntax tree (CST) can help you do just that using only the
standard Python library.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">John Reese</dc:creator><pubDate>Sun, 04 Nov 2018 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2018-11-04:north-bay-python-2018/refactoring-code-with-the-standard-library.html</guid></item><item><title>Refactoring Code With the Standard Library</title><link>https://pyvideo.org/pycon-au-2018/refactoring-code-with-the-standard-library.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;What if you could refactor your entire code base, safely and automatically? How much old code could you fix or replace if you didn't need to worry about updating every reference by hand? I'll show you how a concrete syntax tree (CST) can help you do just that using only the standard Python library.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">John Reese</dc:creator><pubDate>Sat, 25 Aug 2018 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2018-08-25:pycon-au-2018/refactoring-code-with-the-standard-library.html</guid></item><item><title>Thinking Outside the GIL with AsyncIO and Multiprocessing</title><link>https://pyvideo.org/pycon-us-2018/thinking-outside-the-gil-with-asyncio-and-multiprocessing.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Have you ever written a small, elegant application that couldn't keep up with the growth of your data or user demand? Did your beautiful design end up buried in threads and locks? Did Python's very special Global Interpreter Lock make all of this an exercise in futility?&lt;/p&gt;
&lt;p&gt;This talk is for you! With the combined powers of AsyncIO and multiprocessing, we'll redesign an old multithreaded application limited by the GIL into a modern solution that scales with the demand using only the standard library. No prior AsyncIO or multiprocessing experience required.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">John Reese</dc:creator><pubDate>Fri, 11 May 2018 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2018-05-11:pycon-us-2018/thinking-outside-the-gil-with-asyncio-and-multiprocessing.html</guid><category>asyncio</category><category>multiprocessing</category></item></channel></rss>