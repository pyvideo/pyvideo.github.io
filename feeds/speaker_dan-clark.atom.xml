<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_dan-clark.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2018-10-05T00:00:00+00:00</updated><entry><title>Database Testing with pytest</title><link href="https://pyvideo.org/pygotham-2018/database-testing-with-pytest.html" rel="alternate"></link><published>2018-10-05T00:00:00+00:00</published><updated>2018-10-05T00:00:00+00:00</updated><author><name>Dan Clark</name></author><id>tag:pyvideo.org,2018-10-05:pygotham-2018/database-testing-with-pytest.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Options for testing relational databases aren't as renown as what's available for application testing. We've all heard of unittest and pytest, but testing database objects are sometimes forgotten about, or tested through the application. However, pytestâ€™s flexibility along with Python's rich library of modules means that we can accomplish database testing in a way familar to Python developers.&lt;/p&gt;
&lt;p&gt;We'll be exploring how to use PyTest to create a suite of tests for database objects. This will include setting up our testing environment, populating conftest.py with our fixtures, and using transactions to our advantage. As we'll be testing against a real live Microsoft SQL Server database, we'll see how to use pyodbc to set up a connection to it. Then we'll dive into a few tests to show how we can gain confidence in our DB functions and stored procedures. Of course there are alternative ways to do this, and I'll share a few of them along with the benefits and drawbacks of using pytest.&lt;/p&gt;
&lt;p&gt;If time allows we'll show an Postgres equivalent to illustrate that this approach is not limited to a single product.&lt;/p&gt;
</summary></entry></feed>