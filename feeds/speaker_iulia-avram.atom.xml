<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org - Iulia Avram</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_iulia-avram.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2020-09-25T00:00:00+00:00</updated><subtitle></subtitle><entry><title>The 101 guide to deploying Django</title><link href="https://pyvideo.org/django-day-copenhagen-2020/the-101-guide-to-deploying-django.html" rel="alternate"></link><published>2020-09-25T00:00:00+00:00</published><updated>2020-09-25T00:00:00+00:00</updated><author><name>Iulia Avram</name></author><id>tag:pyvideo.org,2020-09-25:/django-day-copenhagen-2020/the-101-guide-to-deploying-django.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;What are some good practices? Can I make a checklist to help me through the process? Which web integration interface could I use? What are some common issues that come with each choice? How to debug my Django app inside the container? Could ASGI be the hero in a …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;What are some good practices? Can I make a checklist to help me through the process? Which web integration interface could I use? What are some common issues that come with each choice? How to debug my Django app inside the container? Could ASGI be the hero in a cape?&lt;/p&gt;
&lt;p&gt;Django Day Copenhagen 2020&lt;/p&gt;
</content><category term="Django Day Copenhagen 2020"></category><category term="Django"></category><category term="DjangoDayCopenhagen"></category><category term="DjangoDayCopenhagen2020"></category></entry><entry><title>Does this run in linear time? A case for algorithmics</title><link href="https://pyvideo.org/djangocon-europe-2019/does-this-run-in-linear-time-a-case-for-algorithmics.html" rel="alternate"></link><published>2019-04-21T00:00:00+00:00</published><updated>2019-04-21T00:00:00+00:00</updated><author><name>Iulia Avram</name></author><id>tag:pyvideo.org,2019-04-21:/djangocon-europe-2019/does-this-run-in-linear-time-a-case-for-algorithmics.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Algorithms are fun to learn and their usefulness goes beyond getting that good grade or acing a coding interview. This talk aims to showcase some the hidden benefits of keeping your algorithmic skills sharp, as well as the speaker’s personal recommendations in keeping up the good work without …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Algorithms are fun to learn and their usefulness goes beyond getting that good grade or acing a coding interview. This talk aims to showcase some the hidden benefits of keeping your algorithmic skills sharp, as well as the speaker’s personal recommendations in keeping up the good work without feeling like studying for an exam.
How many sorting methods can you name out of your head? What is greedy? If these terms sound familiar, you’ve probably heard of algorithmics. For the everyday developer, algorithms are either the scare of all the technical interviews, or that one course you took in university which they vaguely remember. It seems that if you’re not working for one of the big companies, you will never use them. So you might ask yourself: Why do I need to know about linear time when the libraries I’m using already optimise for this?
While you might not implement binary search in that new feature you’re working on, or use dynamic programming, diving a bit deeper into this world could prove useful in training your mind to see patterns you might have a harder time seeing otherwise, or to write code that is better optimised and will give the end users a better experience. I am going to try to dispel some of the myths surrounding the study of algorithms and competitive programming, and argue that sharpening this skill is something that benefits us, as software developers, outside of passing technical tests.&lt;/p&gt;
</content><category term="DjangoCon Europe 2019"></category></entry><entry><title>Gamifying the study of algorithms</title><link href="https://pyvideo.org/europython-2019/gamifying-the-study-of-algorithms.html" rel="alternate"></link><published>2019-07-11T00:00:00+00:00</published><updated>2019-07-11T00:00:00+00:00</updated><author><name>Iulia Avram</name></author><id>tag:pyvideo.org,2019-07-11:/europython-2019/gamifying-the-study-of-algorithms.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Do you remember when you used to learn algorithms? It was probably
either back when you were studying for your degree, or when you were
brushing up for a technical interview. If you're like most of the
developers I know, solving algorithms probably went from being a fun
past-time …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Do you remember when you used to learn algorithms? It was probably
either back when you were studying for your degree, or when you were
brushing up for a technical interview. If you're like most of the
developers I know, solving algorithms probably went from being a fun
past-time, to a bothersome necessity, to a thing of the past. Our life
has been greatly improved by our tools and there's little need to know
all sorting methods out there, or how to search through a tree. Or maybe
we're wrong, maybe knowing these things could make a difference in how
we write code.&lt;/p&gt;
&lt;p&gt;I am going to try to dispel some of the myths surrounding the study of
algorithms and competitive programming, and argue that sharpening this
skill is something that benefits us, as software developers, outside of
passing technical tests; that knowing many algorithms makes us better
and faster problem solvers.&lt;/p&gt;
&lt;p&gt;Lastly, this talk is about resources and ways in which to gamify the
study of algorithms. Going at it the same way as for exams or interviews
makes it very bothersome very quickly. It gets easy to lose sight of the
biggest picture and to start thinking of algorithms in abstract terms,
outside their applications. All these are factors that prompt the
question: why should I carry on with it?&lt;/p&gt;
&lt;p&gt;Therefore, something needs to be changed in the way we do this.
Algorithms are fun and they don't deserve the disdain we give them.
Knowing algorithms is not only for the geniuses and innovators.&lt;/p&gt;
</content><category term="EuroPython 2019"></category><category term="Algorithms"></category><category term="Best Practice"></category><category term="Education"></category><category term="Fun and Humor"></category></entry></feed>