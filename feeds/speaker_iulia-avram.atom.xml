<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_iulia-avram.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2019-07-11T00:00:00+00:00</updated><entry><title>Gamifying the study of algorithms</title><link href="https://pyvideo.org/europython-2019/gamifying-the-study-of-algorithms.html" rel="alternate"></link><published>2019-07-11T00:00:00+00:00</published><updated>2019-07-11T00:00:00+00:00</updated><author><name>Iulia Avram</name></author><id>tag:pyvideo.org,2019-07-11:europython-2019/gamifying-the-study-of-algorithms.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Do you remember when you used to learn algorithms? It was probably
either back when you were studying for your degree, or when you were
brushing up for a technical interview. If you're like most of the
developers I know, solving algorithms probably went from being a fun
past-time, to a bothersome necessity, to a thing of the past. Our life
has been greatly improved by our tools and there's little need to know
all sorting methods out there, or how to search through a tree. Or maybe
we're wrong, maybe knowing these things could make a difference in how
we write code.&lt;/p&gt;
&lt;p&gt;I am going to try to dispel some of the myths surrounding the study of
algorithms and competitive programming, and argue that sharpening this
skill is something that benefits us, as software developers, outside of
passing technical tests; that knowing many algorithms makes us better
and faster problem solvers.&lt;/p&gt;
&lt;p&gt;Lastly, this talk is about resources and ways in which to gamify the
study of algorithms. Going at it the same way as for exams or interviews
makes it very bothersome very quickly. It gets easy to lose sight of the
biggest picture and to start thinking of algorithms in abstract terms,
outside their applications. All these are factors that prompt the
question: why should I carry on with it?&lt;/p&gt;
&lt;p&gt;Therefore, something needs to be changed in the way we do this.
Algorithms are fun and they don't deserve the disdain we give them.
Knowing algorithms is not only for the geniuses and innovators.&lt;/p&gt;
</summary><category term="Algorithms"></category><category term="Best Practice"></category><category term="Education"></category><category term="Fun and Humor"></category></entry><entry><title>Does this run in linear time? A case for algorithmics</title><link href="https://pyvideo.org/djangocon-europe-2019/does-this-run-in-linear-time-a-case-for-algorithmics.html" rel="alternate"></link><published>2019-04-21T00:00:00+00:00</published><updated>2019-04-21T00:00:00+00:00</updated><author><name>Iulia Avram</name></author><id>tag:pyvideo.org,2019-04-21:djangocon-europe-2019/does-this-run-in-linear-time-a-case-for-algorithmics.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Algorithms are fun to learn and their usefulness goes beyond getting that good grade or acing a coding interview. This talk aims to showcase some the hidden benefits of keeping your algorithmic skills sharp, as well as the speaker’s personal recommendations in keeping up the good work without feeling like studying for an exam.
How many sorting methods can you name out of your head? What is greedy? If these terms sound familiar, you’ve probably heard of algorithmics. For the everyday developer, algorithms are either the scare of all the technical interviews, or that one course you took in university which they vaguely remember. It seems that if you’re not working for one of the big companies, you will never use them. So you might ask yourself: Why do I need to know about linear time when the libraries I’m using already optimise for this?
While you might not implement binary search in that new feature you’re working on, or use dynamic programming, diving a bit deeper into this world could prove useful in training your mind to see patterns you might have a harder time seeing otherwise, or to write code that is better optimised and will give the end users a better experience. I am going to try to dispel some of the myths surrounding the study of algorithms and competitive programming, and argue that sharpening this skill is something that benefits us, as software developers, outside of passing technical tests.&lt;/p&gt;
</summary></entry></feed>