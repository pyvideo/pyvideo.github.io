<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_regina-compton.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2019-07-28T12:45:00+00:00</updated><entry><title>Leave Your Inhibitions at the Database Connection</title><link href="https://pyvideo.org/pyohio-2019/leave-your-inhibitions-at-the-database-connection.html" rel="alternate"></link><published>2019-07-28T12:45:00+00:00</published><updated>2019-07-28T12:45:00+00:00</updated><author><name>Regina Compton</name></author><id>tag:pyvideo.org,2019-07-28:pyohio-2019/leave-your-inhibitions-at-the-database-connection.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;It is easy to cling to the familiar to avoid the unknown – even when
unfamiliar approaches better serve your work. My talk explores this
fact, specifically, by looking at the technical and emotional dimensions
of my less- than-easy journey from writing raw SQL to using the Django
ORM.&lt;/p&gt;
&lt;div class="section" id="abstract"&gt;
&lt;h4&gt;Abstract&lt;/h4&gt;
&lt;p&gt;Reconciling old assumptions with new approaches can be difficult. This
reconciliation can be especially difficult, when those assumptions and
approaches correspond with one’s emerging professional identity. A
musicologist turned developer, a Rubyist turned Pythonist, I know well
how intrapersonal tensions can shape (or hinder) approaches to writing
code. This talk confronts these tensions by describing the technical and
emotional dimensions of my less-than-easy journey from SQL to the Django
ORM.&lt;/p&gt;
&lt;p&gt;Django supports two basic approaches to interacting with a database: (1)
running queries with the Django database-mapper (more commonly described
as the “ORM”), and (2) performing raw SQL. My first Django projects
display a strong preference for the latter approach. I came to Django
with very limited coding experience. I started my job at a Python shop
as a freshly minted grad of Dev Bootcamp, where I had acquired some
knowledge of Ruby on Rails and its ORM, but also learned about the
possibilities and easeful-ness of SQL. I eschewed the Django ORM, in
part because of its seeming unknowableness, but mainly because SQL was a
familiar face in an unfamiliar land. In Django, I wrote SQL for simple
queries (selecting with a WHERE clause), moderately challenging ones
(joining multiple tables + ordering with CASE expressions), and
obscenely complex ones (subqueries + aggregate functions + string
manipulations). Whatever case, I generally found my queries to be
transparent, flexible, and friendly.&lt;/p&gt;
&lt;p&gt;It took over a year for me to appreciate that the Django ORM does clever
and astonishing things. I eventually found joy in annotating querysets
with derived values, and I stood in awe of the Prefetch object in
elaborate prefetch operations. The ORM, I learned, could produce clean
code and also bypass the performance loss that comes with transforming
SQL results into more amenable data types (e.g., namedtuple).&lt;/p&gt;
&lt;p&gt;In this talk, I will share some lessons in Django. But also, I will
suggest strategies for evaluating solid, familiar approaches and
replacing them with alternative ones.&lt;/p&gt;
&lt;/div&gt;
</summary></entry></feed>