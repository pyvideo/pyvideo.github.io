<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_hrafn-eiriksson.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2018-07-25T00:00:00+00:00</updated><entry><title>Asyncio in production</title><link href="https://pyvideo.org/europython-2018/asyncio-in-production.html" rel="alternate"></link><published>2018-07-25T00:00:00+00:00</published><updated>2018-07-25T00:00:00+00:00</updated><author><name>Hrafn Eiriksson</name></author><id>tag:pyvideo.org,2018-07-25:europython-2018/asyncio-in-production.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Much has been written about asynchronous programming in Python,
especially after the introduction of asyncio into the standard library
of the language. We’ve all seen the benchmarks that tell us how
asyncio-powered web servers massively outperform their non-asyncio
counterparts for trivial routes and we’ve seen the articles that tell us
how to make the move from flask to aiohttp and why we should.&lt;/p&gt;
&lt;p&gt;Despite all of this, the question remains: How is it to use asyncio in a
production setting? What are the pain points of migrating a large
application to use asyncio? How does the performance of this real-world
application differ after the migration? Is it still just unicorns and
fairy tales? The goal of this talk is to address these questions.&lt;/p&gt;
&lt;p&gt;If you are curious about taking the step from asyncio-dabbling to
creating actual mission critical software systems in asyncio; this is
the talk for you!&lt;/p&gt;
</summary></entry></feed>