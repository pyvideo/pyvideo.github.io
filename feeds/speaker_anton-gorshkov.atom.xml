<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_anton-gorshkov.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2017-07-14T00:00:00+00:00</updated><entry><title>Composable Multiprocessing and Multithreading for Numeric Libraries</title><link href="https://pyvideo.org/scipy-2017/composable-multiprocessing-and-multithreading-for-numeric-libraries.html" rel="alternate"></link><published>2017-07-14T00:00:00+00:00</published><updated>2017-07-14T00:00:00+00:00</updated><author><name>Anton Malakhov</name></author><id>tag:pyvideo.org,2017-07-14:scipy-2017/composable-multiprocessing-and-multithreading-for-numeric-libraries.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Among numeric communities Python is popular because of its easy to use number crunching modules like Numpy, Scipy, Tensor Flow, Theano, Dask, and Numba – to name but a few. These modules often use parallel processing in order to exploit all of the resources of multi-core processors efficiently. However, when used together in the same application, or in an application which exposes parallelism itself, these Python modules can interfere with each other by requesting too many worker threads. That leads to inefficiency or even causes failure of the code due to resource exhaustion. Last year, the Intel® Threading Building Blocks (Intel® TBB) module for Python introduced a new approach to tackle these issues. However, It is limited to a single process and packages which can switch to using the Intel® TBB library for multi-threading (e.g. Numpy, Dask, Joblib, and Numba). In this work, we address both limitations in the existing approach by introducing a way to compose parallelism implemented with OpenMP* runtime and to support multiprocessing coordination for both Intel® TBB and OpenMP threading runtimes.&lt;/p&gt;
</summary></entry></feed>