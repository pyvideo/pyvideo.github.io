<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_alice-harpole.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2017-10-26T11:30:00+01:00</updated><entry><title>Building a python frontend for HPC codes</title><link href="https://pyvideo.org/pycon-uk-2017/building-a-python-frontend-for-hpc-codes.html" rel="alternate"></link><published>2017-10-26T11:30:00+01:00</published><updated>2017-10-26T11:30:00+01:00</updated><author><name>Alice Harpole</name></author><id>tag:pyvideo.org,2017-10-26:pycon-uk-2017/building-a-python-frontend-for-hpc-codes.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;HPC (high performance computing) codes are widely used in computational science, however they are often difficult to manage, with complex build processes, reliance on multiple input and parameter files and intricate data processing routines to visualise the results. Typical approaches to automating this often involve shell scripts to try and link these different stages together, however these can also end up being quite complex and unreadable, particularly for less experienced users.&lt;/p&gt;
&lt;p&gt;I shall present my experience building a python interface for the AMReX Astro codes, a family of codes for AMR (adaptive mesh refinement) modelling of astrophysical systems. I shall look at how I used python to manage the compilation process, create input data, submit supercomputer jobs and visualise the output.&lt;/p&gt;
</summary></entry><entry><title>Testing the unknown: how to test scientific codes</title><link href="https://pyvideo.org/euroscipy-2017/testing-the-unknown-how-to-test-scientific-codes.html" rel="alternate"></link><published>2017-08-31T00:00:00+00:00</published><updated>2017-08-31T00:00:00+00:00</updated><author><name>Alice Harpole</name></author><id>tag:pyvideo.org,2017-08-31:euroscipy-2017/testing-the-unknown-how-to-test-scientific-codes.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In the experimental sciences, new theories are developed by applying the scientific method to produce results which are accurate, reproducible and reliable. This involves testing the experimental setup to show that it is working as designed and thoroughly documenting the progress of the experiment. Results will not be trusted unless the experiment has been carried out to a suitable standard.&lt;/p&gt;
&lt;p&gt;In computational science, we should aim to apply the same principles. Results should only be trusted if the code that has produced it has undergone rigorous testing which demonstrates that it is working as intended, and any limitations of the code (e.g. numerical errors) are understood and quantified.&lt;/p&gt;
&lt;p&gt;Unfortunately, this can be quite challenging. By their very nature, scientific codes are built to investigate systems where the behaviour is to some extent unknown, so testing them can be quite difficult. They can be very complex, built over a number of years (or even decades!) with contributions from many people.&lt;/p&gt;
&lt;p&gt;In this talk, I shall look at how to design tests for scientific codes, showing that even for the most complicated of codes, there are a number of different tests we can apply to ensure we build robust, reliable code.&lt;/p&gt;
</summary></entry><entry><title>Community teaching practices</title><link href="https://pyvideo.org/europython-2017/community-teaching-practices.html" rel="alternate"></link><published>2017-07-13T00:00:00+00:00</published><updated>2017-07-13T00:00:00+00:00</updated><author><name>Alice Harpole</name></author><id>tag:pyvideo.org,2017-07-13:europython-2017/community-teaching-practices.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In the last five years we saw many groups dedicated to teach people
how to program but any volunteer that is going to start a new teaching
group could have hundreds of questions related with concepts order,
examples, exercises, libraries and text editor/IDE. Panellists will
share their experience when teaching Python to newcomers from different
backgrounds as part of their volunteer work for some organisations such
as PyLadies, DjangoGirls, Code for Life, Software Carpentry,
Data Carpentry, etc. Among the panellists we will have&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Mateusz Kuzak, from the Netherlands eScience Center and volunteer for Software Carpentry and Data Carpentry;&lt;/li&gt;
&lt;li&gt;Alice Harpole, from the University of Southampton;&lt;/li&gt;
&lt;li&gt;Celine Boudier, from Code for Life;&lt;/li&gt;
&lt;li&gt;Raniere Silva (as moderator), from the Software Sustainability Institute.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All questions from the audience are welcomed.&lt;/p&gt;
</summary></entry><entry><title>Sustainable Scientific Software Development</title><link href="https://pyvideo.org/europython-2017/sustainable-scientific-software-development.html" rel="alternate"></link><published>2017-07-12T00:00:00+00:00</published><updated>2017-07-12T00:00:00+00:00</updated><author><name>Alice Harpole</name></author><id>tag:pyvideo.org,2017-07-12:europython-2017/sustainable-scientific-software-development.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;In the experimental Sciences, new theories are developed by applying
the Scientific method to produce results which are accurate,
reproducible and reliable. This involves testing the experimental
setup to show that it is working as designed and thoroughly documenting
the progress of the experiment. Results will not be trusted unless the
experiment has been carried out to a suitable standard.&lt;/p&gt;
&lt;p&gt;In computational Science, we should aim to apply the same principles.
Results should only be trusted if the code that has produced it has
undergone rigorous testing which demonstrates that it is working as
intended, and any limitations of the code (e.g. numerical errors)
are understood and quantified. The code should be well documented
so that others can understand how it works and run it themselves to
replicate results.&lt;/p&gt;
&lt;p&gt;Unfortunately, this can be quite challenging. By their very nature,
scientific codes are built to investigate systems where the behaviour
is to some extent unknown, so testing them can be quite difficult.
They can be very complex, built over a number of years (or even decades!)
with contributions from many people. However, even for the most complicated
of codes there are a number of different tools we can use to build robust,
reliable code.&lt;/p&gt;
&lt;p&gt;In this talk, I shall look at techniques and tools you can use to build
more sustainable scientific code, including testing, continuous integration and documentation.&lt;/p&gt;
</summary></entry></feed>