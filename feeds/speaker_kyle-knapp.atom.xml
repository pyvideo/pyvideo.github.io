<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_kyle-knapp.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2018-10-05T00:00:00+00:00</updated><entry><title>Automating Code Quality: Next Level</title><link href="https://pyvideo.org/pygotham-2018/automating-code-quality-next-level.html" rel="alternate"></link><published>2018-10-05T00:00:00+00:00</published><updated>2018-10-05T00:00:00+00:00</updated><author><name>Kyle Knapp</name></author><id>tag:pyvideo.org,2018-10-05:pygotham-2018/automating-code-quality-next-level.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Checking Python code quality by hand can be both tough and tedious. Fortunately, there exist many code quality tools that let you offload these quality checks to a machine. You are likely familiar with many of the popular tools such as &lt;cite&gt;flake8&lt;/cite&gt;, &lt;cite&gt;pylint&lt;/cite&gt;, and &lt;cite&gt;coverage&lt;/cite&gt;. And that’s good! These tools will catch many different code quality issues such as: not following Python standards, code smells, and potential bugs. However, these basic tools won’t catch all potential code quality issues that you care about.  For example, you may want to catch code standard issues outside of PEP 8, bugs related to incorrect type assumptions, and invalid documentation examples. So, does that mean you sit idly by and continue to catch these issues by hand? Of course not! You find ways to offload the quality checks onto a machine because it will be faster, more accurate, and more consistent than you.&lt;/p&gt;
&lt;p&gt;Building on previous talks about automating code quality, I will be diving into the more advanced types of quality checks that you can use (or even write yourself!) to further automate your development workflow. Using examples from real-world open source projects, you will learn about:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Usage of more advanced, lesser-known quality checkers such as &lt;cite&gt;mypy&lt;/cite&gt;&lt;/li&gt;
&lt;li&gt;Writing custom checkers for existing code quality tools such as &lt;cite&gt;pylint&lt;/cite&gt; and &lt;cite&gt;flake8&lt;/cite&gt;&lt;/li&gt;
&lt;li&gt;Using and writing checkers for documentation quality tools&lt;/li&gt;
&lt;/ul&gt;
</summary></entry><entry><title>Automating Code Quality</title><link href="https://pyvideo.org/pycon-us-2018/automating-code-quality.html" rel="alternate"></link><published>2018-05-13T00:00:00+00:00</published><updated>2018-05-13T00:00:00+00:00</updated><author><name>Kyle Knapp</name></author><id>tag:pyvideo.org,2018-05-13:pycon-us-2018/automating-code-quality.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Writing quality Python code can be both tough and tedious. On top of the general design, there are many code quality aspects that you need to watch out for when writing and reviewing code such as adherence to PEP8, docstring quality, test quality, etc. Furthermore, everyone is human. If you are catching these code quality issues by hand, there is a good chance that at some point you will miss an easy opportunity to improve code quality. If the quality check can be done by a machine, then why would you even try to catch the code quality issue by hand? In the end, the machine will be able to perform the quality check with much more speed, accuracy, and consistency than a person.&lt;/p&gt;
&lt;p&gt;This talk will dive into how existing open source projects offload and automate many of these code quality checks resulting in:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;A higher quality and a more consistent codebase&lt;/li&gt;
&lt;li&gt;Maintainers being able to focus more on the higher level design and interfaces of a project.&lt;/li&gt;
&lt;li&gt;An improved contribution process and higher quality pull requests from external contributors&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By diving into how these open source projects automate code quality checks, you will learn about:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The available tooling related to checking code quality such as &lt;cite&gt;flake8&lt;/cite&gt;, &lt;cite&gt;pylint&lt;/cite&gt;, &lt;cite&gt;coverage&lt;/cite&gt;, etc.&lt;/li&gt;
&lt;li&gt;How to automate code quality checks for both a development and team setting.&lt;/li&gt;
&lt;li&gt;First-hand accounts of the benefits and lessons learned from automating code quality checks in real-life open source projects.&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="code quality"></category><category term="flake8"></category><category term="pylint"></category><category term="coverage"></category></entry><entry><title>Serverless Applications with Chalice</title><link href="https://pyvideo.org/europython-2017/serverless-applications-with-chalice.html" rel="alternate"></link><published>2017-07-11T00:00:00+00:00</published><updated>2017-07-11T00:00:00+00:00</updated><author><name>Kyle Knapp</name></author><id>tag:pyvideo.org,2017-07-11:europython-2017/serverless-applications-with-chalice.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Serverless computing: it is the practice of building and running
services and applications without having to worry about provisioning
and managing servers. Serverless computing has been a popular topic
the past couple years, and with respect to Python, there have been
various different frameworks and tools released for developing and
managing your Python serverless applications. This talk will focus on
developing and managing your serverless applications with chalice
(&lt;a class="reference external" href="https://github.com/awslabs/chalice"&gt;https://github.com/awslabs/chalice&lt;/a&gt;), a python serverless
microframework for AWS. Discussion points for this talk will include,
but not be limited to:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Overview of serverless applications&lt;/li&gt;
&lt;li&gt;Best practices in writing a serverless application&lt;/li&gt;
&lt;li&gt;Basic usage and core features of chalice&lt;/li&gt;
&lt;li&gt;Writing complete, production-level applications using chalice&lt;/li&gt;
&lt;li&gt;Managing and maintaining serverless applications using chalice tooling&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By the end of the talk, audience members should have a better
understanding of serverless computing and how to use chalice to
develop and maintain serverless applications.&lt;/p&gt;
</summary></entry><entry><title>It Works on My Machine: Writing Python Code for Any Environment</title><link href="https://pyvideo.org/europython-2015/it-works-on-my-machine-writing-python-code-for-any-environment.html" rel="alternate"></link><published>2015-08-06T00:00:00+00:00</published><updated>2015-08-06T00:00:00+00:00</updated><author><name>Kyle Knapp</name></author><id>tag:pyvideo.org,2015-08-06:europython-2015/it-works-on-my-machine-writing-python-code-for-any-environment.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Kyle Knapp - It Works on My Machine: Writing Python Code for Any Environment
[EuroPython 2015]
[20 July 2015]
[Bilbao, Euskadi, Spain]&lt;/p&gt;
&lt;p&gt;Have you ever developed a nice, well-working python program on one
environment, only to have it blow up with exceptions and tracebacks
when you run it on a different environment? Have no fear! This talk
will show you how to write and maintain python code that is compatible
across environments that may differ by python versions and/or
operating systems.&lt;/p&gt;
&lt;p&gt;Techniques and tips will be drawn from lessons and experiences gained
from making the AWS CLI, a python-based command line tool to manage
AWS resources, compatible across a wide range of environments. In a
case-study-like format, real-life compatibility issues encountered
while developing the AWS CLI will be presented along with how we
resolved each of them. These real-life examples will encompass, but
will not be limited to, the following topics:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;How to use functions and classes that may differ across python versions and/or operating systems&lt;/li&gt;
&lt;li&gt;How to handle version-specific bugs&lt;/li&gt;
&lt;li&gt;How to handle strings, bytes, and Unicode across python versions&lt;/li&gt;
&lt;li&gt;How to handle differing locale settings&lt;/li&gt;
&lt;li&gt;How to handle file operations across operating systems&lt;/li&gt;
&lt;li&gt;How and when to vendor dependencies&lt;/li&gt;
&lt;li&gt;How to write tests that are compatible across python versions and operating systems&lt;/li&gt;
&lt;li&gt;How to create a testing environment that monitors compatibility of code across various environments&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ultimately, the goal of these examples is introduce to you some
effective, real-world programming practices to overcome your current
or next compatibility issue.&lt;/p&gt;
</summary></entry><entry><title>Dynamic Class Generation in Python</title><link href="https://pyvideo.org/europython-2016/dynamic-class-generation-in-python.html" rel="alternate"></link><published>2016-07-28T00:00:00+00:00</published><updated>2016-07-28T00:00:00+00:00</updated><author><name>Kyle Knapp</name></author><id>tag:pyvideo.org,2016-07-28:europython-2016/dynamic-class-generation-in-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Kyle Knapp - Dynamic Class Generation in Python
[EuroPython 2016]
[18 July 2016]
[Bilbao, Euskadi, Spain]
(&lt;a class="reference external" href="https://ep2016.europython.eu//conference/talks/dynamic-class-generation-in-python"&gt;https://ep2016.europython.eu//conference/talks/dynamic-class-generation-in-python&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;This talk is about dynamic class generation in python: the practice of
writing code that generates classes and their functionality at
runtime. It will use boto3, the AWS SDK for Python, as a basis to dive
into the basics, the benefits, and the drawbacks to dynamically
generating classes.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;This talk is about the concept of dynamic class generation in python.
The whole idea is writing code that generates classes and their
functionality at runtime. You now may be asking yourself, “That sounds
like a neat trick. Why would I ever generate my classes at runtime?”
Here are a few reasons why:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;It can decrease the physical size of your code.&lt;/li&gt;
&lt;li&gt;It can improve the workflow in adding new functionality.&lt;/li&gt;
&lt;li&gt;It can improve reliability of your code.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;One example where the power of this concept has really been leveraged
is in boto3, the AWS SDK for Python. Dynamic class generation has
allowed boto3 to become heavily data driven such that most of its
classes and methods are generated based off JSON models representing
aspects of an AWS service’s API. For example, to add support for a new
AWS service API in boto3, just plop in a JSON file into the library
with no additional Python code required.&lt;/p&gt;
&lt;p&gt;Using lessons and techniques drawn from developing boto3, this talk
will dive into the following topics related to dynamic class
generation:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The basics of dynamic class generation such as how to effectively dynamically generate classes.&lt;/li&gt;
&lt;li&gt;How to overcome some of the challenges of dynamic class generation.&lt;/li&gt;
&lt;li&gt;The tradeoffs in dynamically generating classes and discussion on when it is appropriate.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By the end of this talk, the hope is that you will have a better
understanding of dynamic class generation and come away with helpful
ideas for your next big project.&lt;/p&gt;
</summary></entry></feed>