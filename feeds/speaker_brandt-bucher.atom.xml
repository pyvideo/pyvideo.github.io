<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org - Brandt Bucher</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_brandt-bucher.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2025-05-17T00:00:00+00:00</updated><subtitle></subtitle><entry><title>A Perfect Match: The history, design, implementation, and future of Python's structural pattern matching</title><link href="https://pyvideo.org/pycon-us-2022/a-perfect-match-the-history-design-implementation-and-future-of-pythons-structural-pattern-matching.html" rel="alternate"></link><published>2022-04-27T00:00:00+00:00</published><updated>2022-04-27T00:00:00+00:00</updated><author><name>Brandt Bucher</name></author><id>tag:pyvideo.org,2022-04-27:/pycon-us-2022/a-perfect-match-the-history-design-implementation-and-future-of-pythons-structural-pattern-matching.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python 3.10 was released on October 4th, bringing with it a major new feature: &amp;quot;structural pattern matching&amp;quot;. As one of the designers of the feature and its principal implementer, my goal is to introduce you to Python's powerful, dynamic, object-oriented approach to this long-established functional programming construct, and …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python 3.10 was released on October 4th, bringing with it a major new feature: &amp;quot;structural pattern matching&amp;quot;. As one of the designers of the feature and its principal implementer, my goal is to introduce you to Python's powerful, dynamic, object-oriented approach to this long-established functional programming construct, and to explore ways that you might use structural pattern matching in your own code. Along the way, we’ll also dive into the history of the match statement, the design process behind it, how it actually works, and what we're already doing to improve it in Python 3.11 and beyond.&lt;/p&gt;
</content><category term="PyCon US 2022"></category></entry><entry><title>Inside CPython 3.11's new specializing, adaptive interpreter.</title><link href="https://pyvideo.org/pycon-us-2023/inside-cpython-311s-new-specializing-adaptive-interpreter.html" rel="alternate"></link><published>2023-04-21T00:00:00+00:00</published><updated>2023-04-21T00:00:00+00:00</updated><author><name>Brandt Bucher</name></author><id>tag:pyvideo.org,2023-04-21:/pycon-us-2023/inside-cpython-311s-new-specializing-adaptive-interpreter.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python 3.11 was released on October 24th, bringing with it a new
&lt;a class="reference external" href="https://peps.python.org/pep-0659"&gt;&amp;quot;specializing, adaptive
interpreter&amp;quot;&lt;/a&gt;. As one of the
engineers who works on this ambitious project, my goal is to introduce
you to the fascinating way that your code now &lt;em&gt;optimizes itself&lt;/em&gt; as it's
running, and to explore …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python 3.11 was released on October 24th, bringing with it a new
&lt;a class="reference external" href="https://peps.python.org/pep-0659"&gt;&amp;quot;specializing, adaptive
interpreter&amp;quot;&lt;/a&gt;. As one of the
engineers who works on this ambitious project, my goal is to introduce
you to the fascinating way that your code now &lt;em&gt;optimizes itself&lt;/em&gt; as it's
running, and to explore the different techniques employed under-the-hood
to make your programs &lt;a class="reference external" href="https://docs.python.org/3/whatsnew/3.11.html#faster-cpython"&gt;25%
faster&lt;/a&gt;
on average. Along the way, we'll also cover many of the challenges faced
when optimizing dynamic programming languages, some of the
&lt;a class="reference external" href="https://github.com/brandtbucher/specialist"&gt;tools&lt;/a&gt; you can use to
observe the new interpreter in action, and what we're already doing to
further improve performance in &lt;a class="reference external" href="https://github.com/faster-cpython/ideas/tree/main/3.12"&gt;Python
3.12&lt;/a&gt; and
beyond.&lt;/p&gt;
</content><category term="PyCon US 2023"></category></entry><entry><title>Building a JIT compiler for CPython</title><link href="https://pyvideo.org/pycon-us-2024/building-a-jit-compiler-for-cpython.html" rel="alternate"></link><published>2024-05-19T00:00:00+00:00</published><updated>2024-05-19T00:00:00+00:00</updated><author><name>Brandt Bucher</name></author><id>tag:pyvideo.org,2024-05-19:/pycon-us-2024/building-a-jit-compiler-for-cpython.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;CPython is a programming language implementation that is mostly
maintained by volunteers, but has a huge, diverse user base spread
across a wide variety of platforms. These factors present a difficult
set of challenges and tradeoffs when making design decisions, especially
those related to just-in-time machine code generation.&lt;/p&gt;
&lt;p&gt;As …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;CPython is a programming language implementation that is mostly
maintained by volunteers, but has a huge, diverse user base spread
across a wide variety of platforms. These factors present a difficult
set of challenges and tradeoffs when making design decisions, especially
those related to just-in-time machine code generation.&lt;/p&gt;
&lt;p&gt;As one of the engineers working on Microsoft's ambitious &amp;quot;Faster
CPython&amp;quot; project, I'll introduce our prototype of &amp;quot;copy-and-patch&amp;quot;, an
interesting technique for generating high-quality template JIT
compilers. Along the way, I'll also cover some of the important work in
recent CPython releases that this approach builds upon, and how
copy-and-patch promises to be an incredibly attractive tool for pushing
Python's performance forward in a scalable, maintainable way.&lt;/p&gt;
</content><category term="PyCon US 2024"></category></entry><entry><title>What they don't tell you about building a JIT compiler for CPython</title><link href="https://pyvideo.org/pycon-us-2025/what-they-dont-tell-you-about-building-a-jit-compiler-for-cpython.html" rel="alternate"></link><published>2025-05-17T00:00:00+00:00</published><updated>2025-05-17T00:00:00+00:00</updated><author><name>Brandt Bucher</name></author><id>tag:pyvideo.org,2025-05-17:/pycon-us-2025/what-they-dont-tell-you-about-building-a-jit-compiler-for-cpython.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Despite their reputation, just-in-time compilers are not magic “go faster” machines. Developing and maintaining any sort of optimizing compiler for even a single platform, let alone all of Python’s most popular supported platforms, is an incredibly complicated, expensive task.&lt;/p&gt;
&lt;p&gt;However, figuring out how to compile Python code down …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Despite their reputation, just-in-time compilers are not magic “go faster” machines. Developing and maintaining any sort of optimizing compiler for even a single platform, let alone all of Python’s most popular supported platforms, is an incredibly complicated, expensive task.&lt;/p&gt;
&lt;p&gt;However, figuring out how to compile Python code down to machine code is just the beginning. Most talks and other resources about JITs offer an interesting introduction to the general approaches used, but gloss over the most interesting technical issues that need to be solved in order to actually &amp;quot;ship&amp;quot; these performance gains in practice.&lt;/p&gt;
&lt;p&gt;As one of the engineers working on Microsoft's ambitious &amp;quot;Faster CPython&amp;quot; project, I'll introduce some of the challenges that we've encountered over the past year in our quest to make your code faster. Along the way, we'll learn how JITs decide what code to compile, how they compile this code in-process in a safe and secure way, and the debugging and profiling requirements that users have come to expect from native code.&lt;/p&gt;
</content><category term="PyCon US 2025"></category></entry></feed>