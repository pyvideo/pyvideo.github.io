<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_sigurd-ljodal.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2019-04-20T00:00:00+00:00</updated><entry><title>Pushing the ORM to its limits</title><link href="https://pyvideo.org/djangocon-europe-2019/pushing-the-orm-to-its-limits.html" rel="alternate"></link><published>2019-04-20T00:00:00+00:00</published><updated>2019-04-20T00:00:00+00:00</updated><author><name>Sigurd Lj√∏dal</name></author><id>tag:pyvideo.org,2019-04-20:djangocon-europe-2019/pushing-the-orm-to-its-limits.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;You can do a lot more with the Django ORM than you might think, and when something isn't possible using the existing primitives, you can easily add your own. In this talk you will learn about both advanced features of the ORM and how to run your own SQL queries.&lt;/strong&gt;
Django's ORM makes it super simple to run quick queries against your database, but it can do a lot more for you than you might think. Need to get some statistics on a monthly-basis? Easy, just annotate your queryset with year and month using &lt;tt class="docutils literal"&gt;ExtractYear&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;ExtractMonth&lt;/tt&gt;, and you can use &lt;tt class="docutils literal"&gt;.values()&lt;/tt&gt; to get the data aggregated by month.
When you find yourself in need of something that is not already covered by the existing ORM functions, you will often be able to create it yourself. Have you modelled your data with separate date and time fields, but need to compare this to a datetime field? You can make a custom expression in Django for combining the date and time into a datetime in the database.
Starting with Django 1.11, you can easily make subqueries using the Django ORM. In Django 2.0 we got support for window functions. Django 2.1 exposes additional functions that are available in many databases, and version 2.2 will introduce support for custom constraints and extends the primitives for custom indexes.
It is also easy to drop down to writing raw SQL if you need to. It is probably not something you need to do every day, but it's good to know that the option is there, and know how and when to do it.&lt;/p&gt;
</summary><category term="django"></category><category term="orm"></category></entry></feed>