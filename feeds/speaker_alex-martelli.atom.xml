<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_alex-martelli.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2017-07-10T00:00:00+00:00</updated><entry><title>"Good enough" is good enough!</title><link href="https://pyvideo.org/europython-2013/good-enough-is-good-enough.html" rel="alternate"></link><published>2013-07-01T00:00:00+00:00</published><updated>2013-07-01T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2013-07-01:europython-2013/good-enough-is-good-enough.html</id><summary type="html"></summary><category term="best-practices"></category><category term="project-management"></category><category term="principles"></category><category term="refactoring"></category></entry><entry><title>Testing in Layers</title><link href="https://pyvideo.org/pycon-italia-2017/testing-in-layers.html" rel="alternate"></link><published>2017-04-07T00:00:00+00:00</published><updated>2017-04-07T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2017-04-07:pycon-italia-2017/testing-in-layers.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Learn how to code tests in modular ways suitable for multiple
arrangements and layers, arrange and deploy tests as unit tests,
intermediate integration tests, end-to-end tests, and load-tests, and
enrich code and tests with appropriate use and analysis of logging.&lt;/p&gt;
</summary></entry><entry><title>Testing in Layers</title><link href="https://pyvideo.org/europython-2017/testing-in-layers.html" rel="alternate"></link><published>2017-07-10T00:00:00+00:00</published><updated>2017-07-10T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2017-07-10:europython-2017/testing-in-layers.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The role of automated testing at the heart of modern development and
operations is a given. However, the traditional approach to testing,
separating too-developer-focused unit testing and (often only semi-automated)
end-to-end integration testing—is not optimal in the modern, fluid world of DevOps.&lt;/p&gt;
&lt;p&gt;Nothing short of full automation is suitable for continuous integration;
any “testing” requiring humans has a drastically different place in the
continuum of development and deployment and should best be called by a
completely different name like quality assurance.
Within the realm of fully automated testing, the best approach,
just as for other kinds of software, is modular and layered.&lt;/p&gt;
&lt;p&gt;This talk highlights the proper design of components for testing purposes
and explains how such a design lets you compose multiple, layered testing
suites that span the gamut from fast, light-weight unit tests meant
to run all the time during development, to full-fledged end-to-end tests
of whole systems—and, crucially, the often-neglected intermediate layers,
bridging the thoroughness of end-to-end tests with unit tests’ speed
and ability to pinpoint the location of any problems that emerge,
enabling rapid fixes of most such problems.&lt;/p&gt;
&lt;p&gt;The talk also discusses the use of modular, layered testing components
to validate software refactoring, and (when deployed in a load-testing
arrangement) identify and validate software (and architectural) optimizations.&lt;/p&gt;
</summary></entry><entry><title>Bay PIGgies March 2017: Testing in Layers</title><link href="https://pyvideo.org/bay-piggies/bay-piggies-march-2017-testing-in-layers.html" rel="alternate"></link><published>2017-03-16T00:00:00+00:00</published><updated>2017-03-16T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2017-03-16:bay-piggies/bay-piggies-march-2017-testing-in-layers.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Speaker: Alex Martelli&lt;/p&gt;
&lt;p&gt;Abstract
Learn how to code tests in modular ways suitable for multiple arrangements and layers, arrange and deploy tests as unit tests, intermediate integration tests, end-to-end tests, and load-tests, and enrich code and tests with appropriate use and analysis of logging.&lt;/p&gt;
&lt;p&gt;Speaker Bio
Alex Martelli is a senior staff engineer at Google. Alex is the author of Python in a Nutshell and coeditor of the Python Cookbook. He is a PSF Fellow and won the 2002 Activators’ Choice Award and the 2006 Frank Willison Award for contributions to the Python community.&lt;/p&gt;
</summary></entry><entry><title>April 2016 BayPiggies meeting at LinkedIn: A Preview of PyCon</title><link href="https://pyvideo.org/bay-piggies/april-2016-baypiggies-meeting-at-linkedin-a-preview-of-pycon.html" rel="alternate"></link><published>2016-04-28T00:00:00+00:00</published><updated>2016-04-28T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2016-04-28:bay-piggies/april-2016-baypiggies-meeting-at-linkedin-a-preview-of-pycon.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;There were 3 excellent talks:&lt;/p&gt;
&lt;p&gt;&amp;quot;Exception and error handling in Python 2 and Python 3 &amp;quot; by Alex Martelli&lt;/p&gt;
&lt;p&gt;&amp;quot;Jupyter Notebook Lightning Talk&amp;quot; by Lisa Bang&lt;/p&gt;
&lt;p&gt;&amp;quot;SQLite: Gotchas and Gimmes&amp;quot; by Dave Sawyer&lt;/p&gt;
</summary></entry><entry><title>Good Enough is good enough! (October 2013)</title><link href="https://pyvideo.org/bay-piggies/good-enough-is-good-enough-october-2013.html" rel="alternate"></link><published>2013-10-24T00:00:00+00:00</published><updated>2013-10-24T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2013-10-24:bay-piggies/good-enough-is-good-enough-october-2013.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Speaker: Alex Martelli
Topic: Good Enough is good enough!
Date: Oct-24-2013
Location: LinkedIn, Mtn. View&lt;/p&gt;
&lt;p&gt;Our culture's default assumption is that everybody should always be striving for perfection -- settling for anything less is seen as a regrettable compromise. This is wrong in most software development situations: focus instead on keeping the software simple, just &amp;quot;good enough&amp;quot;, launch it early, and iteratively improve, enhance, and re-factor it. This is how software success is achieved!&lt;/p&gt;
&lt;p&gt;In a 1989 keynote speech at a Lisp conference, Richard Gabriel had a &amp;quot;light relief&amp;quot; section where he caricatured a SW development approach he called &amp;quot;worse is better&amp;quot; (AKA &amp;quot;New Jersey approach&amp;quot;) and contrasted it with what he called &amp;quot;the right thing&amp;quot; (AKA &amp;quot;MIT/Stanford approach&amp;quot;)... and despite the caricatural aspects reluctantly concluded that NJ was the most viable approach, identifying several of the actual reasons (speed of development, less monolithic designs, systems more easily adaptable to a variety of uses [including changes in the underlying requirements], ease of gradual incremental improvement over time, ...).
The debate hasn't died down since (Gabriel himself contributing richly to both sides (!), sometimes under the pseudonym &amp;quot;Nickieben Bourbaki&amp;quot;). My favorite Gabriel quote is &amp;quot;The right-thing philosophy is based on letting the experts do their expert thing all the way to the end before users get their hands on it [snip] Worse-is-better takes advantage of the natural advantages of incremental development. Incremental improvement satisﬁes some human needs&amp;quot;.&lt;/p&gt;
&lt;p&gt;However, while the debate is still raging, reality has steadily been shifting away from &amp;quot;the right thing&amp;quot; (inherently &amp;quot;Cathedral&amp;quot;-centralized, with &amp;quot;Big Design Up Front&amp;quot; a must, conceived with academia and large firms in mind, and quite unsuited to always-shifting real-world requirements) and towards &amp;quot;the NJ approach&amp;quot; (suited to &amp;quot;Bazaar&amp;quot;-like structures, agile and iterative enhancement, dynamic start-ups and independent developers, in a world of always-shifting specs).&lt;/p&gt;
&lt;p&gt;In this talk, I come down strongly on the side of &amp;quot;the NJ approach&amp;quot;, illustrating it and defending it on both philosophical and pragmatical grounds.&lt;/p&gt;
&lt;p&gt;I draw technical examples from several areas where the systems that won the &amp;quot;mind-share battles&amp;quot; did so by focusing on pragmatic simplicity (&amp;quot;good enough&amp;quot;) to the expense of theoretical refinement and completeness (the quest for elusive perfection), leading to large ecosystems of developers bent on incremental improvement -- the TCP/IP approach to networking contrasted with ISO/OSI, the HTTP/HTML approach to hypertext contrasted with Xanadu, early Unix's simplistic (but OK) approach to interrupted system calls versus Multic's and ITS's perfectionism.&lt;/p&gt;
&lt;p&gt;Within Python, I show how metaclasses' quest for completeness yielded excessive complexity (and 80% of their intended uses can now be obtained via class decorators for 20% of the complexity), and how well incremental improvement worked instead in areas such as sorting, generators, and &amp;quot;guaranteed&amp;quot;-finalization semantics.&lt;/p&gt;
&lt;p&gt;The talk is not about lowering expectations: our dreams must stay big, bigger than we can achieve. It's about the best practical track towards making such dreams reality -- think grandiose, act humble. &amp;quot;Rightly traced and well ordered: what of that? // Speak as they please, what does the mountain care? // Ah, but a man's reach should exceed his grasp // Or what's a heaven for? All's silver-grey // Placid and perfect with my art: and worse&amp;quot;!&lt;/p&gt;
&lt;p&gt;This talk is probably not perfect, but I do think it's good enough.&lt;/p&gt;
&lt;p&gt;Speaker:
Author of &amp;quot;Python in a Nutshell&amp;quot;, co-author of &amp;quot;Python Cookbook&amp;quot;, frequent speaker at Python conferences, once-prolific contributor to StackOverflow, and recipient of the 2006 Frank Willison Memorial Award for contributions to Python, Alex currently works as Senior Staff Engineer at Google.&lt;/p&gt;
</summary></entry><entry><title>There *will* be bugs</title><link href="https://pyvideo.org/pycon-italia-2014/there-will-be-bugs.html" rel="alternate"></link><published>2014-05-24T00:00:00+00:00</published><updated>2014-05-24T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2014-05-24:pycon-italia-2014/there-will-be-bugs.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;If you're pushing the envelope of programming (or of your own skills)... and even when you're not... there will be bugs in your code. The speaker has lots of experience perpetrating, finding, and fixing bugs. Most schools don't cover bug-hunting in programming and computer science classes. I cover the attitudes and skills that are most helpful to minimize your bugs, track them, fix them, ensure they never recur, and deploy fixes to your users.&lt;/p&gt;
&lt;p&gt;In this talk, I describe how to start tracking down those pesky bugs, where they like to hide, how your brain tricks you, making it harder to find the bugs, and the processes that will help avoid them (or catch them early). Testing, pair programming, code reviews, open source (&amp;quot;given enough eyes all bugs are shallow&amp;quot;), when to use a bug-tracker, are just some of what I cover.&lt;/p&gt;
&lt;p&gt;Of all the advice I impart in the talk, the one most important bit: once you've confirmed the existence of a bug, never start &amp;quot;fixing&amp;quot; it until and unless you have reproduced that bug in a unit test. Often this task surprises you by showing the bug is elsewhere than you originally thought - and in any case, writing the test, ensuring it breaks, fixing the code, running the test again to confirm it now passes, and leaving the test (small, simple, fast) in your unit test suite forever, is the only way you can ensure that bug doesn't slip in again without you noticing... (Some push this even further and apply &amp;quot;test-driven&amp;quot; or &amp;quot;behavior-driven&amp;quot; programming - far from bad ideas, if you find you can be productive using them!)&lt;/p&gt;
&lt;p&gt;Most bugs tend to be concentrated in small parts of the code—the ones using too-advanced concepts, perhaps, or the ones where your original understanding of the problem (and thus the related architecture) was imperfect. You may discover where you have been too clever for your own good, and then you need to simplify those parts of the code. As Kernighan put it, &amp;quot;debugging is twice as hard as writing a program in the first place. So if you're as clever as you can be when you write it, how will you ever debug it?&amp;quot;&lt;/p&gt;
</summary></entry><entry><title>I bug ci sono sempre...</title><link href="https://pyvideo.org/pycon-italia-2014/i-bug-ci-sono-sempre.html" rel="alternate"></link><published>2014-05-23T00:00:00+00:00</published><updated>2014-05-23T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2014-05-23:pycon-italia-2014/i-bug-ci-sono-sempre.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Se scrivi programmi innovativi, o ai limiti delle tue abilitá... o anche in caso contrario... i bug, nel tuo codice, ci saranno sempre. Ho molta esperienza a combinare bug, e quindi a scoprirli e rimediarli. A scuola non s'insegna come dar la caccia ai bug, quando t'insegnano programmazione e informatica... quindi, spiego quali atteggiamenti e capacitá aiutano a minimizzare i bug, trovarli, rimediarli, assicurare che non tornino mai piú, e distribuire le correzioni agli utenti del programma.&lt;/p&gt;
&lt;p&gt;In questo talk descrivo come iniziare a cercare i dannati bug, dove preferiscono nascondersi, come il tuo cervello t'imbroglia (rendendo piú difficile trovarli), e le procedure che aiutano ad evitarli (o almeno a trovarli molto presto). Testing, pair programming, code reviews, l'open source (&amp;quot;dati abbastanza occhi, tutti i bug sono facili da vedere&amp;quot;), quando usare un programma bug-tracker, sono fra gli argomenti considerati.&lt;/p&gt;
&lt;p&gt;Di tutti i consigli pratici nel tak, il piu importante: una volta confermata l'esistenza di un bug, mai cominciare a &amp;quot;ripararlo&amp;quot; fino a quando hai riprodotto il bug in un unit-test. Spesso questo compito ti stupisce, rivelando che il bug é altrove da dove pensavi - e comunque, scrivere il test, assicurarsi che non passa, riparare il codice, assicurarsi che adesso il test passa -- e lasciare il test (piccolo, semplice, veloce) per sempre nella tua suite di unit-test, é l'unico modo di assicurarsi che il bug non torni a farsi vivo senza essere notato (lo fanno, lo fanno, fidati...!). Alcuni spingono il concetto anche piú avanti e applicano tecniche &amp;quot;test driven&amp;quot; o &amp;quot;behavior driven&amp;quot; -- lungi dall'essere cattive idee, se non danneggiano la tua produttivitá.&lt;/p&gt;
&lt;p&gt;Molti bug tendono a concentrarsi in piccole parti del codice -- in quelle che usano concetti troppo avanzati, in intricati alberi di decisioni booleane, o in quelle dove l'iniziale comprensione del problema (e quindi l'architettura per affrontarlo) era imperfetta. Se scopri dove sei stato &amp;quot;troppo furbo per il tuo bene&amp;quot;, devi semplificare quelle parti del codice. Come dice Kernighan, &amp;quot;Il debug é due volte piú difficile che inizialmente scrivere il programma stesso. Quindi se sei il piú furbo possibile quando lo scrivi, come mai potrai fare a debuggarlo?&amp;quot;&lt;/p&gt;
</summary></entry><entry><title>"Good Enough" IS Good Enough!</title><link href="https://pyvideo.org/pybay-2016/good-enough-is-good-enough.html" rel="alternate"></link><published>2016-08-21T00:00:00+00:00</published><updated>2016-08-21T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2016-08-21:pybay-2016/good-enough-is-good-enough.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Our culture's default assumption is that everybody should always be striving for perfection -- settling for anything less is seen as a regrettable compromise. This is wrong in most software development situations: focus instead on keeping the software simple, just &amp;quot;good enough&amp;quot;, launch it early, and iteratively improve, enhance, and re-factor it. This is how software success is achieved!
​
Abstract
In 1989, Richard Gabriel caricatured two approaches to SW development: &amp;quot;worse is better&amp;quot; (&amp;quot;New Jersey approach&amp;quot;) and &amp;quot;the right thing&amp;quot; (&amp;quot;MIT/Stanford approach&amp;quot;), reluctantly concluding NJ was more viable, for several reasons (speed of development, flexible designs, systems adaptable to a variety of uses [including changes in requirements], ease of gradual, incremental improvement, ...). And this debate hasn't died down since.&lt;/p&gt;
&lt;p&gt;Debate rages, but reality has moved away from &amp;quot;right thing&amp;quot; (&amp;quot;Cathedral&amp;quot;-centralized &amp;quot;Big Design Up Front&amp;quot;, focus on academia/large firms, unsuited to shifting real-world requirements), toward &amp;quot;NJ&amp;quot; (&amp;quot;Bazaar&amp;quot;-like, agile iterative enhancement, dynamic start-ups/independent developers, a world of always-shifting specs).&lt;/p&gt;
&lt;p&gt;In this talk I support &amp;quot;the NJ approach&amp;quot;, on both philosophical and pragmatical grounds, with examples from many areas. Winners of the &amp;quot;mind-share battles&amp;quot; focused on simplicity (&amp;quot;good enough&amp;quot;), not theoretical refinement/completeness: large ecosystems of developers, incremental improvement -- TCP/IP approach vs ISO/OSI, HTTP/HTML vs Xanadu, early Unix's simplistic (but OK) approach to interrupted system calls vs Multic's/ITS's perfectionism.&lt;/p&gt;
&lt;p&gt;In Python, metaclasses often end up too complex (80% of their pluses can be had via class decorators, for 20% of the complexity); OTOH, incremental improvement worked just fine in sorting, generators, and guaranteed-finalization semantics.&lt;/p&gt;
&lt;p&gt;The talk is not perfect, but I do think it's good enough.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt;
Author of &amp;quot;Python in a Nutshell&amp;quot;, co-author of &amp;quot;Python Cookbook&amp;quot;, PSF Fellow, frequent speaker at Python conferences, prolific contributor to StackOverflow, and winner of the 2006 Frank Willison Memorial Award for contributions to Python, Alex currently leads &amp;quot;1:many tech support&amp;quot; for Google Cloud Platform. He's married to Anna Ravenscroft, his co-author in the &amp;quot;Cookbook&amp;quot; 2nd edition and &amp;quot;Nutshell&amp;quot; 3rd edition, also a PSF Fellow, and also a winner of the Frank Willison Memorial Award, in 2013.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://speakerdeck.com/pybay2016/alex-martelli-good-enough-is-good-enough"&gt;https://speakerdeck.com/pybay2016/alex-martelli-good-enough-is-good-enough&lt;/a&gt;&lt;/p&gt;
</summary></entry><entry><title>The Tower of Abstraction</title><link href="https://pyvideo.org/pybay-2016/the-tower-of-abstraction.html" rel="alternate"></link><published>2016-08-21T00:00:00+00:00</published><updated>2016-08-21T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2016-08-21:pybay-2016/the-tower-of-abstraction.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Abstraction is a powerful servant, but a dangerous master. We code, design, think, debug ... on a tower of abstractions. Spolsky's Law tells us that &amp;quot;All abstractions leak&amp;quot;. This talk explores why they leak, why that's often a problem, what to do about it; I also cover why sometimes abstractions SHOULD &amp;quot;leak&amp;quot;, and how best to produce and consume abstraction layers.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bio:&lt;/strong&gt;
Author of &amp;quot;Python in a Nutshell&amp;quot;, co-author of &amp;quot;Python Cookbook&amp;quot;, PSF Fellow, frequent speaker at Python conferences, prolific contributor to StackOverflow, and winner of the 2006 Frank Willison Memorial Award for contributions to Python, Alex currently leads &amp;quot;1:many tech support&amp;quot; for Google Cloud Platform. He's married to Anna Ravenscroft, his co-author in the &amp;quot;Cookbook&amp;quot; 2nd edition and &amp;quot;Nutshell&amp;quot; 3rd edition, also a PSF Fellow, and also a winner of the Frank Willison Memorial Award, in 2013.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://speakerdeck.com/pybay2016/alex-martelli-the-tower-of-abstraction"&gt;https://speakerdeck.com/pybay2016/alex-martelli-the-tower-of-abstraction&lt;/a&gt;&lt;/p&gt;
</summary></entry><entry><title>exception and error handling in python 2 and python 3</title><link href="https://pyvideo.org/pycon-italia-2016/exception-and-error-handling-in-python-2-and-python-3.html" rel="alternate"></link><published>2016-06-20T00:00:00+00:00</published><updated>2016-06-20T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2016-06-20:pycon-italia-2016/exception-and-error-handling-in-python-2-and-python-3.html</id><summary type="html"></summary></entry><entry><title>Gestione di errori ed eccezioni in Python 2 e Python 3</title><link href="https://pyvideo.org/pycon-italia-2016/gestione-di-errori-ed-eccezioni-in-python-2-e-python-3.html" rel="alternate"></link><published>2016-06-20T00:00:00+00:00</published><updated>2016-06-20T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2016-06-20:pycon-italia-2016/gestione-di-errori-ed-eccezioni-in-python-2-e-python-3.html</id><summary type="html"></summary></entry><entry><title>Exception and error handling in Python 2 and Python 3</title><link href="https://pyvideo.org/pycon-us-2016/alex-martelli-exception-and-error-handling-in-python-2-and-python-3-pycon-2016.html" rel="alternate"></link><published>2016-05-31T00:00:00+00:00</published><updated>2016-05-31T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2016-05-31:pycon-us-2016/alex-martelli-exception-and-error-handling-in-python-2-and-python-3-pycon-2016.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Speaker: Alex Martelli&lt;/p&gt;
&lt;p&gt;Handling errors and exceptions optimally is crucial in solid Python programs. Some technical details have changed in Python 3, and the talk covers those, but the core of &amp;quot;&amp;quot;best practices&amp;quot;&amp;quot; is quite enduring, and the talk focuses on presenting and explaining them.&lt;/p&gt;
&lt;p&gt;Slides can be found at: &lt;a class="reference external" href="https://speakerdeck.com/pycon2016"&gt;https://speakerdeck.com/pycon2016&lt;/a&gt; and &lt;a class="reference external" href="https://github.com/PyCon/2016-slides"&gt;https://github.com/PyCon/2016-slides&lt;/a&gt;&lt;/p&gt;
</summary></entry><entry><title>Good API design</title><link href="https://pyvideo.org/europython-2011/good-api-design.html" rel="alternate"></link><published>2011-07-21T00:00:00+00:00</published><updated>2011-07-21T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2011-07-21:europython-2011/good-api-design.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Alex Martelli - 20 June 2011 in &amp;quot;Track Spaghetti&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Designing interfaces so that other code can interact with ours (whether
our code is a library, framework, application, website…) is a very
common and clearly crucial activity, but it's fraught with dangers -
there's a lot stuff we all keep doing wrong time after time. This talk
shows some common categories of API design errors encountered in the
wild, with tips on how to avoid them when you design your next API.&lt;/p&gt;
&lt;p&gt;Goals: to show you how to focus resources and attention to help avoid
mistakes in API design. Prereqs: experience designing and developing
software, esp. software which needs to interact w/other existing
software.&lt;/p&gt;
</summary><category term="api"></category><category term="design"></category><category term="interfaces"></category></entry><entry><title>Python Design Patterns</title><link href="https://pyvideo.org/europython-2011/python-design-patterns.html" rel="alternate"></link><published>2011-07-13T00:00:00+00:00</published><updated>2011-07-13T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2011-07-13:europython-2011/python-design-patterns.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Alex Martelli - 24 June 2011 in &amp;quot;Track Spaghetti&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;A completely misguided meme has long been going around: that Python
doesn't have, or need, any Design Patterns. This terrible meme may
spring from not realizing what the Gang Of Four state so plainly in
their historical &amp;quot;Design Patterns&amp;quot; book: which design patterns are
useful DOES depend on the programming language one targets - design is
NOT independent of implementation, as the epic-fail &amp;quot;Waterfall&amp;quot;
Methodology Pattern would suggest. What patterns apply to a design,
depends to some extent on what implementation technologies will be used
to realize that design.&lt;/p&gt;
&lt;p&gt;If you focus on some &amp;quot;classic DPs&amp;quot; that are basically workarounds for
some other language's lack of garbage collection, or for a clumsy
static-typing system, those may indeed be worthless for Python. But many
other DPs are perfectly useful and applicable, and Python's strengths as
a language afford riffing on them to develop highly Pythonic, powerful,
productive variants.&lt;/p&gt;
&lt;p&gt;In this talk, I analyze some of my favorite pattern families - e.g.,
Template Method and its variants, Dependency Injection and its ilk,
Callback and friends - in a highly Pythonic context. Non-pattern Idioms,
and Patterns that aren't really Design Patterns but rather Architecture
or Methodology ones, make cameo appearances.&lt;/p&gt;
&lt;p&gt;Goals: remove from your system any residue of the pernicious meme about
Python not having or needing design patterns. Prereqs: experience
designing and developing software; intermediate-level Python knowledge.&lt;/p&gt;
</summary><category term="architecture"></category><category term="design"></category><category term="patterns"></category></entry><entry><title>Permission or forgiveness?</title><link href="https://pyvideo.org/europython-2012/permission-or-forgiveness-0.html" rel="alternate"></link><published>2012-07-04T00:00:00+00:00</published><updated>2012-07-04T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2012-07-04:europython-2012/permission-or-forgiveness-0.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2012 ] Alex Martelli - 2 JULY 2012 in &amp;quot;Track Spaghetti&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Grace Murray Hopper’s famous motto, “It’s easier to ask forgiveness than
permission”, has many useful applications – in Python, in concurrency,
in networking, as well of course as in real life. However, it’s not
universally valid. This talk explores both useful and damaging
applications of this principle. I start by introducing the motto “It’s
easier to ask forgiveness than permission” and the woman who used it,
Rear Admiral Grace Murray Hopper, also known as the “mother of Cobol”
and the author of the first ever programming-language compiler. I then
move on to the Python context, where the motto supports the proper usage
of exception-catching rather than preliminary checks; and the “rule that
proves the exception” introduced by abstract base classes. Expanding the
subject, I show how “optimistic concurrency” applies that motto (while
locking would “ask permission”, in essence, STM “asks forgiveness&amp;quot;), and
how collision-detection focused networking protocols have similarly
triumphed over more highly structured, “ask permission” ones like
token-ring. Moving to the fuzzier context of real life, I then show how
this daring approach does not work quite as well as in the technical
realm – except when applied correctly, in the right circumstances… and I
try to evince a general law describing what the right circumstances for
its application are, comparing and contrasting with the similar issue of
“do it right the first time” versus “launch and iterate” (and the
latter’s cognate “fail, but fail fast” principle).&lt;/p&gt;
</summary></entry><entry><title>Modern Python Patterns and Idioms</title><link href="https://pyvideo.org/pycon-italia-2015/modern-python-patterns-and-idioms.html" rel="alternate"></link><published>2015-06-09T00:00:00+00:00</published><updated>2015-06-09T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2015-06-09:pycon-italia-2015/modern-python-patterns-and-idioms.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;As Python grows, the problem spaces we address keep shifting, and best
practices for software development mature, so does the set of
best-of-breed patterns and idioms change: some classics fading, new
stars emerging. This talk helps fill the gap between yesterday’s good
old Python, and tomorrow’s glittering vistas.&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python itself has grown to encompass some classic idioms, such as
Decorate-Sort-Undecorate, AKA DSU, begetting the widespread key=
argument to most functions related to ordering – but not quite all of
them: heapq, for example, still mostly lacks key= – so, we also show
what idioms to use with this and similar modules.&lt;/p&gt;
&lt;p&gt;Lists have long been one of Python’s strengths, and they’re of course
still precious – but many kinds of specialized containers have emerged,
and it’s important to know how to choose among them, and when and how to
roll your own. More important still, iterators have grown into
prominence, and very often they’ll be the best choice – and they come
with a large set of relevant patterns and idioms.&lt;/p&gt;
&lt;p&gt;The tectonic shift that’s taking us from classic to modern Python goes
even deeper – even the dominance of good old duck typing is threatened!
Specifically, in many cases, we use, instead, goose typing – checking
against an abstract base class – and, as type annotations slowly emerge,
they reinforce this general tendency.&lt;/p&gt;
&lt;p&gt;These, and a miscellanea of smaller patterns and idioms (concerning I/O,
best uses of dicts and other specialized mappings, async operations,
testing, …), are fast becoming indispensable parts of the Proficient
Pythonista’s repertoire.&lt;/p&gt;
</summary></entry><entry><title>*aaS Royal Rumble - Q&amp;A</title><link href="https://pyvideo.org/pycon-italia-2015/aas-royal-rumble-qa.html" rel="alternate"></link><published>2015-05-30T00:00:00+00:00</published><updated>2015-05-30T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2015-05-30:pycon-italia-2015/aas-royal-rumble-qa.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;La sessione di Q&amp;amp;A ti permetterà di approfondire le differenze tra le
varie piattaforme.&lt;/p&gt;
</summary></entry><entry><title>Powerful Pythonic Patterns (#186)</title><link href="https://pyvideo.org/pycon-us-2010/pycon-2010--powerful-pythonic-patterns---186.html" rel="alternate"></link><published>2010-02-19T00:00:00+00:00</published><updated>2010-02-19T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2010-02-19:pycon-us-2010/pycon-2010--powerful-pythonic-patterns---186.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Powerful Pythonic Patterns video&lt;/p&gt;
&lt;p&gt;Presented by Alex Martelli&lt;/p&gt;
&lt;p&gt;An extremely misguided meme is going around: that Python doesn't have,
or need, any Design Patterns. Maybe the meme springs from not realizing
what the Gang Of Four state so plainly in their historical &amp;quot;Design
Patterns&amp;quot; book: which design patterns are useful DOES depend on the
programming language one targets -- design is NOT independent of
implementation, as the epic-fail &amp;quot;Waterfall&amp;quot; Methodology Pattern would
suggest. If you examine a &amp;quot;classic DP&amp;quot; that's basically a workaround for
some other language's lack of garbage collection, or for a clumsy
static-typing system, it may indeed be worthless for Python. But many
other DPs are still perfectly useful and applicable, and indeed Python's
strengths as a language afford riffing on them to develop highly
Pythonic, powerful, productive variants.&lt;/p&gt;
&lt;p&gt;In this talk, I analyze some of my favorite pattern families -- e.g.,
Template Method and its variants, Dependency Injection and its ilk,
Callback and friends -- in a highly Pythonic context. Non-pattern
Idioms, and Patterns that aren't really Design Patterns but rather
Architecture or Methodology ones, also make cameo appearances.&lt;/p&gt;
</summary><category term="designpatterns"></category><category term="pycon"></category><category term="pycon2010"></category><category term="python-advanced"></category></entry><entry><title>API Design anti-patterns</title><link href="https://pyvideo.org/pycon-us-2011/pycon-2011--api-design-anti-patterns.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--api-design-anti-patterns.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;API Design Anti-Patterns&lt;/p&gt;
&lt;p&gt;Presented by Alex Martelli&lt;/p&gt;
&lt;p&gt;Designing interfaces so that other code can interact with ours (whether
our code is a library, framework, application, website...) is a very
common and clearly crucial activity, but fraught with dangers -- stuff
we all keep doing wrong time after time. This talks shows some common
cases of API design errors encountered in the wild, with tips on how to
avoid them when you design your next API.&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;Whenever we write code we should always be thinking about how other code
(whether our own, or other people's) will interact with ours (an &amp;quot;API&amp;quot;,
in common parlance). Indeed, the most common and terrible mistake in API
design is... not doing any! -- i.e., not providing any designed,
architected way for other code to interact with ours. That's fortunately
less common when &amp;quot;our code&amp;quot; is a library or framework;-), but, alas!,
sadly widespread when &amp;quot;our code&amp;quot; is an application or website -- that's
why questions about screen- scraping the web and simulating keystrokes
and mouse gestures need be so tragically frequent all over the web.&lt;/p&gt;
&lt;p&gt;Once past the obvious hurdle of not having any API at all, there's still
plenty of ways we can go badly wrong in the process of designing one --
and many of those ways fall into recognizable categories, i.e.,
patterns. Specifically, since they're frequently observed categories of
defective design, they're anti-patterns -- and that's what this talk is
in fact about (as the smartest among you could tell from the title...).&lt;/p&gt;
&lt;p&gt;I'm eminently qualified to present on this subject, since, in a lifetime
spent mostly stumbling into software (after actually qualifying to
design hardware in college, but only doing that for a few years), I've
been responsible for more of my shares of API design fumbles (plus, of
course, just like every other programmer, I've done my share of swearing
at the design fumbles of other API designers). And, as novelist Richard
Bach reminds us, &amp;quot;You teach best what you most need to learn&amp;quot;!-)&lt;/p&gt;
</summary><category term="api"></category><category term="pycon"></category><category term="pycon2011"></category></entry><entry><title>Permission or Forgiveness?</title><link href="https://pyvideo.org/pycon-us-2012/permission-or-forgiveness.html" rel="alternate"></link><published>2012-03-09T00:00:00+00:00</published><updated>2012-03-09T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2012-03-09:pycon-us-2012/permission-or-forgiveness.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Grace Murray Hopper's famous motto, &amp;quot;It's easier to ask forgiveness than
permission&amp;quot;, has many useful applications -- in Python, in concurrency,
in networking, as well of course as in real life. However, it's not
universally valid. This talk explores both useful and damaging
applications of this principle.&lt;/p&gt;
</summary></entry><entry><title>"Good enough" is good enough!</title><link href="https://pyvideo.org/pycon-us-2013/good-enough-is-good-enough.html" rel="alternate"></link><published>2013-03-17T00:00:00+00:00</published><updated>2013-03-17T00:00:00+00:00</updated><author><name>Alex Martelli</name></author><id>tag:pyvideo.org,2013-03-17:pycon-us-2013/good-enough-is-good-enough.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Our culture's default assumption is that everybody should always be
striving for perfection -- settling for anything less is seen as a
regrettable compromise. This is wrong in most software development
situations: focus instead on keeping the software simple, just &amp;quot;good
enough&amp;quot;, launch it early, and iteratively improve, enhance, and
re-factor it. This is how software success is achieved!&lt;/p&gt;
</summary><category term="talk"></category></entry></feed>