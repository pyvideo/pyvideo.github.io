<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/tag_decorators.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2013-12-29T00:00:00+00:00</updated><entry><title>Decoradores desmitificados</title><link href="https://pyvideo.org/pycon-es-2013/decoradores-desmitificados.html" rel="alternate"></link><published>2013-12-29T00:00:00+00:00</published><updated>2013-12-29T00:00:00+00:00</updated><author><name>Pablo Enfedaque Vidal</name></author><id>tag:pyvideo.org,2013-12-29:pycon-es-2013/decoradores-desmitificados.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Autor: Pablo Enfedaque Vidal&lt;/p&gt;
&lt;p&gt;Track: Avanzado&lt;/p&gt;
&lt;p&gt;¿Sabes lo que pasa cada vez que utilizas el símbolo &amp;#64; en Python? En esta charla vamos a descubrir la magia que hay detrás del syntactic sugar de los decoradores. Para entender cómo funcionan internamente veremos en detalle los scopes y los namespaces de Python y luego aplicaremos manualmente nuestros propios decoradores.&lt;/p&gt;
</summary><category term="decorators"></category></entry><entry><title>A Deep-Dive Into Python Classes</title><link href="https://pyvideo.org/europython-2011/a-deep-dive-into-python-classes.html" rel="alternate"></link><published>2011-07-15T00:00:00+00:00</published><updated>2011-07-15T00:00:00+00:00</updated><author><name>Mark Smith</name></author><id>tag:pyvideo.org,2011-07-15:europython-2011/a-deep-dive-into-python-classes.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Mark Smith - 22 June 2011 in &amp;quot;Track Lasagne&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;This talk aims to lift the lid on the system that governs how types
behave in Python - everything except Metaclasses.&lt;/p&gt;
&lt;p&gt;The talk answers questions such as:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;What is a class, and how can we think of them?&lt;/li&gt;
&lt;li&gt;How are classes instantiated?&lt;/li&gt;
&lt;li&gt;How are attributes obtained from a class or an instance?&lt;/li&gt;
&lt;li&gt;Why do I get a different thing when accessing a method via its class
instead of its instance?&lt;/li&gt;
&lt;li&gt;How do the classmethod and staticmethod decorators work?&lt;/li&gt;
&lt;li&gt;How can I modify classes and instances after they've been
initialised?&lt;/li&gt;
&lt;li&gt;Does any of this allow me to do any clever tricks?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Attendees should understand at least the basics of object oriented
programming in Python. This talk doesn't aim to explain
object-orientation, o-o design, or how Python represents objects in C.&lt;/p&gt;
</summary><category term="decorators"></category></entry><entry><title>plac: more than just another command-line arguments parser</title><link href="https://pyvideo.org/europython-2011/plac-more-than-just-another-command-line-argumen.html" rel="alternate"></link><published>2011-07-13T00:00:00+00:00</published><updated>2011-07-13T00:00:00+00:00</updated><author><name>Michele Simionato</name></author><id>tag:pyvideo.org,2011-07-13:europython-2011/plac-more-than-just-another-command-line-argumen.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Michele Simionato - 21 June 2011 in &amp;quot;Track Ravioli&amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;plac is general purpose tool than can be used to define command-oriented
domain specific languages (DSLs). In its simplest form it can be used as
a command-line arguments parser with an easier-to-use API than argparse.
It can also be used to replace the cmd module in the standard library.
Moreover it can be used to automatize functional tests and for much
more. The talk will touch upon many use cases where plac can make your
life as a developer simpler and better. Technically Plac is a wrapper
over argparse and works in all versions of Python starting from Python
2.3 up to Python 3.2. In Python 3.X it takes advantage of function
annotations to define the parser in a declarative way, instead of the
imperative way of argparse. In Python 2.X it uses decorators instead, to
reach the same goal. The talk is a hands-on interactive demonstration of
plac capabilities.&lt;/p&gt;
</summary><category term="api"></category><category term="argparse"></category><category term="cmd"></category><category term="decorators"></category><category term="parser"></category></entry><entry><title>Decorators From Basics to Class Decorators to Decorator Libraries (#138)</title><link href="https://pyvideo.org/pycon-us-2010/pycon-2010--decorators-from-basics-to-class-decor.html" rel="alternate"></link><published>2010-02-19T00:00:00+00:00</published><updated>2010-02-19T00:00:00+00:00</updated><author><name>Charles Merriam</name></author><id>tag:pyvideo.org,2010-02-19:pycon-us-2010/pycon-2010--decorators-from-basics-to-class-decor.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Decorators from Basics to Class Decorators to Decorator Libraries&lt;/p&gt;
&lt;p&gt;Presented by Charles Merriam&lt;/p&gt;
&lt;p&gt;Decorators simplify design and improve readability and reliability. This
tutorial starts from the beginning with basic decorators, showing how
simple tasks like restricting administration functions are clearer and
more readable with decorators, and exactly how the decorators work. A
simple library of decorators for tracing, logging, and caching results
is presented. This leads into writing your own decorators and
parameterized decorators either from scratch or by using libraries like
Simionato's Decorator Decorator and &amp;quot;&amp;#64;call_before(fn)&amp;quot;. Finally, using
Python 3.x class decorators in place of metaclasses for most common
dictionary modifications is covered.&lt;/p&gt;
&lt;p&gt;[VIDEO HAS ISSUES: Missing about 1 minute at start, because of technical
problems.]&lt;/p&gt;
</summary><category term="decorators"></category><category term="pycon"></category><category term="pycon2010"></category></entry><entry><title>The Meaty Parts of Python: Closures, Decorators, List Comprehension, and Functional Constructs</title><link href="https://pyvideo.org/pycon-us-2010/pycon-2010--the-meaty-parts-of-python--closures--.html" rel="alternate"></link><published>2010-02-19T00:00:00+00:00</published><updated>2010-02-19T00:00:00+00:00</updated><author><name>Matt Harrison</name></author><id>tag:pyvideo.org,2010-02-19:pycon-us-2010/pycon-2010--the-meaty-parts-of-python--closures--.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;The Meaty Parts of Python: Closures, Decorators, List Comprehension, and
Functional Constructs&lt;/p&gt;
&lt;p&gt;Presented by Matt Harrison&lt;/p&gt;
&lt;p&gt;Are you new to Python and want to learn how to step it up to the next
level? Have you wondered about functional programming, closures,
decorators, generators or list comprehensions and when you should use
them? This hands-on tutorial will cover these intermediate subjects in
detail, by explaining the theory behind them then walking through
examples. It will also cover how to test such programs. The session will
conclude with some basic problems to work through.&lt;/p&gt;
&lt;p&gt;Outline:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Testing (45 min)&lt;ul&gt;
&lt;li&gt;unittest&lt;/li&gt;
&lt;li&gt;doctest&lt;/li&gt;
&lt;li&gt;brief code coverage intro&lt;/li&gt;
&lt;li&gt;other testing tools&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Functional Programming (15 min)&lt;ul&gt;
&lt;li&gt;lambda&lt;/li&gt;
&lt;li&gt;map&lt;/li&gt;
&lt;li&gt;reduce&lt;/li&gt;
&lt;li&gt;filter&lt;/li&gt;
&lt;li&gt;Substitutes for above constructs&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Functions (20 min)&lt;ul&gt;
&lt;li&gt;callables&lt;/li&gt;
&lt;li&gt;arguments (args, kw)&lt;/li&gt;
&lt;li&gt;mutable parameters&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Scoping (10 min)&lt;/li&gt;
&lt;li&gt;Closures (5 min)&lt;/li&gt;
&lt;li&gt;Decorators (20 min)&lt;ul&gt;
&lt;li&gt;Simple decorators&lt;/li&gt;
&lt;li&gt;parameterized decorators&lt;/li&gt;
&lt;li&gt;mangling&lt;/li&gt;
&lt;li&gt;templates for decorators&lt;/li&gt;
&lt;li&gt;classmethod staticmethod&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Properties (5 min)&lt;/li&gt;
&lt;li&gt;List comprehensions (10 min)&lt;/li&gt;
&lt;li&gt;Iterator pattern (5 min)&lt;/li&gt;
&lt;li&gt;Generators (15 min )&lt;/li&gt;
&lt;li&gt;Hands-on application (50 min)&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="callables"></category><category term="closures"></category><category term="decorators"></category><category term="functionalprogramming"></category><category term="functions"></category><category term="generators"></category><category term="iterators"></category><category term="listcomprehensions"></category><category term="pycon"></category><category term="pycon2010"></category><category term="python-advanced"></category></entry><entry><title>Turtles All The Way Down: Demystifying Deferreds, Decorators, and Declarations (#169)</title><link href="https://pyvideo.org/pycon-us-2010/pycon-2010--turtles-all-the-way-down--demystifyin.html" rel="alternate"></link><published>2010-02-19T00:00:00+00:00</published><updated>2010-02-19T00:00:00+00:00</updated><author><name>Glyph</name></author><id>tag:pyvideo.org,2010-02-19:pycon-us-2010/pycon-2010--turtles-all-the-way-down--demystifyin.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Turtles all the way down: Demystifying deferreds, decorators and
declarations&lt;/p&gt;
&lt;p&gt;Presented by Glyph Lefkowitz&lt;/p&gt;
&lt;p&gt;Python's flexible object model allows library and framework authors to
add very flexible declarations. Metaclasses, decorators, callable
objects, and operator overloading practically allow libraries to
re-define the language in order to provide a more concise, natural style
for that library. Unfortunately, the library user's first experience of
such conveniences is often confusing, because it's not clear what's
going on.&lt;/p&gt;
&lt;p&gt;In this talk, I will try to convince you that all of this wonderful
magic isn't all that weird. This is not a typical how-to session on how
to use a particular feature, either of Python or of Twisted, but will
rather draw examples from Python, Twisted, and Zope to illustrate
techniques you can use to read and understand &amp;quot;magical&amp;quot; Python code.&lt;/p&gt;
</summary><category term="decorators"></category><category term="deferreds"></category><category term="delcarations"></category><category term="pycon"></category><category term="pycon2010"></category></entry><entry><title>Useful Namespaces: Context Managers and Decorators</title><link href="https://pyvideo.org/pycon-us-2011/pycon-2011--useful-namespaces--context-managers-a.html" rel="alternate"></link><published>2011-03-11T00:00:00+00:00</published><updated>2011-03-11T00:00:00+00:00</updated><author><name>Jack Diederich</name></author><id>tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--useful-namespaces--context-managers-a.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Useful Namespaces: Context Managers and Decorators&lt;/p&gt;
&lt;p&gt;Presented by Jack Diederich&lt;/p&gt;
&lt;p&gt;Python has two useful conventions for &amp;quot;I mean it, but only here&amp;quot; and you
can say it with Context Managers and Decorators. Both give you the power
to define a push/pop of a resource for a set period inside a namespace,
be it a function or a level of indentation. This talk is a list of
patterns that are implemented by one or the other (including some clever
functions that are both).&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Decorators, formal definition.&lt;/li&gt;
&lt;li&gt;Context Managers, formal definition.&lt;/li&gt;
&lt;li&gt;Informal definition: both have the opportunity to do and then undo. -
very similar to C++ RIIA &amp;quot;Resource Acquisition Is Initialization.&amp;quot; -
Context Managers were designed to do that but decorators are
frequently just as good.&lt;/li&gt;
&lt;li&gt;Which one to use use when is all about namespaces. - Context Managers
manipulate at the block level. - Function Decorators manipulate the
function level. - Class Decorators manipulate at the class level.&lt;/li&gt;
&lt;li&gt;Recipes on writing decorators and context managers - Familiar
examples from Django and Mock.&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="contextmanagers"></category><category term="decorators"></category><category term="namespaces"></category><category term="pycon"></category><category term="pycon2011"></category></entry></feed>