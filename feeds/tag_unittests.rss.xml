<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Sun, 26 Jun 2016 00:00:00 +0000</lastBuildDate><item><title>Testes unita패rios como ferramentas de design de co패digo</title><link>https://pyvideo.org/caipyra-2016/testes-unitarios-como-ferramentas-de-design-de-codigo.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Palestra da Paula Grangeiro no Caipyra 2016:&lt;/p&gt;
&lt;p&gt;Testes unita패rios como ferramentas de design de co패digo&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Paula Grangeiro</dc:creator><pubDate>Sun, 26 Jun 2016 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2016-06-26:caipyra-2016/testes-unitarios-como-ferramentas-de-design-de-codigo.html</guid><category>unittest</category><category>unittests</category></item><item><title>Units Need Testing Too</title><link>https://pyvideo.org/pycon-us-2011/pycon-2011--units-need-testing-too.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Units Need Testing Too&lt;/p&gt;
&lt;p&gt;Presented by Gary Bernhardt&lt;/p&gt;
&lt;p&gt;Python's long history of testing has focused primarily on integration-
and system-level tests: slow-running tests executing lots of code. These
are a great start, but many of them can be transformed into unit-level
tests. True unit tests are orders of magnitude faster (about 1ms each),
providing quicker feedback and better failure localization. We'll look
at why and how to write them.&lt;/p&gt;
&lt;p&gt;Abstract&lt;/p&gt;
&lt;p&gt;Python has a wonderful legacy in testing: PyUnit has been in the
standard library since March, 2001, and it was already a year old by
then. We adopted browser driving quickly, and we do it at huge scale
with great test parallelization infrastructure.&lt;/p&gt;
&lt;p&gt;Big tests aren't everything, though. In the Python world, true unit
tests are somewhat rare, and even most tests written with the unittest
library are integration tests. These tests are slow to execute and don't
localize failure as well as smaller, focused tests. They leave us with
two options: either run them rarely, sacrificing feedback, or run them
often, sacrificing speed.&lt;/p&gt;
&lt;p&gt;Writing true unit tests removes that particular trade-off. When your
tests execute in a millisecond each, you can afford to run a thousand of
them every time you save a source file. This talk will discuss what unit
tests really are, why they matter, and how to write them in Python.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Gary Bernhardt</dc:creator><pubDate>Fri, 11 Mar 2011 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2011-03-11:pycon-us-2011/pycon-2011--units-need-testing-too.html</guid><category>pycon</category><category>pycon2011</category><category>pyunit</category><category>testing</category><category>unittests</category></item></channel></rss>