<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_thomas-guest.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2018-09-17T00:00:00+00:00</updated><entry><title>TIMTOWTDI</title><link href="https://pyvideo.org/pycon-uk-2018/timtowtdi.html" rel="alternate"></link><published>2018-09-17T00:00:00+00:00</published><updated>2018-09-17T00:00:00+00:00</updated><author><name>Thomas Guest</name></author><id>tag:pyvideo.org,2018-09-17:pycon-uk-2018/timtowtdi.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Should there be one—and preferably only one—obvious way to do it?&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;TIMTOWTDI stands for “There is more than one way to do it”, an
approach promoted by the Perl community.&lt;/div&gt;
&lt;div class="line"&gt;A contrasting mantra appears in the Zen of Python, a list of aphorisms
which summarise the guiding principles behind Python’s design. Item
number 13 states: “There should be one — and preferably only one —
obvious way to do it.”&lt;/div&gt;
&lt;div class="line"&gt;This talk discusses these apparently different philosophies. It
demonstrates that Python, like Perl, borrows features from other
languages. Contrary to Item 13, there is — and has always been — more
than one way to do it. Obviously.&lt;/div&gt;
&lt;/div&gt;
</summary></entry><entry><title>Lazy Sequences working hard</title><link href="https://pyvideo.org/pycon-uk-2017/lazy-sequences-working-hard.html" rel="alternate"></link><published>2017-10-28T11:30:00+01:00</published><updated>2017-10-28T11:30:00+01:00</updated><author><name>Thomas Guest</name></author><id>tag:pyvideo.org,2017-10-28:pycon-uk-2017/lazy-sequences-working-hard.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python has no problem handling large and even infinite streams of data. Just write lazy programs – code which defers data access until the last minute. This talk examines Python’s language and library support for such delaying tactics. There will be live coding, and we’ll draw parallels with similar features in other languages, in particular the Unix shell.&lt;/p&gt;
</summary></entry></feed>