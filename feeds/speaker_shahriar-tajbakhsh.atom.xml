<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_shahriar-tajbakhsh.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2016-07-31T00:00:00+00:00</updated><entry><title>Parallelism Shootout: threads vs asyncio vs multiple processes</title><link href="https://pyvideo.org/europython-2015/parallelism-shootout-threads-vs-asyncio-vs-multiple-processes.html" rel="alternate"></link><published>2015-08-02T00:00:00+00:00</published><updated>2015-08-02T00:00:00+00:00</updated><author><name>Shahriar Tajbakhsh</name></author><id>tag:pyvideo.org,2015-08-02:europython-2015/parallelism-shootout-threads-vs-asyncio-vs-multiple-processes.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Shahriar Tajbakhsh - Parallelism Shootout: threads vs asyncio vs multiple processes
[EuroPython 2015]
[24 July 2015]
[Bilbao, Euskadi, Spain]&lt;/p&gt;
&lt;p&gt;You need to download data from lots and lots of URLs stored in a text
file and then save them on your machine. Sure, you could write a loop
and get each URL in sequence, but imagine that there are so many URLs
that the sun may burn out before that loop is finished; or, you're
just too impatient.&lt;/p&gt;
&lt;p&gt;For the sake of making this instructive, pretend you can only use one
box. So, what do you do? Here are some typical solutions: Use a single
process that creates lots of threads. Use many processes. Use a single
process and a library like asyncio, gevent or eventlet to yield
between coroutines when the OS blocks on IO.&lt;/p&gt;
&lt;p&gt;The talk will walk through the mechanics of each approach, and then
show benchmarks of the three different approaches.&lt;/p&gt;
</summary></entry><entry><title>Go for Python Programmers</title><link href="https://pyvideo.org/europython-2016/go-for-python-programmers.html" rel="alternate"></link><published>2016-07-31T00:00:00+00:00</published><updated>2016-07-31T00:00:00+00:00</updated><author><name>Shahriar Tajbakhsh</name></author><id>tag:pyvideo.org,2016-07-31:europython-2016/go-for-python-programmers.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Shahriar Tajbakhsh - Go for Python Programmers
[EuroPython 2016]
[19 July 2016]
[Bilbao, Euskadi, Spain]
(&lt;a class="reference external" href="https://ep2016.europython.eu//conference/talks/go-for-python-programmers"&gt;https://ep2016.europython.eu//conference/talks/go-for-python-programmers&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;A side-by-side walkthrough of basic Go history, syntax, semantics and
tools compared to Python.&lt;/p&gt;
&lt;hr class="docutils" /&gt;
&lt;p&gt;There's been quite a bit of hype around Go for some time. In
particular within the Python community, we've seen some engineers
moving their stack from Python to Go or starting their new project in
Go. This talk is &lt;strong&gt;not&lt;/strong&gt; about whether you should move from Python to
Go. Instead, this talk is for those who've been hearing all about all
the hype but haven't yet had a chance to take a proper look at Go.&lt;/p&gt;
&lt;p&gt;We'll first _very_ briefly look at Go and Python's history. Then we'll
go through a high-level side-by-side walkthrough of basic Go syntax
and semantics compared to Python. Finally, we'll have a brief look at
a subset of the ecosystem and tools available to Go and Python
programmers for certain tasks such as testing, code formatting,
documentation generation etc.&lt;/p&gt;
&lt;p&gt;By the end, you will not be a Go programmer but you'll have a high-
level feel for how the Go language operates.&lt;/p&gt;
</summary></entry></feed>