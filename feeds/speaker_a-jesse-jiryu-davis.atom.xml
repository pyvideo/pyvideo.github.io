<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_a-jesse-jiryu-davis.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2019-05-03T11:30:00+00:00</updated><entry><title>API Evolution the Right Way</title><link href="https://pyvideo.org/pycon-ca-2018/api-evolution-the-right-way.html" rel="alternate"></link><published>2018-11-10T00:00:00+00:00</published><updated>2018-11-10T00:00:00+00:00</updated><author><name>A. Jesse Jiryu Davis</name></author><id>tag:pyvideo.org,2018-11-10:pycon-ca-2018/api-evolution-the-right-way.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Library maintainers, how can you innovate without breaking projects that depend on you? Follow semantic versioning, add APIs conservatively, add parameters compatibly, write an upgrade guide, use DeprecationWarnings, and publish a deprecation policy. Break backwards compatibility rarely and wisely.&lt;/p&gt;
&lt;p&gt;Staff Engineer at MongoDB in New York City specializing in C, Python, and async. Lead developer of the MongoDB C Driver libraries libbson and libmongoc. Author of Motor, an async MongoDB driver for Tornado and asyncio. Contributor to Python, PyMongo, MongoDB, Tornado, and asyncio. Co-author with Guido van Rossum of “A Web Crawler With asyncio Coroutines”, a chapter in the “500 Lines or Less” book in the Architecture of Open Source Applications series.&lt;/p&gt;
&lt;p&gt;Blogs at emptysquare.net and for the PSF at pyfound.blogspot.com&lt;/p&gt;
&lt;p&gt;Presentation page:  &lt;a class="reference external" href="https://2018.pycon.ca/talks/talk-PC-53789/"&gt;https://2018.pycon.ca/talks/talk-PC-53789/&lt;/a&gt;&lt;/p&gt;
</summary></entry><entry><title>API Evolution the Right Way</title><link href="https://pyvideo.org/pycon-us-2019/api-evolution-the-right-way.html" rel="alternate"></link><published>2019-05-03T11:30:00+00:00</published><updated>2019-05-03T11:30:00+00:00</updated><author><name>A. Jesse Jiryu Davis</name></author><id>tag:pyvideo.org,2019-05-03:pycon-us-2019/api-evolution-the-right-way.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;If you maintain a library, how can you innovate without breaking the
projects that depend on it? Follow semantic versioning, add APIs
conservatively, add parameters compatibly, use DeprecationWarnings and
publish a deprecation policy, guide your users on how to upgrade, and
make wise choices about when to break backwards compatibility.&lt;/p&gt;
</summary><category term="talk"></category></entry><entry><title>Grok the GIL: Write Fast And Thread-Safe Python</title><link href="https://pyvideo.org/pycon-us-2017/grok-the-gil-write-fast-and-thread-safe-python.html" rel="alternate"></link><published>2017-05-19T00:00:00+00:00</published><updated>2017-05-19T00:00:00+00:00</updated><author><name>A. Jesse Jiryu Davis</name></author><id>tag:pyvideo.org,2017-05-19:pycon-us-2017/grok-the-gil-write-fast-and-thread-safe-python.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;I wrote Python for years while holding mistaken notions about the Global
Interpreter Lock, and I've met others in the same boat. The GIL's effect
is simply this: only one thread can execute Python code at a time, while
N other threads sleep or await network I/O. Let's read CPython
interpreter source and try some examples to grok the GIL, and learn to
write fast and thread-safe Python.&lt;/p&gt;
</summary></entry><entry><title>Python Performance Profiling: The Guts And The Glory</title><link href="https://pyvideo.org/pygotham-2016/python-performance-profiling-the-guts-and-the-glory.html" rel="alternate"></link><published>2016-07-16T00:00:00+00:00</published><updated>2016-07-16T00:00:00+00:00</updated><author><name>A. Jesse Jiryu Davis</name></author><id>tag:pyvideo.org,2016-07-16:pygotham-2016/python-performance-profiling-the-guts-and-the-glory.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Your Python program is too slow, and you need to optimize it. Where do you start? Optimization is a scientific investigation, just like debugging is: you generate hypotheses about how to make your program faster, then use benchmarks as the experiments that test your hypotheses. With the right tools, you can optimize your code where it counts. With the Python profiler “Yappi” to understand its features and limitations we’ll learn how to find the maximum performance wins with minimum effort.&lt;/p&gt;
</summary></entry><entry><title>Write an Excellent Programming Blog</title><link href="https://pyvideo.org/pycon-us-2016/a-jesse-jiryu-davis-write-an-excellent-programming-blog-pycon-2016.html" rel="alternate"></link><published>2016-06-01T00:00:00+00:00</published><updated>2016-06-01T00:00:00+00:00</updated><author><name>A. Jesse Jiryu Davis</name></author><id>tag:pyvideo.org,2016-06-01:pycon-us-2016/a-jesse-jiryu-davis-write-an-excellent-programming-blog-pycon-2016.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Speaker: A. Jesse Jiryu Davis&lt;/p&gt;
&lt;p&gt;Writing rewards you and benefits us all: when you write you refine your thinking, share your knowledge, and connect with your niche community. This talk describes the special challenges of writing a programming blog. It outlines solid article structures, and offers methods for generating ideas and writing more skillfully. Get the guidance and inspiration to craft articles of enduring value.&lt;/p&gt;
&lt;p&gt;Slides can be found at: &lt;a class="reference external" href="https://speakerdeck.com/pycon2016"&gt;https://speakerdeck.com/pycon2016&lt;/a&gt; and &lt;a class="reference external" href="https://github.com/PyCon/2016-slides"&gt;https://github.com/PyCon/2016-slides&lt;/a&gt;&lt;/p&gt;
</summary></entry><entry><title>How Do Python Coroutines Work?</title><link href="https://pyvideo.org/pygotham-2015/how-do-python-coroutines-work.html" rel="alternate"></link><published>2015-08-16T00:00:00+00:00</published><updated>2015-08-16T00:00:00+00:00</updated><author><name>A. Jesse Jiryu Davis</name></author><id>tag:pyvideo.org,2015-08-16:pygotham-2015/how-do-python-coroutines-work.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python 3's new “asyncio” module is an efficient async framework similar
to Node. But unlike Node, it emphasizes a modern idiom called
&amp;quot;coroutines&amp;quot;, rather than callbacks. Coroutines promise the best of two
worlds: the efficiency of callbacks, but with a natural and robust
coding style similar to synchronous programming.&lt;/p&gt;
&lt;p&gt;In barely 30 minutes I live-code a Python 3 async framework. First, I
show how an async framework uses non-blocking sockets, callbacks, and an
event loop. This version of the framework is very efficient, but
callbacks make a mess of the code. Therefore, I implement coroutines
using Python generators and two classes called Future and Task, and
update my little framework to use coroutines instead of callbacks.&lt;/p&gt;
&lt;p&gt;The live-coding demo isn't just a magic trick: watch to see how simply a
coroutine-based async framework can be implemented, and gain a deep
understanding of this miraculous new programming idiom in the Python 3
standard library.&lt;/p&gt;
</summary></entry><entry><title>Python Performance Profiling: The Guts And The Glory</title><link href="https://pyvideo.org/pycon-apac-2014/python-performance-profiling-the-guts-and-the-gl.html" rel="alternate"></link><published>2014-06-27T00:00:00+00:00</published><updated>2014-06-27T00:00:00+00:00</updated><author><name>A. Jesse Jiryu Davis</name></author><id>tag:pyvideo.org,2014-06-27:pycon-apac-2014/python-performance-profiling-the-guts-and-the-gl.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Your Python program is too slow, and you need to optimize it. Where do
you start? With the right tools, you can optimize your code where it
counts. We'll explore the guts of the Python profiler Yappi to
understand its features and limitations, and learn how to find the
maximum performance wins with minimum effort.&lt;/p&gt;
&lt;p&gt;About the speaker&lt;/p&gt;
&lt;p&gt;Author of Motor, an async MongoDB driver for Tornado, and of Toro, a
library of locks and queues for Tornado coroutines. Author of
GreenletProfiler. Contributor to Python, PyMongo, MongoDB, Yappi,
Tornado, and Tulip.&lt;/p&gt;
</summary></entry><entry><title>What Is Async, How Does It Work, and When Should I Use It?</title><link href="https://pyvideo.org/pycon-apac-2014/what-is-async-how-does-it-work-and-when-should-0.html" rel="alternate"></link><published>2014-06-26T00:00:00+00:00</published><updated>2014-06-26T00:00:00+00:00</updated><author><name>A. Jesse Jiryu Davis</name></author><id>tag:pyvideo.org,2014-06-26:pycon-apac-2014/what-is-async-how-does-it-work-and-when-should-0.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Python's asynchronous frameworks, like asyncio, Tornado, and Twisted,
are increasingly important for writing high-performance web
applications. Even if you're an experienced web programmer, you may lack
a rigorous understanding of how these frameworks work and when to use
them. Let's see how asyncio's event loop works, and learn how to
efficiently handle very large numbers of concurrent connections.&lt;/p&gt;
&lt;p&gt;Attendees will learn when to use async and when not to. They'll learn
about asyncio, a major new feature in the Python 3.4 standard library:
what it is, how it works, and how to use it for high-concurrency web
programming.&lt;/p&gt;
&lt;p&gt;About the speaker&lt;/p&gt;
&lt;p&gt;Author of Motor, an async MongoDB driver for Tornado, and of Toro, a
library of locks and queues for Tornado coroutines. Author of
GreenletProfiler. Contributor to Python, PyMongo, MongoDB, Yappi,
Tornado, and Tulip.&lt;/p&gt;
</summary></entry><entry><title>What Is Async, How Does It Work, And When Should I Use It?</title><link href="https://pyvideo.org/pycon-us-2014/what-is-async-how-does-it-work-and-when-should.html" rel="alternate"></link><published>2014-04-12T00:00:00+00:00</published><updated>2014-04-12T00:00:00+00:00</updated><author><name>A. Jesse Jiryu Davis</name></author><id>tag:pyvideo.org,2014-04-12:pycon-us-2014/what-is-async-how-does-it-work-and-when-should.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;Python's asynchronous frameworks, like Tulip, Tornado, and Twisted, are
increasingly important for writing high-performance web applications.
Even if you're an experienced web programmer, you may lack a rigorous
understanding of how these frameworks work and when to use them. Let's
see how Tulip's event loop works, and learn how to efficiently handle
very large numbers of concurrent connections.&lt;/p&gt;
</summary></entry><entry><title>Eventually Correct: Testing Async Apps</title><link href="https://pyvideo.org/pycon-us-2015/eventually-correct-testing-async-apps.html" rel="alternate"></link><published>2015-04-12T00:00:00+00:00</published><updated>2015-04-12T00:00:00+00:00</updated><author><name>A. Jesse Jiryu Davis</name></author><id>tag:pyvideo.org,2015-04-12:pycon-us-2015/eventually-correct-testing-async-apps.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Async frameworks like Tornado and asyncio scramble our usual strategies
for writing sequential code. This is most problematic when writing
tests: how can you validate the outcome when you don’t know when to
expect it? This talk introduces you to methods and practices for
unittesting async applications.&lt;/p&gt;
</summary></entry><entry><title>Python Performance Profiling: The Guts And The Glory</title><link href="https://pyvideo.org/pycon-us-2015/python-performance-profiling-the-guts-and-the-gl-0.html" rel="alternate"></link><published>2015-04-12T00:00:00+00:00</published><updated>2015-04-12T00:00:00+00:00</updated><author><name>A. Jesse Jiryu Davis</name></author><id>tag:pyvideo.org,2015-04-12:pycon-us-2015/python-performance-profiling-the-guts-and-the-gl-0.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Your Python program is too slow, and you need to optimize it. Where do
you start? With the right tools, you can optimize your code where it
counts. We’ll explore the guts of the Python profiler “Yappi” to
understand its features and limitations. We’ll learn how to find the
maximum performance wins with minimum effort.&lt;/p&gt;
</summary></entry></feed>