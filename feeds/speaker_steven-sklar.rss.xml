<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PyVideo.org</title><link>https://pyvideo.org/</link><description></description><lastBuildDate>Sun, 13 May 2018 00:00:00 +0000</lastBuildDate><item><title>The Hare Wins the Race: Getting the most out of RabbitMQ in distributed applications</title><link>https://pyvideo.org/pycon-us-2018/the-hare-wins-the-race-getting-the-most-out-of-rabbitmq-in-distributed-applications.html</link><description>&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;As web apps grow increasingly complex, distributing asynchronous work
across multiple background workers is often a basic requirement of a
performant app. While there are a variety of tools that exist to solve
this issue, one common feature among them is the need for a robust
messaging platform.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://www.rabbitmq.com/"&gt;RabbitMQ&lt;/a&gt; is a stable, full-featured, and mature solution that is
usually found in the Python ecosystem backing &lt;a class="reference external" href="http://www.celeryproject.org/"&gt;Celery&lt;/a&gt; implementations.
While Celeryâ€™s utilization of RabbitMQ works just fine out of the gate,
users with complex workflows, unique constraints, or tight budgets can
take advantage of the flexibility of RabbitMQ to streamline their data
pipelines and get the most out of their infrastructure.&lt;/p&gt;
&lt;p&gt;This talk will provide an overview of RabbitMQ, review its varied
message-routing capabilities, and demonstrate some of the ways in which
these features can be utilized in Python applications to solve common
yet difficult use-cases.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Steven Sklar</dc:creator><pubDate>Sun, 13 May 2018 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:pyvideo.org,2018-05-13:pycon-us-2018/the-hare-wins-the-race-getting-the-most-out-of-rabbitmq-in-distributed-applications.html</guid><category>celery</category><category>rabbitmq</category></item></channel></rss>