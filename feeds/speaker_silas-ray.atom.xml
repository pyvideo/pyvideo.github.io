<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_silas-ray.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2015-08-16T00:00:00+00:00</updated><entry><title>Metaclasses and Decorators in the Wild: Ingesting Data With FeedEater</title><link href="https://pyvideo.org/pygotham-2015/metaclasses-and-decorators-in-the-wild-ingesting.html" rel="alternate"></link><published>2015-08-16T00:00:00+00:00</published><updated>2015-08-16T00:00:00+00:00</updated><author><name>Silas Ray</name></author><id>tag:pyvideo.org,2015-08-16:pygotham-2015/metaclasses-and-decorators-in-the-wild-ingesting.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;FeedEater is a small library (&lt;a class="reference external" href="https://github.com/Suitey/FeedEater"&gt;https://github.com/Suitey/FeedEater&lt;/a&gt;) I
wrote at TripleMint that we use to manage the interface between data
sources with disparate formats and our DB. This talk runs through the
basic principles involved and shows how the pieces fit together. If you
are interested in Python metaprogramming but have never been able to see
how to use it practically, this is a good example of using it in the
real world.&lt;/p&gt;
</summary></entry></feed>