<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_cesare-di-mauro.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2019-05-05T00:00:00+00:00</updated><entry><title>Ternary CPUs: how they work and how Python helps designing one</title><link href="https://pyvideo.org/pycon-italia-2019/ternary-cpus-how-they-work-and-how-python-helps-designing-one.html" rel="alternate"></link><published>2019-05-05T00:00:00+00:00</published><updated>2019-05-05T00:00:00+00:00</updated><author><name>Cesare Di Mauro</name></author><id>tag:pyvideo.org,2019-05-05:pycon-italia-2019/ternary-cpus-how-they-work-and-how-python-helps-designing-one.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;0/1, False/True, off/on, etc.: the computers which we’re working on are
based, from very long time, on the so called binary arithmetic/logic.&lt;/p&gt;
&lt;p&gt;“Two states to rule them all&amp;quot;: with these we built a complete ecosystem
which goes from the hardware to the software… showing even this text
that you’re reading now.&lt;/p&gt;
&lt;p&gt;However the possibility to use the ternary logic instead, that started
just a joke some years ago, generated recent papers and researches about
it, with interesting features exploited and documented.&lt;/p&gt;
&lt;p&gt;An FPGA project is in development to implement a “ternary CPU” and an
ISA (Instruction Set Architecture) draft was roughly defined (and
evolving).&lt;/p&gt;
&lt;p&gt;But a CPU without code to execute is useless and here comes Python,
which allows to quickly implement (and test) some simple, primitive
assembler to generate executables (&amp;quot;ternaries”?), which can then be
transferred to the FPGA board and run.&lt;/p&gt;
&lt;p&gt;A basic emulator with a minimal set of instructions is implemented, in
order to test the code even without the physical board.&lt;/p&gt;
&lt;p&gt;This talk provides a short overview of the ternary logic, some
challenges, and how the basic assembler and emulator are written,
tested, and work.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Feedback form:&lt;/strong&gt; &lt;a class="reference external" href="https://python.it/feedback-1793"&gt;https://python.it/feedback-1793&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;in __on &lt;strong&gt;Sunday 5 May&lt;/strong&gt; at 10:15 &lt;a class="reference external" href="/en/sprints/schedule/pycon10/"&gt;**See
schedule**&lt;/a&gt;&lt;/p&gt;
</summary><category term="TernaryLogic"></category><category term="Assembler"></category><category term="emulator"></category><category term="CPU"></category></entry><entry><title>x86/x64 assembly + Python = new CPU architecture (to rule the world)</title><link href="https://pyvideo.org/europython-2013/x86x64-assembly-python-new-cpu-architecture-to-rule-the-world.html" rel="alternate"></link><published>2013-07-05T00:00:00+00:00</published><updated>2013-07-05T00:00:00+00:00</updated><author><name>Cesare Di Mauro</name></author><id>tag:pyvideo.org,2013-07-05:europython-2013/x86x64-assembly-python-new-cpu-architecture-to-rule-the-world.html</id><summary type="html"></summary></entry><entry><title>Hacking PyLongObject on Python 3.2</title><link href="https://pyvideo.org/europython-2011/hacking-pylongobject-on-python-32.html" rel="alternate"></link><published>2011-07-13T00:00:00+00:00</published><updated>2011-07-13T00:00:00+00:00</updated><author><name>Cesare Di Mauro</name></author><id>tag:pyvideo.org,2011-07-13:europython-2011/hacking-pylongobject-on-python-32.html</id><summary type="html">&lt;h3&gt;Summary&lt;/h3&gt;&lt;p&gt;[EuroPython 2011] Cesare Di Mauro - 24 June 2011 in &amp;quot;Track Ravioli &amp;quot;&lt;/p&gt;
&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Beginning with Python 3 the old integer (&amp;quot;int&amp;quot;) type has gone leaving
the place to &amp;quot;long&amp;quot;, which replaced it giving a unique, uniform type to
deal with integers. However longs need a more complex structure which
effectively dropped a bit of Python 3.x performance. Looking at their
implementation, an idea grown that can help to improve the situation on
common sceneries (using &amp;quot;short&amp;quot; integers). A slightly changed structure
will be presented and compared with the old PyIntObject and the current
Python 3.2 PyLongObject, along with some optimizations, thoughts, and
issues found on the road, which will show the effort required by such
change on a Python core element.&lt;/p&gt;
</summary><category term="hacking"></category></entry><entry><title>Writing an 8086 emulator</title><link href="https://pyvideo.org/pycon-italia-2015/writing-an-8086-emulator.html" rel="alternate"></link><published>2015-06-09T00:00:00+00:00</published><updated>2015-06-09T00:00:00+00:00</updated><author><name>Cesare Di Mauro</name></author><id>tag:pyvideo.org,2015-06-09:pycon-italia-2015/writing-an-8086-emulator.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;An 8086 emulator written in Python is presented. The talk gives a brief
introduction to the 8086 architecture, the pitfalls on emulating it, and
the challenge to have a working model ready to be quickly ported in C
(which is the final goal of the project). Some classes are presented
that try to “mimic” the C memory pointers handling, to make the port
easier. A set of APIs is shown, which are exposed to the emulator
“consumers” (applications, drivers, or kernels). Finally, some words are
spent about how testing is done and can be reused by the C version as
well.&lt;/p&gt;
</summary></entry></feed>