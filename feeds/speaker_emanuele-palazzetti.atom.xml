<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_emanuele-palazzetti.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2017-10-06T00:00:00+00:00</updated><entry><title>Speed up your Django apps with Jython and SPDY</title><link href="https://pyvideo.org/europython-2013/speed-up-your-django-apps-with-jython-and-spdy.html" rel="alternate"></link><published>2013-07-03T00:00:00+00:00</published><updated>2013-07-03T00:00:00+00:00</updated><author><name>Emanuele Palazzetti</name></author><id>tag:pyvideo.org,2013-07-03:europython-2013/speed-up-your-django-apps-with-jython-and-spdy.html</id><summary type="html"></summary><category term="spdy"></category><category term="jython"></category><category term="jetty"></category><category term="django"></category></entry><entry><title>Context propagation for Python concurrency models</title><link href="https://pyvideo.org/pygotham-2017/context-propagation-for-python-concurrency-models.html" rel="alternate"></link><published>2017-10-06T00:00:00+00:00</published><updated>2017-10-06T00:00:00+00:00</updated><author><name>Emanuele Palazzetti</name></author><id>tag:pyvideo.org,2017-10-06:pygotham-2017/context-propagation-for-python-concurrency-models.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Asynchronous Python can dramatically improve application performance by allowing work during traditional waiting periods. But when asynchronous libraries and frameworks are used to build web applications, request data often needs to be manually propagated across functions. Usually these frameworks provide a clean way to attach such context to the request object itself so it can be retrieved later in the route handler.&lt;/p&gt;
&lt;p&gt;Explicitly passing the request or context objects from function to function can be time consuming and tedious. It is also error prone, especially when the code base is big and different teams are responsible for passing context data to inner functions.&lt;/p&gt;
&lt;p&gt;At Datadog we faced these problems when we started to support asyncio and asynchronous web frameworks in our Application Performance Monitoring (APM) service. In this talk Emanuele will go over some techniques that his team used in the Python APM client to add in-process context propagation, explaining how it fits in the wide world of python concurrency models and simplifies context propagation, while maintaining asynchronous Python performance.&lt;/p&gt;
</summary></entry><entry><title>Da sito web a dati JSON in 30 minuti con Scrapy</title><link href="https://pyvideo.org/pycon-italia-2014/da-sito-web-a-dati-json-in-30-minuti-con-scrapy.html" rel="alternate"></link><published>2014-05-24T00:00:00+00:00</published><updated>2014-05-24T00:00:00+00:00</updated><author><name>Emanuele Palazzetti</name></author><id>tag:pyvideo.org,2014-05-24:pycon-italia-2014/da-sito-web-a-dati-json-in-30-minuti-con-scrapy.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Scrapy è un framework open source che consente di estrarre dati strutturati da un sito web in maniera semplice e veloce. Sebbene nato per il web scraping, Scrapy può essere utilizzato anche per scopi diversi, dal crawling al monitoring fino al testing di applicazioni web.&lt;/p&gt;
&lt;p&gt;Il talk si aprirà con una panoramica del framework illustrandone le peculiarità e le potenzialità, in seguito verrà mostrato un caso d'uso reale a dimostrazione della rapidità con cui grazie a Scrapy è possibile implementare un sistema di crawling, analisi e storaging di dati provenienti da pagine web.&lt;/p&gt;
</summary></entry></feed>