<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PyVideo.org</title><link href="https://pyvideo.org/" rel="alternate"></link><link href="https://pyvideo.org/feeds/speaker_paul-barry.atom.xml" rel="self"></link><id>https://pyvideo.org/</id><updated>2016-11-06T00:00:00+00:00</updated><entry><title>My 25 year love/hate relationship with databases</title><link href="https://pyvideo.org/pycon-ireland-2015/my-25-year-lovehate-relationship-with-databases.html" rel="alternate"></link><published>2015-10-25T00:00:00+00:00</published><updated>2015-10-25T00:00:00+00:00</updated><author><name>Paul Barry</name></author><id>tag:pyvideo.org,2015-10-25:pycon-ireland-2015/my-25-year-lovehate-relationship-with-databases.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;We all use existing decorators all the time (athough Python 3.5 is overloading the &amp;#64; symbol, which will likely confuse a lot of us ol' timers). However, writing a decorator ourselves can sometimes be daunting. This talk/tutorial walks through an example case study which demonstrates when to create a decorator (and why), and proves - all being well - that decorators aren't all that scary afterall.&lt;/p&gt;
</summary></entry><entry><title>The Bluffer's Guide to Data Science</title><link href="https://pyvideo.org/pycon-ireland-2016/the-bluffers-guide-to-data-science.html" rel="alternate"></link><published>2016-11-06T00:00:00+00:00</published><updated>2016-11-06T00:00:00+00:00</updated><author><name>Paul Barry</name></author><id>tag:pyvideo.org,2016-11-06:pycon-ireland-2016/the-bluffers-guide-to-data-science.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;A light-hearted look at the world of Data Science for Python programmers
who are eyeing-up the Data Science problem domain and thinking: &amp;quot;It
can't be all that hard, can it?&amp;quot;. In his talk, Paul presents his
thinking on what Python programmers need to know in order to
convincingly pass themselves off as a &amp;quot;real&amp;quot; Data Scientist.&lt;/p&gt;
</summary></entry><entry><title>Try, try, and try again</title><link href="https://pyvideo.org/pycon-ireland-2016/try-try-and-try-again.html" rel="alternate"></link><published>2016-11-05T00:00:00+00:00</published><updated>2016-11-05T00:00:00+00:00</updated><author><name>Paul Barry</name></author><id>tag:pyvideo.org,2016-11-05:pycon-ireland-2016/try-try-and-try-again.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Writing code in Python is easier than most other programming languages.
So much so, in fact, that it's easy to quickly knock-up something to
solve a problem, especially if your code is ultimately &amp;quot;throw-away&amp;quot;. As
a language, Python's great at not getting in your way: you write your
code, it runs, then you move onto something else. But, how easy is it to
to write robust code in Python? What if your code has to hang around for
a long time? What if you need to write code which not only runs but also
has to handle problems should they occur? In this talk, Paul attempts to
answer these questions by presenting some working code, which he then
dissects to highlight some of the things that can go wrong, before
describing how it's possible to handle and survive the identified
problems (should they occur).&lt;/p&gt;
</summary></entry></feed>